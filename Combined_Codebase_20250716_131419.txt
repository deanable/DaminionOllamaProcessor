
<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Converters\BooleanToVisibilityConverter.cs">
<![CDATA[
using System;
using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace DaminionOllamaApp.Converters
{
    public class BooleanToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool b && b)
                return Visibility.Visible;
            return Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is Visibility v)
                return v == Visibility.Visible;
            return false;
        }
    }
} 
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Converters\CountToBooleanConverter.cs">
<![CDATA[
// DaminionOllamaApp/Converters/CountToBooleanConverter.cs
using System;
using System.Globalization;
using System.Windows.Data;

namespace DaminionOllamaApp.Converters // Or DaminionOllamaApp.Views if you prefer to keep converters with views
{
    public class CountToBooleanConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is int count)
            {
                return count > 0;
            }
            return false;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Converters\EnumToBooleanConverter.cs">
<![CDATA[
// DaminionOllamaApp/Converters/EnumToBooleanConverter.cs
using System;
using System.Globalization;
using System.Windows.Data;

namespace DaminionOllamaApp.Converters
{
    /// <summary>
    /// Converts a specific enum value to a boolean (true if the value matches the parameter) and back.
    /// This is used to bind RadioButtons to an enum property.
    /// </summary>
    public class EnumToBooleanConverter : IValueConverter
    {
        /// <summary>
        /// Converts the enum value to a boolean.
        /// </summary>
        /// <param name="value">The enum value from the binding source.</param>
        /// <param name="targetType">The type of the binding target property.</param>
        /// <param name="parameter">The specific enum value to check for (e.g., "Ollama" or "OpenRouter").</param>
        /// <param name="culture">The culture to use in the converter.</param>
        /// <returns>True if the value matches the parameter; otherwise, false.</returns>
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is null || parameter is null)
                return false;

            string? enumValue = value?.ToString();
            string? targetValue = parameter?.ToString();
            if (enumValue is null || targetValue is null)
                return false;

            return enumValue.Equals(targetValue, StringComparison.OrdinalIgnoreCase);
        }

        /// <summary>
        /// Converts a boolean (from a checked RadioButton) back to the corresponding enum value.
        /// </summary>
        /// <param name="value">The boolean value from the binding target.</param>
        /// <param name="targetType">The type to convert to (the enum type).</param>
        /// <param name="parameter">The specific enum value this RadioButton represents.</param>
        /// <param name="culture">The culture to use in the converter.</param>
        /// <returns>The enum value corresponding to the parameter if the RadioButton is checked.</returns>
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            // If the RadioButton is checked (value is true), return the enum value it represents.
            if (value is bool isChecked && isChecked && parameter is not null)
            {
                return Enum.Parse(targetType, parameter.ToString()!);
            }
            // Otherwise, do nothing.
            return Binding.DoNothing;
        }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Models\AppSettings.cs">
<![CDATA[
// DaminionOllamaApp/Models/AppSettings.cs
using System.ComponentModel;
using System.Security; // Required for SecureString if you choose to use it later
using System.Collections.Generic;

namespace DaminionOllamaApp.Models
{
    // NEW: Enum to define the available AI providers.
    public enum AiProvider
    {
        Ollama,
        OpenRouter,
        Gemma
    }

    public class ModelUsageInfo
    {
        public int InputTokensUsed { get; set; }
        public int OutputTokensUsed { get; set; }
        public double EstimatedSpendUSD { get; set; }
        public bool FreeTierExceeded { get; set; }
    }

    public class AppSettings : INotifyPropertyChanged
    {
        // -- AI Provider Selection --
        private AiProvider _selectedAiProvider = AiProvider.Ollama; // Default to Ollama

        // -- Existing Daminion Properties --
        private string _daminionServerUrl = "http://researchserver.juicefilm.local/daminion"; // Example default
        private string _daminionUsername = "admin";
        private string _daminionPassword = "admin"; // For simplicity now, consider SecureString later

        // -- Existing Ollama Properties --
        private string _ollamaServerUrl = "http://researchserver.juicefilm.local:11434"; // Example default
        private string _ollamaModelName = "llava:13b"; // Example default
        private string _ollamaPrompt = "Please describe this image in detail. Identify key objects, subjects, and the overall scene. If relevant, suggest suitable categories and keywords.\n\nDescription:\n\nCategories:\n- Category1\n- Category2\n\nKeywords:\n- Keyword1, Keyword2, Keyword3"; // Example default

        // -- OpenRouter Properties --
        private string _openRouterApiKey = string.Empty;
        private string _openRouterHttpReferer = "http://localhost"; // Replace with your actual app name or URL
        private string _openRouterModelName = "google/gemini-pro-vision"; // A sensible default

        // NEW: Public property for the selected AI provider
        public AiProvider SelectedAiProvider
        {
            get => _selectedAiProvider;
            set
            {
                if (_selectedAiProvider != value)
                {
                    _selectedAiProvider = value;
                    // Synchronize UseOpenRouter
                    UseOpenRouter = (value == AiProvider.OpenRouter);
                    OnPropertyChanged(nameof(SelectedAiProvider));
                }
            }
        }

        public string DaminionServerUrl
        {
            get => _daminionServerUrl;
            set
            {
                if (_daminionServerUrl != value)
                {
                    _daminionServerUrl = value;
                    OnPropertyChanged(nameof(DaminionServerUrl));
                }
            }
        }

        public string DaminionUsername
        {
            get => _daminionUsername;
            set
            {
                if (_daminionUsername != value)
                {
                    _daminionUsername = value;
                    OnPropertyChanged(nameof(DaminionUsername));
                }
            }
        }

        public string DaminionPassword // Consider changing to SecureString for better security
        {
            get => _daminionPassword;
            set
            {
                if (_daminionPassword != value)
                {
                    _daminionPassword = value;
                    OnPropertyChanged(nameof(DaminionPassword));
                }
            }
        }

        public string OllamaServerUrl
        {
            get => _ollamaServerUrl;
            set
            {
                if (_ollamaServerUrl != value)
                {
                    _ollamaServerUrl = value;
                    OnPropertyChanged(nameof(OllamaServerUrl));
                }
            }
        }

        public string OllamaModelName
        {
            get => _ollamaModelName;
            set
            {
                if (_ollamaModelName != value)
                {
                    _ollamaModelName = value;
                    OnPropertyChanged(nameof(OllamaModelName));
                }
            }
        }

        public string OllamaPrompt
        {
            get => _ollamaPrompt;
            set
            {
                if (_ollamaPrompt != value)
                {
                    _ollamaPrompt = value;
                    OnPropertyChanged(nameof(OllamaPrompt));
                }
            }
        }

        public string OpenRouterApiKey
        {
            get => _openRouterApiKey;
            set
            {
                if (_openRouterApiKey != value)
                {
                    _openRouterApiKey = value;
                    OnPropertyChanged(nameof(OpenRouterApiKey));
                }
            }
        }

        public string OpenRouterHttpReferer
        {
            get => _openRouterHttpReferer;
            set
            {
                if (_openRouterHttpReferer != value)
                {
                    _openRouterHttpReferer = value;
                    OnPropertyChanged(nameof(OpenRouterHttpReferer));
                }
            }
        }

        public string OpenRouterModelName
        {
            get => _openRouterModelName;
            set
            {
                if (_openRouterModelName != value)
                {
                    _openRouterModelName = value;
                    OnPropertyChanged(nameof(OpenRouterModelName));
                }
            }
        }

        // --- Gemma Properties ---
        private string _gemmaApiKey = string.Empty;
        private string _gemmaModelName = "gemma-3n-e2b-it";
        private string _gemmaServiceAccountJsonPath = string.Empty; // Path to service account JSON
        public string GemmaApiKey
        {
            get => _gemmaApiKey;
            set
            {
                if (_gemmaApiKey != value)
                {
                    _gemmaApiKey = value;
                    OnPropertyChanged(nameof(GemmaApiKey));
                }
            }
        }
        public string GemmaModelName
        {
            get => _gemmaModelName;
            set
            {
                if (_gemmaModelName != value)
                {
                    _gemmaModelName = value;
                    OnPropertyChanged(nameof(GemmaModelName));
                }
            }
        }
        public string GemmaServiceAccountJsonPath
        {
            get => _gemmaServiceAccountJsonPath;
            set
            {
                if (_gemmaServiceAccountJsonPath != value)
                {
                    _gemmaServiceAccountJsonPath = value;
                    OnPropertyChanged(nameof(GemmaServiceAccountJsonPath));
                }
            }
        }
        // Optional: For compatibility
        public bool UseGemma => SelectedAiProvider == AiProvider.Gemma;


        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        // ... existing properties for Daminion Tag GUIDs and Flags ...
        private string _daminionDescriptionTagGuid = string.Empty;
        private string _daminionKeywordsTagGuid = string.Empty;
        private string _daminionCategoriesTagGuid = string.Empty;
        private string _daminionFlagTagGuid = string.Empty;

        public string DaminionDescriptionTagGuid
        {
            get => _daminionDescriptionTagGuid;
            set { if (_daminionDescriptionTagGuid != value) { _daminionDescriptionTagGuid = value; OnPropertyChanged(nameof(DaminionDescriptionTagGuid)); } }
        }
        public string DaminionKeywordsTagGuid
        {
            get => _daminionKeywordsTagGuid;
            set { if (_daminionKeywordsTagGuid != value) { _daminionKeywordsTagGuid = value; OnPropertyChanged(nameof(DaminionKeywordsTagGuid)); } }
        }
        public string DaminionCategoriesTagGuid
        {
            get => _daminionCategoriesTagGuid;
            set { if (_daminionCategoriesTagGuid != value) { _daminionCategoriesTagGuid = value; OnPropertyChanged(nameof(DaminionCategoriesTagGuid)); } }
        }
        public string DaminionFlagTagGuid
        {
            get => _daminionFlagTagGuid;
            set { if (_daminionFlagTagGuid != value) { _daminionFlagTagGuid = value; OnPropertyChanged(nameof(DaminionFlagTagGuid)); } }
        }

        private bool _automaticallyUpdateFlagAfterOllama = false;
        private string _flagValueIdToClearAfterOllama = string.Empty;
        private string _flagValueIdToSetAfterOllama = string.Empty;

        public bool AutomaticallyUpdateFlagAfterOllama
        {
            get => _automaticallyUpdateFlagAfterOllama;
            set
            {
                if (_automaticallyUpdateFlagAfterOllama != value)
                {
                    _automaticallyUpdateFlagAfterOllama = value;
                    OnPropertyChanged(nameof(AutomaticallyUpdateFlagAfterOllama));
                }
            }
        }

        public string FlagValueIdToClearAfterOllama
        {
            get => _flagValueIdToClearAfterOllama;
            set
            {
                if (_flagValueIdToClearAfterOllama != value)
                {
                    _flagValueIdToClearAfterOllama = value;
                    OnPropertyChanged(nameof(FlagValueIdToClearAfterOllama));
                }
            }
        }

        public string FlagValueIdToSetAfterOllama
        {
            get => _flagValueIdToSetAfterOllama;
            set
            {
                if (_flagValueIdToSetAfterOllama != value)
                {
                    _flagValueIdToSetAfterOllama = value;
                    OnPropertyChanged(nameof(FlagValueIdToSetAfterOllama));
                }
            }
        }

        // --- Daminion Query Properties ---
        private string _daminionQueryType = string.Empty;
        private string _daminionQueryLine = string.Empty;
        private string _daminionProcessingPrompt = "Please describe this image in detail. Identify key objects, subjects, and the overall scene. If relevant, suggest suitable categories and keywords.\n\nDescription:\n\nCategories:\n- Category1\n- Category2\n\nKeywords:\n- Keyword1, Keyword2, Keyword3";

        public string DaminionQueryType
        {
            get => _daminionQueryType;
            set
            {
                if (_daminionQueryType != value)
                {
                    _daminionQueryType = value;
                    OnPropertyChanged(nameof(DaminionQueryType));
                }
            }
        }

        public string DaminionQueryLine
        {
            get => _daminionQueryLine;
            set
            {
                if (_daminionQueryLine != value)
                {
                    _daminionQueryLine = value;
                    OnPropertyChanged(nameof(DaminionQueryLine));
                }
            }
        }

        public string DaminionProcessingPrompt
        {
            get => _daminionProcessingPrompt;
            set
            {
                if (_daminionProcessingPrompt != value)
                {
                    _daminionProcessingPrompt = value;
                    OnPropertyChanged(nameof(DaminionProcessingPrompt));
                }
            }
        }

        // --- AI Provider Selection Properties ---
        private bool _useOpenRouter = false;

        public bool UseOpenRouter
        {
            get => _useOpenRouter;
            set
            {
                if (_useOpenRouter != value)
                {
                    _useOpenRouter = value;
                    // Synchronize SelectedAiProvider
                    SelectedAiProvider = value ? AiProvider.OpenRouter : AiProvider.Ollama;
                    OnPropertyChanged(nameof(UseOpenRouter));
                }
            }
        }

        // --- Usage/Spend Tracking ---
        // Key: Model name, Value: Usage info
        private Dictionary<string, ModelUsageInfo> _modelUsage = new Dictionary<string, ModelUsageInfo>();
        public Dictionary<string, ModelUsageInfo> ModelUsage
        {
            get => _modelUsage;
            set { if (_modelUsage != value) { _modelUsage = value; OnPropertyChanged(nameof(ModelUsage)); } }
        }
        // Helper to get usage for a model (creates if missing)
        public ModelUsageInfo GetOrCreateModelUsage(string modelName)
        {
            if (!_modelUsage.ContainsKey(modelName))
                _modelUsage[modelName] = new ModelUsageInfo();
            return _modelUsage[modelName];
        }

        // --- Alias Properties for Compatibility ---
        public string OllamaModel => OllamaModelName;
        public string OpenRouterModel => OpenRouterModelName;

        // --- BigQuery Billing Export Settings ---
        private string _bigQueryProjectId = string.Empty;
        private string _bigQueryDataset = string.Empty;
        private string _bigQueryTable = string.Empty;
        public string BigQueryProjectId
        {
            get => _bigQueryProjectId;
            set { if (_bigQueryProjectId != value) { _bigQueryProjectId = value; OnPropertyChanged(nameof(BigQueryProjectId)); } }
        }
        public string BigQueryDataset
        {
            get => _bigQueryDataset;
            set { if (_bigQueryDataset != value) { _bigQueryDataset = value; OnPropertyChanged(nameof(BigQueryDataset)); } }
        }
        public string BigQueryTable
        {
            get => _bigQueryTable;
            set { if (_bigQueryTable != value) { _bigQueryTable = value; OnPropertyChanged(nameof(BigQueryTable)); } }
        }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Models\DaminionQueueItem.cs">
<![CDATA[
// DaminionOllamaApp/Models/DaminionQueueItem.cs
using System.ComponentModel;
using System.IO;

namespace DaminionOllamaApp.Models
{
    // We can reuse the ProcessingStatus enum from FileQueueItem.cs
    // If it's not accessible due to namespace/file structure, you might need to move it
    // to a more common location or redeclare it here. For now, assume it's accessible.

    public class DaminionQueueItem : INotifyPropertyChanged
    {
        private long _daminionItemId;
        private string _filePath = string.Empty;
        private string _fileName = string.Empty; // Can be Daminion item name or file name
        private ProcessingStatus _status = ProcessingStatus.Unprocessed;
        private string _statusMessage = string.Empty;

        // Alias property for compatibility with existing code
        public long Id => DaminionItemId;

        public long DaminionItemId
        {
            get => _daminionItemId;
            set
            {
                if (_daminionItemId != value)
                {
                    _daminionItemId = value;
                    OnPropertyChanged(nameof(DaminionItemId));
                }
            }
        }

        public string FilePath
        {
            get => _filePath;
            set
            {
                if (_filePath != value)
                {
                    _filePath = value;
                    if (string.IsNullOrEmpty(_fileName) && !string.IsNullOrEmpty(_filePath))
                    {
                        FileName = Path.GetFileName(_filePath);
                    }
                    OnPropertyChanged(nameof(FilePath));
                }
            }
        }

        public string FileName // Could be Daminion item's title or filename
        {
            get => _fileName;
            set
            {
                if (_fileName != value)
                {
                    _fileName = value;
                    OnPropertyChanged(nameof(FileName));
                }
            }
        }

        public ProcessingStatus Status
        {
            get => _status;
            set
            {
                if (_status != value)
                {
                    _status = value;
                    OnPropertyChanged(nameof(Status));
                }
            }
        }

        public string StatusMessage
        {
            get => _statusMessage;
            set
            {
                if (_statusMessage != value)
                {
                    _statusMessage = value;
                    OnPropertyChanged(nameof(StatusMessage));
                }
            }
        }

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        public DaminionQueueItem(long daminionId, string initialName = "Loading...")
        {
            DaminionItemId = daminionId;
            FileName = initialName; // Initially set to item ID or a placeholder
            Status = ProcessingStatus.Unprocessed;
            StatusMessage = "Awaiting path information.";
        }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Models\FileQueueItem.cs">
<![CDATA[
// DaminionOllamaApp/Models/FileQueueItem.cs
using System.ComponentModel;
using System.IO; // Required for Path
using System.Runtime.CompilerServices; // Required for CallerMemberName
using System.Collections.Generic; // Required for EqualityComparer

namespace DaminionOllamaApp.Models
{
    public enum ProcessingStatus
    {
        Unprocessed,
        Queued,
        Processing,
        Processed,
        Completed, // Added missing status
        Error,
        Cancelled
    }

    public class FileQueueItem : INotifyPropertyChanged
    {
        private string _filePath = string.Empty;
        private string _fileName = string.Empty;
        private ProcessingStatus _status = ProcessingStatus.Unprocessed;
        private string _statusMessage = string.Empty;
        private long? _daminionItemId; // <-- NEW PROPERTY
        private string _mimeType = "image/jpeg";

        public long? DaminionItemId // <-- NEW PROPERTY
        {
            get => _daminionItemId;
            set { SetProperty(ref _daminionItemId, value); }
        }

        public string FilePath
        {
            get => _filePath;
            set
            {
                if (SetProperty(ref _filePath, value))
                {
                    // Only update FileName from FilePath if FileName wasn't explicitly set by a constructor that takes fileName
                    if (string.IsNullOrEmpty(_fileName) && !string.IsNullOrEmpty(_filePath))
                    {
                        FileName = Path.GetFileName(_filePath); // FileName setter will call OnPropertyChanged
                    }
                }
            }
        }

        public string FileName
        {
            get => _fileName;
            // Allow public set for cases where filename might be different from Path.GetFileName (e.g. Daminion title)
            set { SetProperty(ref _fileName, value); }
        }

        public ProcessingStatus Status
        {
            get => _status;
            set { SetProperty(ref _status, value); }
        }

        public string StatusMessage
        {
            get => _statusMessage;
            set { SetProperty(ref _statusMessage, value); }
        }

        public string MimeType
        {
            get => _mimeType;
            set { SetProperty(ref _mimeType, value); }
        }

        // --- NEW READ-ONLY PROPERTY ---
        public string DisplayIdentifier
        {
            get
            {
                if (DaminionItemId.HasValue)
                {
                    return $"Daminion ID: {DaminionItemId.Value}";
                }
                return FilePath; // Or Path.GetFileName(FilePath) if you prefer just the name as fallback
            }
        }
        // --- END NEW READ-ONLY PROPERTY ---

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = "")
        {
            if (EqualityComparer<T>.Default.Equals(storage, value)) return false;
            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = "")
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        // Constructor for local files
        public FileQueueItem(string filePath)
        {
            FilePath = filePath; // Sets _filePath and calls OnPropertyChanged for FilePath
                                 // FileName is set by FilePath setter if _fileName is empty
            if (string.IsNullOrEmpty(_fileName) && !string.IsNullOrEmpty(filePath)) // Explicitly ensure FileName is set if not already
            {
                FileName = Path.GetFileName(filePath);
            }
            Status = ProcessingStatus.Unprocessed;
            StatusMessage = string.Empty;
            MimeType = "image/jpeg";
        }

        // Constructor for Daminion items (includes Daminion ID and allows specific initial name)
        public FileQueueItem(string filePath, string initialFileName, long daminionId)
        {
            DaminionItemId = daminionId;
            FilePath = filePath; // Sets _filePath and calls OnPropertyChanged for FilePath
            FileName = initialFileName; // Explicitly set FileName
            Status = ProcessingStatus.Unprocessed;
            StatusMessage = string.Empty;
            MimeType = "image/jpeg";
        }

        public FileQueueItem() { MimeType = "image/jpeg"; } // Parameterless for XAML design-time if needed/used
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Models\QueryTypeDisplayItem.cs">
<![CDATA[
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DaminionOllamaApp.Models
{
    // Add this class definition within the DaminionOllamaApp.ViewModels namespace,
    // or in a Models file and add the appropriate using statement.
    // For simplicity here, placing it in the ViewModel file.
    public class QueryTypeDisplayItem
    {
        public string DisplayName { get; set; } = string.Empty;
        public string QueryType { get; set; } = string.Empty; // Added missing property
        public string QueryLine { get; set; } = string.Empty;
        public string Operators { get; set; } = string.Empty;

        public override string ToString() => DisplayName;
    }
}

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\Views\SettingsWindow.g.cs">
<![CDATA[
#pragma checksum "..\..\..\..\Views\SettingsWindow.xaml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "9D56881B5F7C91C82166BB60E4AEDCBD34D5BD57"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DaminionOllamaApp.Converters;
using DaminionOllamaApp.ViewModels;
using DaminionOllamaApp.Views;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Controls.Ribbon;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Shell;


namespace DaminionOllamaApp.Views {
    
    
    /// <summary>
    /// SettingsWindow
    /// </summary>
    public partial class SettingsWindow : System.Windows.Window, System.Windows.Markup.IComponentConnector {
        
        
        #line 33 "..\..\..\..\Views\SettingsWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.PasswordBox DaminionPasswordBox;
        
        #line default
        #line hidden
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "9.0.7.0")]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/DaminionOllamaApp;component/views/settingswindow.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\..\..\Views\SettingsWindow.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "9.0.7.0")]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            switch (connectionId)
            {
            case 1:
            this.DaminionPasswordBox = ((System.Windows.Controls.PasswordBox)(target));
            
            #line 33 "..\..\..\..\Views\SettingsWindow.xaml"
            this.DaminionPasswordBox.PasswordChanged += new System.Windows.RoutedEventHandler(this.DaminionPasswordBox_PasswordChanged);
            
            #line default
            #line hidden
            return;
            case 2:
            
            #line 160 "..\..\..\..\Views\SettingsWindow.xaml"
            ((System.Windows.Controls.Button)(target)).Click += new System.Windows.RoutedEventHandler(this.GemmaServiceAccountBrowse_Click);
            
            #line default
            #line hidden
            return;
            }
            this._contentLoaded = true;
        }
    }
}


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\Views\SettingsWindow.g.i.cs">
<![CDATA[
#pragma checksum "..\..\..\..\Views\SettingsWindow.xaml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "9D56881B5F7C91C82166BB60E4AEDCBD34D5BD57"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DaminionOllamaApp.Converters;
using DaminionOllamaApp.ViewModels;
using DaminionOllamaApp.Views;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Controls.Ribbon;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Shell;


namespace DaminionOllamaApp.Views {
    
    
    /// <summary>
    /// SettingsWindow
    /// </summary>
    public partial class SettingsWindow : System.Windows.Window, System.Windows.Markup.IComponentConnector {
        
        
        #line 33 "..\..\..\..\Views\SettingsWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.PasswordBox DaminionPasswordBox;
        
        #line default
        #line hidden
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "9.0.7.0")]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/DaminionOllamaApp;component/views/settingswindow.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\..\..\Views\SettingsWindow.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "9.0.7.0")]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            switch (connectionId)
            {
            case 1:
            this.DaminionPasswordBox = ((System.Windows.Controls.PasswordBox)(target));
            
            #line 33 "..\..\..\..\Views\SettingsWindow.xaml"
            this.DaminionPasswordBox.PasswordChanged += new System.Windows.RoutedEventHandler(this.DaminionPasswordBox_PasswordChanged);
            
            #line default
            #line hidden
            return;
            case 2:
            
            #line 160 "..\..\..\..\Views\SettingsWindow.xaml"
            ((System.Windows.Controls.Button)(target)).Click += new System.Windows.RoutedEventHandler(this.GemmaServiceAccountBrowse_Click);
            
            #line default
            #line hidden
            return;
            }
            this._contentLoaded = true;
        }
    }
}


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs">
<![CDATA[
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\App.g.cs">
<![CDATA[
#pragma checksum "..\..\..\App.xaml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "88514ABD88AA65BE74C3914C65B33231E93773F2"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DaminionOllamaApp;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Controls.Ribbon;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Shell;


namespace DaminionOllamaApp {
    
    
    /// <summary>
    /// App
    /// </summary>
    public partial class App : System.Windows.Application {
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "9.0.7.0")]
        public void InitializeComponent() {
            
            #line 5 "..\..\..\App.xaml"
            this.StartupUri = new System.Uri("MainWindow.xaml", System.UriKind.Relative);
            
            #line default
            #line hidden
        }
        
        /// <summary>
        /// Application Entry Point.
        /// </summary>
        [System.STAThreadAttribute()]
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "9.0.7.0")]
        public static void Main() {
            DaminionOllamaApp.App app = new DaminionOllamaApp.App();
            app.InitializeComponent();
            app.Run();
        }
    }
}


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\App.g.i.cs">
<![CDATA[
#pragma checksum "..\..\..\App.xaml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "88514ABD88AA65BE74C3914C65B33231E93773F2"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DaminionOllamaApp;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Controls.Ribbon;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Shell;


namespace DaminionOllamaApp {
    
    
    /// <summary>
    /// App
    /// </summary>
    public partial class App : System.Windows.Application {
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "9.0.7.0")]
        public void InitializeComponent() {
            
            #line 5 "..\..\..\App.xaml"
            this.StartupUri = new System.Uri("MainWindow.xaml", System.UriKind.Relative);
            
            #line default
            #line hidden
        }
        
        /// <summary>
        /// Application Entry Point.
        /// </summary>
        [System.STAThreadAttribute()]
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "9.0.7.0")]
        public static void Main() {
            DaminionOllamaApp.App app = new DaminionOllamaApp.App();
            app.InitializeComponent();
            app.Run();
        }
    }
}


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+d27e96757a5cc501ab80f07942cb323fe92f9e2c")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_0basfjea_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+806f938c9567d7a6ce9c67399357baeb352bfb75")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_0basfjea_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_1krucjrt_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+deb43acf4c7d774f175810574d20a6589d19f105")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_1krucjrt_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_25wx3nwi_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+fa750d4e9601f60d14998e8f0e4ae1b4d4070e85")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_25wx3nwi_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_2hsg2p5d_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+9b9c48d3b7a33db20bcd16f1445434a5ac3140b6")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_2hsg2p5d_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_2jgddcjr_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5cf2c0f7f9d88a3b9396571cc7061567d5426d3e")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_2jgddcjr_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_2smzvxzw_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+949c3d229f0f1144e78f0817991f243a20ef7b4b")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_2smzvxzw_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_3giyl1je_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+ca72829cee285229de87e33b01b26c1cfc25ec7b")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_3giyl1je_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_431fqn5z_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+d496dcea6f6e85a14cab1fb29304af14c1750c67")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_431fqn5z_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_4afxhpp4_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+9b9c48d3b7a33db20bcd16f1445434a5ac3140b6")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_4afxhpp4_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_54dbwssy_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+806f938c9567d7a6ce9c67399357baeb352bfb75")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_54dbwssy_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_abk31o1t_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5552228ae77937f2e220dd138e4dd07d31794f49")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_abk31o1t_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_aioc1vfq_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5552228ae77937f2e220dd138e4dd07d31794f49")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_aioc1vfq_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_c3ygjk0a_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+ca72829cee285229de87e33b01b26c1cfc25ec7b")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_c3ygjk0a_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_cd43gddc_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+d5c2300a46a0fb5379361741a628ff875269edd2")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_cd43gddc_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_Content.g.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.Windows.Resources.AssemblyAssociatedContentFileAttribute("daminion-llama.ico")]



]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_Content.g.i.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.Windows.Resources.AssemblyAssociatedContentFileAttribute("daminion-llama.ico")]



]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_cxtobjqm_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+9b9c48d3b7a33db20bcd16f1445434a5ac3140b6")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_cxtobjqm_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_d4w4epxf_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+ca72829cee285229de87e33b01b26c1cfc25ec7b")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_d4w4epxf_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_du5zjt10_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+961ad223b09e9ab4fcf878bc35c32f4aa3b838db")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_du5zjt10_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_ezf5dwtu_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+844bd4e2c8b81416f5c567d0c51fc3e04fa216f7")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_ezf5dwtu_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_gbxlotng_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+867f376737b5b24e23b1cb0fdc84f18bfc7e703b")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_gbxlotng_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_iubg2aue_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+844bd4e2c8b81416f5c567d0c51fc3e04fa216f7")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_iubg2aue_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_jikrp2yi_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+d5c2300a46a0fb5379361741a628ff875269edd2")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_jikrp2yi_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_k4yu5fbj_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+0a6962a0e0663e9c3d52486339bd4dcd291b09af")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_k4yu5fbj_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_klbtuagl_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+867f376737b5b24e23b1cb0fdc84f18bfc7e703b")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_klbtuagl_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_l200bx4u_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+844bd4e2c8b81416f5c567d0c51fc3e04fa216f7")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_l200bx4u_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_ljsnk0oq_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+666b39a4d440826d3f368cb2c896df38385eed55")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_ljsnk0oq_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_mukvk3oe_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+a21a9f790566117003bdc91c12250b3709d5344e")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_mukvk3oe_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_ngslepbw_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+844bd4e2c8b81416f5c567d0c51fc3e04fa216f7")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_ngslepbw_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_nz1fy0rh_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+a21a9f790566117003bdc91c12250b3709d5344e")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_nz1fy0rh_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_ojqyog2k_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+fa750d4e9601f60d14998e8f0e4ae1b4d4070e85")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_ojqyog2k_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_op0l3jlv_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+666b39a4d440826d3f368cb2c896df38385eed55")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_op0l3jlv_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_oxqqcdgu_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+bd36f2aabe394f0e1183dab30effdc936c8220cf")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_oxqqcdgu_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_pjhci532_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+d12d69666e4bde447548da38b5fefa0638729c2f")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_pjhci532_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_py0buzze_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+a21a9f790566117003bdc91c12250b3709d5344e")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_py0buzze_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_qo1pcs21_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5552228ae77937f2e220dd138e4dd07d31794f49")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_qo1pcs21_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_t45c3ww1_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5552228ae77937f2e220dd138e4dd07d31794f49")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_t45c3ww1_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_vnfcn2y5_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+3ffb5e62f353d73f8f02b9ea5a39e606eba90c9e")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_vnfcn2y5_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_vvwkqpo4_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+844bd4e2c8b81416f5c567d0c51fc3e04fa216f7")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_vvwkqpo4_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_vxvkzxjo_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+ca72829cee285229de87e33b01b26c1cfc25ec7b")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_vxvkzxjo_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_wvgh2dfu_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+d27e96757a5cc501ab80f07942cb323fe92f9e2c")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_wvgh2dfu_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_xgeiozzf_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+ff07fd78db9ccf1d72d05238df820f3a69bf301c")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_xgeiozzf_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_zftlueht_wpftmp.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+d12d69666e4bde447548da38b5fefa0638729c2f")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaApp")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows10.0.26100.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows10.0.26100.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\DaminionOllamaApp_zftlueht_wpftmp.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.Linq;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\GeneratedInternalTypeHelper.g.cs">
<![CDATA[



]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\GeneratedInternalTypeHelper.g.i.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace XamlGeneratedNamespace {
    
    
    /// <summary>
    /// GeneratedInternalTypeHelper
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "9.0.7.0")]
    [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
    public sealed class GeneratedInternalTypeHelper : System.Windows.Markup.InternalTypeHelper {
        
        /// <summary>
        /// CreateInstance
        /// </summary>
        protected override object CreateInstance(System.Type type, System.Globalization.CultureInfo culture) {
            return System.Activator.CreateInstance(type, ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic) 
                            | (System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.CreateInstance)), null, null, culture);
        }
        
        /// <summary>
        /// GetPropertyValue
        /// </summary>
        protected override object GetPropertyValue(System.Reflection.PropertyInfo propertyInfo, object target, System.Globalization.CultureInfo culture) {
            return propertyInfo.GetValue(target, System.Reflection.BindingFlags.Default, null, null, culture);
        }
        
        /// <summary>
        /// SetPropertyValue
        /// </summary>
        protected override void SetPropertyValue(System.Reflection.PropertyInfo propertyInfo, object target, object value, System.Globalization.CultureInfo culture) {
            propertyInfo.SetValue(target, value, System.Reflection.BindingFlags.Default, null, null, culture);
        }
        
        /// <summary>
        /// CreateDelegate
        /// </summary>
        protected override System.Delegate CreateDelegate(System.Type delegateType, object target, string handler) {
            return ((System.Delegate)(target.GetType().InvokeMember("_CreateDelegate", (System.Reflection.BindingFlags.InvokeMethod 
                            | (System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)), null, target, new object[] {
                        delegateType,
                        handler}, null)));
        }
        
        /// <summary>
        /// AddEventHandler
        /// </summary>
        protected override void AddEventHandler(System.Reflection.EventInfo eventInfo, object target, System.Delegate handler) {
            eventInfo.AddEventHandler(target, handler);
        }
    }
}


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\MainWindow.g.cs">
<![CDATA[
#pragma checksum "..\..\..\MainWindow.xaml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "13A226B48B6FA2BDE0BD30AC508F6847CBD1D62E"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DaminionOllamaApp;
using DaminionOllamaApp.Converters;
using DaminionOllamaApp.Models;
using DaminionOllamaApp.ViewModels;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Controls.Ribbon;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Shell;


namespace DaminionOllamaApp {
    
    
    /// <summary>
    /// MainWindow
    /// </summary>
    public partial class MainWindow : System.Windows.Window, System.Windows.Markup.IComponentConnector {
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "9.0.7.0")]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/DaminionOllamaApp;component/mainwindow.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\..\MainWindow.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "9.0.7.0")]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            this._contentLoaded = true;
        }
    }
}


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\obj\Debug\net8.0-windows10.0.26100.0\MainWindow.g.i.cs">
<![CDATA[
#pragma checksum "..\..\..\MainWindow.xaml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "13A226B48B6FA2BDE0BD30AC508F6847CBD1D62E"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DaminionOllamaApp;
using DaminionOllamaApp.Converters;
using DaminionOllamaApp.Models;
using DaminionOllamaApp.ViewModels;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Controls.Ribbon;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Shell;


namespace DaminionOllamaApp {
    
    
    /// <summary>
    /// MainWindow
    /// </summary>
    public partial class MainWindow : System.Windows.Window, System.Windows.Markup.IComponentConnector {
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "9.0.7.0")]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/DaminionOllamaApp;component/mainwindow.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\..\MainWindow.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "9.0.7.0")]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            this._contentLoaded = true;
        }
    }
}


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Services\BigQueryBillingClient.cs">
<![CDATA[
using System;
using System.Threading.Tasks;
using Google.Cloud.BigQuery.V2;
using Google.Apis.Auth.OAuth2;
using System.IO;

namespace DaminionOllamaApp.Services
{
    public class BigQueryBillingClient
    {
        private readonly string _projectId;
        private readonly string _dataset;
        private readonly string _table;
        private readonly string _serviceAccountJsonPath;

        public BigQueryBillingClient(string projectId, string dataset, string table, string serviceAccountJsonPath)
        {
            _projectId = projectId;
            _dataset = dataset;
            _table = table;
            _serviceAccountJsonPath = serviceAccountJsonPath;
        }

        public async Task<double> GetCurrentMonthSpendUSDAsync()
        {
            // Authenticate using the service account JSON
            GoogleCredential credential;
            using (var stream = new FileStream(_serviceAccountJsonPath, FileMode.Open, FileAccess.Read))
            {
                credential = GoogleCredential.FromStream(stream);
            }
            var client = await BigQueryClient.CreateAsync(_projectId, credential);

            // Get the first and last day of the current month
            var now = DateTime.UtcNow;
            var firstDay = new DateTime(now.Year, now.Month, 1);
            var nextMonth = firstDay.AddMonths(1);

            // Standard GCP billing export schema: cost is in the 'cost' field, usage_start_time is the timestamp
            string query = $@"
                SELECT SUM(cost) as total_cost
                FROM `{_projectId}.{_dataset}.{_table}`
                WHERE usage_start_time >= TIMESTAMP('{firstDay:yyyy-MM-dd}')
                  AND usage_start_time < TIMESTAMP('{nextMonth:yyyy-MM-dd}')
                  AND cost_type = 'regular'
            ";

            var result = await client.ExecuteQueryAsync(query, parameters: null);
            foreach (var row in result)
            {
                if (row["total_cost"] != null && double.TryParse(row["total_cost"].ToString(), out double cost))
                {
                    return cost;
                }
            }
            return 0.0;
        }
    }
} 
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Services\GemmaApiClient.cs">
<![CDATA[
using System;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Linq;
using Serilog;
using System.IO;
using Google.Apis.Auth.OAuth2;
using Google.Apis.Auth.OAuth2.Responses;

namespace DaminionOllamaApp.Services
{
    public class GemmaApiClient
    {
        private readonly string _modelName;
        private readonly string _serviceAccountJsonPath;
        private readonly HttpClient _httpClient;
        private string? _accessToken;
        private DateTime _accessTokenExpiry;
        // Use the correct Gemini/Gemma API scope
        private static readonly string[] Scopes = new[] { "https://www.googleapis.com/auth/generative-language" };

        public GemmaApiClient(string serviceAccountJsonPath, string modelName)
        {
            _serviceAccountJsonPath = serviceAccountJsonPath;
            // Ensure model name is always prefixed with 'models/'
            if (!string.IsNullOrWhiteSpace(modelName) && !modelName.StartsWith("models/"))
                _modelName = $"models/{modelName}";
            else
                _modelName = modelName;
            _httpClient = new HttpClient();
            _httpClient.BaseAddress = new Uri($"https://generativelanguage.googleapis.com/v1beta/models/{_modelName}:generateContent");
            _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
        }

        private async Task<string> GetAccessTokenAsync()
        {
            if (!string.IsNullOrEmpty(_accessToken) && DateTime.UtcNow < _accessTokenExpiry)
            {
                return _accessToken;
            }
            GoogleCredential credential;
            using (var stream = new FileStream(_serviceAccountJsonPath, FileMode.Open, FileAccess.Read))
            {
                credential = GoogleCredential.FromStream(stream).CreateScoped(Scopes);
            }
            var token = await credential.UnderlyingCredential.GetAccessTokenForRequestAsync();
            // Token expiry is not directly available, so set a conservative expiry (50 min)
            _accessToken = token;
            _accessTokenExpiry = DateTime.UtcNow.AddMinutes(50);
            return _accessToken;
        }

        // Helper to get model name for endpoint (no double 'models/' prefix)
        private string GetModelNameForEndpoint()
        {
            return _modelName.StartsWith("models/") ? _modelName.Substring("models/".Length) : _modelName;
        }

        // Overload for text-only prompt
        public async Task<string> GenerateContentAsync(string prompt)
        {
            return await GenerateContentAsync(prompt, null, null);
        }

        // Overload for prompt + image
        public async Task<string> GenerateContentAsync(string prompt, byte[]? imageBytes, string? imageMimeType)
        {
            await GetAccessTokenAsync(); // Changed to EnsureAccessTokenAsync()
            var modelNameForUrl = GetModelNameForEndpoint();
            var endpoint = $"https://generativelanguage.googleapis.com/v1beta/models/{modelNameForUrl}:generateContent";
            _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", _accessToken); // Use _accessToken

            var parts = new List<object> { new { text = prompt } };
            if (imageBytes != null && !string.IsNullOrEmpty(imageMimeType))
            {
                parts.Add(new {
                    inline_data = new {
                        mime_type = imageMimeType,
                        data = Convert.ToBase64String(imageBytes)
                    }
                });
            }
            var payload = new
            {
                contents = new[]
                {
                    new
                    {
                        role = "user",
                        parts = parts.ToArray()
                    }
                }
            };

            var payloadJson = JsonSerializer.Serialize(payload);
            if (App.Logger != null)
            {
                App.Logger.Log($"[Gemma] Sending request to endpoint: {endpoint}");
                App.Logger.Log($"[Gemma] Model: {_modelName}");
                App.Logger.Log($"[Gemma] Payload: {payloadJson.Substring(0, Math.Min(payloadJson.Length, 1000))}{(payloadJson.Length > 1000 ? "..." : "")}");
            }
            var content = new StringContent(payloadJson, Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync(endpoint, content);
            var responseBody = await response.Content.ReadAsStringAsync();

            if (!response.IsSuccessStatusCode)
            {
                if (App.Logger != null)
                {
                    App.Logger.Log($"[Gemma] Error response: {response.StatusCode} - {responseBody}");
                }
                throw new Exception($"Gemma API error: {response.StatusCode} - {responseBody}");
            }

            return responseBody;
        }

        public async Task<List<string>> ListModelsAsync()
        {
            var models = new List<string>();
            try
            {
                var accessToken = await GetAccessTokenAsync();
                _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", accessToken);
                var url = "https://generativelanguage.googleapis.com/v1beta/models";
                var response = await _httpClient.GetAsync(url);
                var responseBody = await response.Content.ReadAsStringAsync();

                // Centralized logging: log the raw response body to the main app log
                if (App.Logger != null)
                {
                    App.Logger.Log($"[Gemma] Raw response from {url}: {responseBody}");
                }

                if (!response.IsSuccessStatusCode)
                {
                    if (App.Logger != null)
                    {
                        App.Logger.Log($"[Gemma] ListModelsAsync failed. Status: {response.StatusCode}, Body: {responseBody}");
                    }
                    return models;
                }
                using var doc = JsonDocument.Parse(responseBody);
                if (doc.RootElement.TryGetProperty("models", out var modelsElement))
                {
                    foreach (var model in modelsElement.EnumerateArray())
                    {
                        if (model.TryGetProperty("name", out var nameProp))
                        {
                            var name = nameProp.GetString();
                            if (!string.IsNullOrWhiteSpace(name))
                            {
                                models.Add(name);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                if (App.Logger != null)
                {
                    App.Logger.Log($"[Gemma] Exception in ListModelsAsync: {ex.Message}\n{ex}");
                }
            }
            return models;
        }
    }
} 
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Services\GoogleBillingApiClient.cs">
<![CDATA[
using System;
using System.Net.Http;
using System.Threading.Tasks;
using System.Text.Json;
using System.IO;
using Google.Apis.Auth.OAuth2;
using System.Net.Http.Headers;

namespace DaminionOllamaApp.Services
{
    public class GoogleBillingApiClient
    {
        private readonly string _serviceAccountJsonPath;
        private string? _accessToken;
        private DateTime _accessTokenExpiry;
        private static readonly string[] Scopes = new[] { "https://www.googleapis.com/auth/cloud-billing.readonly" };

        public GoogleBillingApiClient(string serviceAccountJsonPath)
        {
            _serviceAccountJsonPath = serviceAccountJsonPath;
        }

        private async Task<string> GetAccessTokenAsync()
        {
            if (!string.IsNullOrEmpty(_accessToken) && DateTime.UtcNow < _accessTokenExpiry)
            {
                return _accessToken;
            }
            GoogleCredential credential;
            using (var stream = new FileStream(_serviceAccountJsonPath, FileMode.Open, FileAccess.Read))
            {
                credential = GoogleCredential.FromStream(stream).CreateScoped(Scopes);
            }
            var token = await credential.UnderlyingCredential.GetAccessTokenForRequestAsync();
            _accessToken = token;
            _accessTokenExpiry = DateTime.UtcNow.AddMinutes(50);
            return _accessToken;
        }

        /// <summary>
        /// Fetches the current month's spend for the given project using the Cloud Billing API.
        /// </summary>
        /// <param name="projectId">The GCP project ID (e.g., "my-gemini-project")</param>
        /// <returns>The spend in USD, or -1 if unavailable.</returns>
        public async Task<double> GetCurrentMonthSpendAsync(string projectId)
        {
            // NOTE: The Cloud Billing API does not provide real-time spend per project directly.
            // For a production implementation, use BigQuery billing export or Budgets API for more detail.
            // Here, we simulate a call and return a stub value.

            // Example endpoint: GET https://cloudbilling.googleapis.com/v1/projects/{projectId}/billingInfo
            // This only returns billing account info, not spend.

            // For demonstration, return a stub value:
            await Task.Delay(100); // Simulate network
            return -1; // -1 means unavailable
        }
    }
} 
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Services\GoogleCloudResourceHelper.cs">
<![CDATA[
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Google.Apis.Auth.OAuth2;
using Google.Apis.Services;
using Google.Apis.CloudResourceManager.v1;
using Google.Cloud.BigQuery.V2;
using System.IO;
using System.Linq;

namespace DaminionOllamaApp.Services
{
    public static class GoogleCloudResourceHelper
    {
        public static async Task<List<string>> ListProjectsAsync(string serviceAccountJsonPath)
        {
            GoogleCredential credential;
            using (var stream = new FileStream(serviceAccountJsonPath, FileMode.Open, FileAccess.Read))
            {
                credential = GoogleCredential.FromStream(stream).CreateScoped(CloudResourceManagerService.Scope.CloudPlatform);
            }
            var service = new CloudResourceManagerService(new BaseClientService.Initializer
            {
                HttpClientInitializer = credential,
                ApplicationName = "DaminionOllamaApp"
            });
            var request = service.Projects.List();
            var result = await request.ExecuteAsync();
            var projects = new List<string>();
            if (result.Projects != null)
            {
                foreach (var project in result.Projects)
                {
                    if (project.LifecycleState == "ACTIVE")
                        projects.Add(project.ProjectId);
                }
            }
            return projects;
        }

        public static async Task<List<string>> ListDatasetsAsync(string projectId, string serviceAccountJsonPath)
        {
            GoogleCredential credential;
            using (var stream = new FileStream(serviceAccountJsonPath, FileMode.Open, FileAccess.Read))
            {
                credential = GoogleCredential.FromStream(stream);
            }
            var client = await BigQueryClient.CreateAsync(projectId, credential);
            var datasets = new List<string>();
            await foreach (var dataset in client.ListDatasetsAsync())
            {
                datasets.Add(dataset.Reference.DatasetId);
            }
            return datasets;
        }

        public static async Task<List<string>> ListTablesAsync(string projectId, string datasetId, string serviceAccountJsonPath)
        {
            GoogleCredential credential;
            using (var stream = new FileStream(serviceAccountJsonPath, FileMode.Open, FileAccess.Read))
            {
                credential = GoogleCredential.FromStream(stream);
            }
            var client = await BigQueryClient.CreateAsync(projectId, credential);
            var tables = new List<string>();
            await foreach (var table in client.ListTablesAsync(datasetId))
            {
                tables.Add(table.Reference.TableId);
            }
            return tables;
        }

        public static async Task<bool> IsBillingExportTableAsync(string projectId, string datasetId, string tableId, string serviceAccountJsonPath)
        {
            GoogleCredential credential;
            using (var stream = new FileStream(serviceAccountJsonPath, FileMode.Open, FileAccess.Read))
            {
                credential = GoogleCredential.FromStream(stream);
            }
            var client = await BigQueryClient.CreateAsync(projectId, credential);
            var table = await client.GetTableAsync(datasetId, tableId);
            // Check for required fields in the billing export schema
            return table.Schema.Fields.Any(f => f.Name == "cost") && table.Schema.Fields.Any(f => f.Name == "usage_start_time");
        }
    }
} 
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Services\LogService.cs">
<![CDATA[
using System;
using System.IO;

namespace DaminionOllamaApp.Services
{
    public class LogService : IDisposable
    {
        private readonly string _logFilePath;
        private readonly StreamWriter _writer;
        private bool _disposed = false;

        public LogService()
        {
            // Use the application's base directory for logs
            string appRoot = AppDomain.CurrentDomain.BaseDirectory;
            string logsFolder = Path.Combine(appRoot, "logs");
            Directory.CreateDirectory(logsFolder); // Ensure the logs directory exists
            string timestamp = DateTime.Now.ToString("yyyyMMdd-HHmmss");
            string logFileName = $"log-{timestamp}.txt";
            _logFilePath = Path.Combine(logsFolder, logFileName);
            _writer = new StreamWriter(_logFilePath, append: false) { AutoFlush = true };
            Log($"Log started at {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        }

        public void Log(string message)
        {
            string logEntry = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}";
            _writer.WriteLine(logEntry);
        }

        public void Dispose()
        {
            if (!_disposed)
            {
                _writer?.Dispose();
                _disposed = true;
            }
        }
    }
} 
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Services\ProcessingService.cs">
<![CDATA[
// DaminionOllamaApp/Services/ProcessingService.cs
using DaminionOllamaApp.Models;
using DaminionOllamaInteractionLib.Ollama;
using DaminionOllamaInteractionLib.OpenRouter;
using DaminionOllamaInteractionLib.Services; // For ImageMetadataService
using System;
using System.IO;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using DaminionOllamaApp;

namespace DaminionOllamaApp.Services
{
    public class ProcessingService
    {
        public async Task ProcessLocalFileAsync(
            FileQueueItem item,
            AppSettings settings,
            Action<string> reportProgress,
            CancellationToken cancellationToken)
        {
            if (item == null || settings == null)
            {
                reportProgress?.Invoke($"Error: File item or settings are null for {item?.FileName ?? "Unknown File"}.");
                if (App.Logger != null) App.Logger.Log($"Error: File item or settings are null for {item?.FileName ?? "Unknown File"}.");
                if (item != null) item.Status = ProcessingStatus.Error;
                return;
            }

            try
            {
                if (App.Logger != null)
                {
                    App.Logger.Log($"Settings at processing start for {item.FileName}: UseOpenRouter={settings.UseOpenRouter}, OpenRouterModelName={settings.OpenRouterModelName}, OllamaModelName={settings.OllamaModelName}, OllamaServerUrl={settings.OllamaServerUrl}");
                }
                item.Status = ProcessingStatus.Processing;
                item.StatusMessage = "Starting...";
                reportProgress?.Invoke($"Processing: {item.FileName} - Reading file...");
                if (App.Logger != null) App.Logger.Log($"Processing started for {item.FileName}");

                if (cancellationToken.IsCancellationRequested)
                {
                    item.Status = ProcessingStatus.Cancelled;
                    item.StatusMessage = "Cancelled before starting.";
                    reportProgress?.Invoke($"Cancelled: {item.FileName}");
                    if (App.Logger != null) App.Logger.Log($"Processing cancelled before starting for {item.FileName}");
                    return;
                }

                // 1. Read image bytes
                if (App.Logger != null) App.Logger.Log($"Reading file bytes for {item.FileName}");
                byte[] imageBytes;
                try
                {
                    imageBytes = await File.ReadAllBytesAsync(item.FilePath, cancellationToken);
                    if (App.Logger != null) App.Logger.Log($"File bytes read for {item.FileName}, size: {imageBytes.Length} bytes");
                }
                catch (Exception ex)
                {
                    item.Status = ProcessingStatus.Error;
                    item.StatusMessage = $"Error reading file: {ex.Message}";
                    reportProgress?.Invoke($"Error: {item.FileName} - {item.StatusMessage}");
                    if (App.Logger != null) App.Logger.Log($"Error reading file {item.FileName}: {ex.Message}");
                    return;
                }

                if (settings.UseOpenRouter)
                {
                    if (App.Logger != null) App.Logger.Log($"Preparing OpenRouter request payload for {item.FileName}");
                }
                else
                {
                    if (App.Logger != null) App.Logger.Log($"Preparing Ollama request payload for {item.FileName}");
                }

                reportProgress?.Invoke($"Processing: {item.FileName} - Sending to Ollama...");
                if (App.Logger != null) App.Logger.Log($"Sending {item.FileName} to AI provider: {(settings.UseOpenRouter ? "OpenRouter" : "Ollama")}");
                if (cancellationToken.IsCancellationRequested) throw new OperationCanceledException(cancellationToken);

                // 2. Call AI API (Ollama, OpenRouter, or Gemma)
                string? aiResponse;
                string usedModelName = null;
                int inputTokens = 0; // Placeholder, update with real token count if available
                int outputTokens = 0; // Placeholder, update with real token count if available
                try
                {
                    if (settings.SelectedAiProvider == AiProvider.Gemma)
                    {
                        if (App.Logger != null) App.Logger.Log($"Sending request to Gemma for {item.FileName} (Model: {settings.GemmaModelName}, MimeType: {item.MimeType ?? "image/jpeg"})");
                        var gemmaClient = new GemmaApiClient(settings.GemmaServiceAccountJsonPath, settings.GemmaModelName);
                        var gemmaResult = await gemmaClient.GenerateContentAsync(settings.OllamaPrompt, imageBytes, item.MimeType ?? "image/jpeg");
                        aiResponse = gemmaResult != null ? gemmaResult : string.Empty;
                        usedModelName = settings.GemmaModelName;
                        // TODO: Parse token usage from response if available
                        if (App.Logger != null) App.Logger.Log($"Gemma response for {item.FileName}: {aiResponse.Substring(0, Math.Min(aiResponse.Length, 500))}");
                        if (string.IsNullOrWhiteSpace(aiResponse))
                        {
                            throw new Exception("Gemma returned an empty response");
                        }
                    }
                    else if (settings.UseOpenRouter)
                    {
                        // Log request metadata
                        if (App.Logger != null)
                        {
                            App.Logger.Log($"OpenRouter request metadata for {item.FileName}: Model={settings.OpenRouterModelName}, PromptSnippet={settings.OllamaPrompt.Substring(0, Math.Min(settings.OllamaPrompt.Length, 100))}, ImageSize={imageBytes.Length} bytes, ImageBase64Snippet={Convert.ToBase64String(imageBytes).Substring(0, 40)}...");
                        }
                        var openRouterClient = new OpenRouterApiClient(settings.OpenRouterApiKey, settings.OpenRouterHttpReferer);
                        // Pre-check API key by listing models
                        var modelCheck = await openRouterClient.ListModelsAsync();
                        if (modelCheck == null)
                        {
                            if (App.Logger != null) App.Logger.Log($"OpenRouter API key check failed for {item.FileName}: Unable to list models. Aborting.");
                            item.Status = ProcessingStatus.Error;
                            item.StatusMessage = "OpenRouter API key invalid or unauthorized.";
                            reportProgress?.Invoke($"Error: {item.FileName} - {item.StatusMessage}");
                            return;
                        }
                        if (App.Logger != null) App.Logger.Log($"OpenRouter API key check succeeded for {item.FileName}: Models listed.");
                        var openRouterResult = await openRouterClient.AnalyzeImageAsync(
                            settings.OpenRouterModelName, 
                            settings.OllamaPrompt, 
                            imageBytes);
                        usedModelName = settings.OpenRouterModelName;
                        // TODO: Parse token usage from response if available
                        if (App.Logger != null)
                        {
                            App.Logger.Log($"OpenRouter response for {item.FileName}: StatusCode={openRouterResult.StatusCode}, ContentSnippet={openRouterResult.Content?.Substring(0, Math.Min(openRouterResult.Content?.Length ?? 0, 200))}, ErrorMessage={openRouterResult.ErrorMessage}, RawResponseSnippet={openRouterResult.RawResponse?.Substring(0, Math.Min(openRouterResult.RawResponse?.Length ?? 0, 500))}");
                        }
                        aiResponse = openRouterResult.Content ?? string.Empty;
                        if (string.IsNullOrWhiteSpace(aiResponse))
                        {
                            throw new Exception("OpenRouter returned an empty response");
                        }
                    }
                    else
                    {
                        if (App.Logger != null) App.Logger.Log($"Sending request to Ollama for {item.FileName}");
                        OllamaApiClient ollamaClient = new OllamaApiClient(settings.OllamaServerUrl);
                        OllamaGenerateResponse? ollamaResponse = await ollamaClient.AnalyzeImageAsync(settings.OllamaModelName, settings.OllamaPrompt, imageBytes);
                        usedModelName = settings.OllamaModelName;
                        // Ollama is always free, so no spend tracking
                        if (App.Logger != null) App.Logger.Log($"Ollama response received for {item.FileName}: {ollamaResponse?.Response?.Substring(0, Math.Min(ollamaResponse?.Response?.Length ?? 0, 200))}");
                        if (ollamaResponse == null || !ollamaResponse.Done || string.IsNullOrWhiteSpace(ollamaResponse.Response))
                        {
                            throw new Exception($"Ollama returned an empty or invalid response. API Message: {ollamaResponse?.Response?.Substring(0, Math.Min(ollamaResponse.Response?.Length ?? 0, 100)) ?? "N/A"}");
                        }
                        aiResponse = ollamaResponse.Response;
                    }
                }
                catch (HttpRequestException ex)
                {
                    var serviceName = settings.UseOpenRouter ? "OpenRouter" : "Ollama";
                    item.Status = ProcessingStatus.Error;
                    item.StatusMessage = $"{serviceName} connection error: {ex.Message}";
                    reportProgress?.Invoke($"Error: {item.FileName} - {item.StatusMessage}");
                    if (App.Logger != null) App.Logger.Log($"{serviceName} connection error for {item.FileName}: {ex.Message}");
                    return;
                }
                catch (TaskCanceledException ex)
                {
                    var serviceName = settings.UseOpenRouter ? "OpenRouter" : "Ollama";
                    item.Status = ProcessingStatus.Error;
                    item.StatusMessage = $"{serviceName} request timed out: {ex.Message}";
                    reportProgress?.Invoke($"Error: {item.FileName} - {item.StatusMessage}");
                    if (App.Logger != null) App.Logger.Log($"{serviceName} request timed out for {item.FileName}: {ex.Message}");
                    return;
                }
                catch (Exception ex)
                {
                    var serviceName = settings.UseOpenRouter ? "OpenRouter" : "Ollama";
                    item.Status = ProcessingStatus.Error;
                    item.StatusMessage = $"{serviceName} API error: {ex.Message}";
                    reportProgress?.Invoke($"Error: {item.FileName} - {item.StatusMessage}");
                    if (App.Logger != null) App.Logger.Log($"{serviceName} API error for {item.FileName}: {ex.Message}");
                    return;
                }

                // --- Usage/Spend Tracking ---
                if (!string.IsNullOrEmpty(usedModelName))
                {
                    var usage = settings.GetOrCreateModelUsage(usedModelName);
                    // For now, increment by 1 request; update with real token counts if available
                    usage.InputTokensUsed += inputTokens > 0 ? inputTokens : 1000; // Assume 1K tokens/request as a placeholder
                    usage.OutputTokensUsed += outputTokens;
                    // Look up pricing
                    if (DaminionOllamaApp.Services.ModelPricingTable.Pricing.TryGetValue(usedModelName, out var pricing))
                    {
                        int paidInputTokens = Math.Max(0, usage.InputTokensUsed - pricing.FreeInputTokens);
                        int paidOutputTokens = Math.Max(0, usage.OutputTokensUsed - pricing.FreeOutputTokens);
                        usage.EstimatedSpendUSD = (paidInputTokens / 1000.0) * pricing.PricePer1KInputTokens + (paidOutputTokens / 1000.0) * pricing.PricePer1KOutputTokens;
                        usage.FreeTierExceeded = usage.InputTokensUsed > pricing.FreeInputTokens;
                    }
                    else
                    {
                        usage.EstimatedSpendUSD = 0;
                        usage.FreeTierExceeded = false;
                    }
                }

                if (App.Logger != null) App.Logger.Log($"Parsing AI response for {item.FileName}");
                if (cancellationToken.IsCancellationRequested) throw new OperationCanceledException(cancellationToken);

                // Log the raw model response for debugging parser issues
                if (App.Logger != null)
                {
                    App.Logger.Log($"[AI Raw Response] {item.FileName}: {aiResponse}");
                }
                // 3. Parse AI response
                ParsedOllamaContent parsedContent = OllamaResponseParser.ParseLlavaResponse(aiResponse);
                if (!parsedContent.SuccessfullyParsed)
                {
                    item.Status = ProcessingStatus.Error;
                    // If parsing fails but we have a description, use the raw response as description.
                    // Otherwise, indicate parsing failure.
                    if (!string.IsNullOrWhiteSpace(aiResponse) && string.IsNullOrWhiteSpace(parsedContent.Description) && !parsedContent.Keywords.Any() && !parsedContent.Categories.Any())
                    {
                        parsedContent.Description = aiResponse; // Fallback
                        parsedContent.SuccessfullyParsed = true; // Consider it parsed as a single block
                        reportProgress?.Invoke($"Warning: {item.FileName} - Could not parse structured data, using full response as description.");
                    }
                    else
                    {
                        item.StatusMessage = "Failed to parse structured data from AI response.";
                        reportProgress?.Invoke($"Error: {item.FileName} - {item.StatusMessage}");
                        return;
                    }
                }


                reportProgress?.Invoke($"Processing: {item.FileName} - Writing metadata to file...");
                if (cancellationToken.IsCancellationRequested) throw new OperationCanceledException(cancellationToken);

                // 4. Write metadata to image file
                try
                {
                    // Using ImageMetadataService as it's more comprehensive
                    var metadataService = new ImageMetadataService(item.FilePath);
                    metadataService.Read(); // Read existing metadata first
                    metadataService.PopulateFromOllamaContent(parsedContent);
                    metadataService.Save(); // Save changes

                    item.Status = ProcessingStatus.Processed;
                    item.StatusMessage = "Metadata written successfully.";
                    reportProgress?.Invoke($"Success: {item.FileName} - Metadata written.");
                }
                catch (Exception ex)
                {
                    item.Status = ProcessingStatus.Error;
                    item.StatusMessage = $"Error writing metadata: {ex.Message}";
                    reportProgress?.Invoke($"Error: {item.FileName} - {item.StatusMessage}");
                    return;
                }
            }
            catch (OperationCanceledException)
            {
                item.Status = ProcessingStatus.Cancelled;
                item.StatusMessage = "Processing cancelled by user.";
                reportProgress?.Invoke($"Cancelled: {item.FileName}");
            }
            catch (Exception ex)
            {
                item.Status = ProcessingStatus.Error;
                item.StatusMessage = $"Unexpected error: {ex.Message}";
                reportProgress?.Invoke($"Error: {item.FileName} - {item.StatusMessage}");
            }
        }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Services\SettingsService.cs">
<![CDATA[
// DaminionOllamaApp/Services/SettingsService.cs
using DaminionOllamaApp.Models;
using System;
using System.IO;
using System.Text.Json;
using DaminionOllamaApp.Services; // Add this for App.Logger
using System.Collections.Generic; // Add this for Dictionary

namespace DaminionOllamaApp.Services
{
    public class SettingsService
    {
        private static readonly string AppName = "DaminionOllamaApp";
        private static readonly string SettingsFileName = "settings.json";
        private readonly string _settingsFilePath;

        public SettingsService()
        {
            // Store settings in a subdirectory within the user's LocalApplicationData folder
            string appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
            string appSpecificFolder = Path.Combine(appDataPath, AppName);
            Directory.CreateDirectory(appSpecificFolder); // Ensure the directory exists
            _settingsFilePath = Path.Combine(appSpecificFolder, SettingsFileName);
        }

        public AppSettings LoadSettings()
        {
            try
            {
                if (File.Exists(_settingsFilePath))
                {
                    string json = File.ReadAllText(_settingsFilePath);
                    var settings = JsonSerializer.Deserialize<AppSettings>(json);
                    return settings ?? new AppSettings(); // Return new settings if deserialization fails
                }
            }
            catch (Exception ex)
            {
                // Log or handle the exception (e.g., corrupted settings file)
                if (App.Logger != null)
                {
                    App.Logger.Log($"Error loading settings: {ex.Message}");
                }
                else
                {
                    Console.Error.WriteLine($"Error loading settings: {ex.Message}");
                }
            }
            return new AppSettings(); // Return default settings if file doesn't exist or error occurs
        }

        public void SaveSettings(AppSettings settings)
        {
            try
            {
                string json = JsonSerializer.Serialize(settings, new JsonSerializerOptions { WriteIndented = true });
                File.WriteAllText(_settingsFilePath, json);
            }
            catch (Exception ex)
            {
                // Log or handle the exception (e.g., permission issues)
                if (App.Logger != null)
                {
                    App.Logger.Log($"Error saving settings: {ex.Message}");
                }
                else
                {
                    Console.Error.WriteLine($"Error saving settings: {ex.Message}");
                }
                // Optionally, re-throw or notify the user
            }
        }
    }

    // Add this class to hold pricing and free tier info for supported models
    public static class ModelPricingTable
    {
        // Example: Update with real values as needed
        public static readonly Dictionary<string, ModelPricingInfo> Pricing = new Dictionary<string, ModelPricingInfo>
        {
            // Gemini 1.5 Pro
            { "gemini-1.5-pro", new ModelPricingInfo { PricePer1KInputTokens = 0.005, PricePer1KOutputTokens = 0.015, FreeInputTokens = 1500000, FreeOutputTokens = 0 } },
            // Gemini 1.5 Flash
            { "gemini-1.5-flash", new ModelPricingInfo { PricePer1KInputTokens = 0.003, PricePer1KOutputTokens = 0.009, FreeInputTokens = 5000000, FreeOutputTokens = 0 } },
            // Gemma (always free)
            { "gemma-2-9b-it", new ModelPricingInfo { PricePer1KInputTokens = 0, PricePer1KOutputTokens = 0, FreeInputTokens = int.MaxValue, FreeOutputTokens = int.MaxValue } },
            { "gemma-2-27b-it", new ModelPricingInfo { PricePer1KInputTokens = 0, PricePer1KOutputTokens = 0, FreeInputTokens = int.MaxValue, FreeOutputTokens = int.MaxValue } },
        };
    }

    public class ModelPricingInfo
    {
        public double PricePer1KInputTokens { get; set; }
        public double PricePer1KOutputTokens { get; set; }
        public int FreeInputTokens { get; set; }
        public int FreeOutputTokens { get; set; }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Utils\AsyncRelayCommand.cs">
<![CDATA[
// DaminionOllamaApp/Utils/AsyncRelayCommand.cs
using System;
using System.Threading.Tasks;
using System.Windows.Input;

namespace DaminionOllamaApp.Utils
{
    public class AsyncRelayCommand : ICommand
    {
        private readonly Func<object?, Task> _execute;
        private readonly Func<bool>? _canExecute;
        private bool _isExecuting;

        public AsyncRelayCommand(Func<object?, Task> execute, Func<bool>? canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public event EventHandler? CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }

        public bool CanExecute(object? parameter)
        {
            return !_isExecuting && (_canExecute == null || _canExecute());
        }

        public async void Execute(object? parameter)
        {
            if (_isExecuting) return;

            _isExecuting = true;
            RaiseCanExecuteChanged();

            try
            {
                await _execute(parameter);
            }
            finally
            {
                _isExecuting = false;
                RaiseCanExecuteChanged();
            }
        }

        public void RaiseCanExecuteChanged()
        {
            CommandManager.InvalidateRequerySuggested();
        }
    }
} 
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Utils\RelayCommand.cs">
<![CDATA[
// DaminionOllamaApp/Utils/RelayCommand.cs
using System;
using System.Windows.Input;

namespace DaminionOllamaApp.Utils
{
    public class RelayCommand : ICommand
    {
        private readonly Action<object?> _execute;
        private readonly Predicate<object?>? _canExecute;

        public RelayCommand(Action<object?> execute, Predicate<object?>? canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public event EventHandler? CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }

        public bool CanExecute(object? parameter)
        {
            return _canExecute == null || _canExecute(parameter);
        }

        public void Execute(object? parameter)
        {
            _execute(parameter);
        }

        public void RaiseCanExecuteChanged()
        {
            CommandManager.InvalidateRequerySuggested();
        }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\ViewModels\DaminionCollectionTaggerViewModel.cs">
<![CDATA[
// DaminionOllamaApp/ViewModels/DaminionCollectionTaggerViewModel.cs
using DaminionOllamaApp.Models;
using DaminionOllamaApp.Services;
using DaminionOllamaApp.Utils;
using DaminionOllamaInteractionLib;
using DaminionOllamaInteractionLib.Daminion;
using DaminionOllamaInteractionLib.Ollama;
using DaminionOllamaInteractionLib.OpenRouter;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using Serilog;
using Serilog.Sinks.File;
using DaminionOllamaApp;

namespace DaminionOllamaApp.ViewModels
{
    /// <summary>
    /// View model responsible for managing the AI-powered tagging workflow for Daminion collection items.
    /// This class handles the complete process of:
    /// 1. Connecting to Daminion DAM system
    /// 2. Querying and loading items from the collection
    /// 3. Processing images with AI services (Ollama or OpenRouter)
    /// 4. Updating metadata back to the Daminion system
    /// 
    /// The workflow supports batch processing with progress tracking and error handling.
    /// </summary>
    public class DaminionCollectionTaggerViewModel : INotifyPropertyChanged
    {
        private static readonly ILogger Logger;
        static DaminionCollectionTaggerViewModel()
        {
            var logDir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "DaminionOllamaApp", "logs");
            Directory.CreateDirectory(logDir);
            var logPath = Path.Combine(logDir, "daminioncollectiontaggerviewmodel.log");
            Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day, retainedFileCountLimit: 7)
                .CreateLogger();
        }
        #region Private Fields
        /// <summary>
        /// Service for loading and saving application settings.
        /// </summary>
        private readonly SettingsService _settingsService;
        
        /// <summary>
        /// Client for interacting with the Daminion API.
        /// Handles authentication, item querying, and metadata updates.
        /// </summary>
        private DaminionApiClient? _daminionClient;

        /// <summary>
        /// Indicates whether the user is currently authenticated with Daminion.
        /// </summary>
        private bool _isLoggedIn;
        
        /// <summary>
        /// Current status message for the Daminion connection and operations.
        /// </summary>
        private string _daminionStatus = "Not logged in. Please configure Daminion settings and click Login.";
        
        /// <summary>
        /// Collection of available query types for loading items from Daminion.
        /// </summary>
        private ObservableCollection<QueryTypeDisplayItem> _queryTypes;
        
        /// <summary>
        /// Currently selected query type for loading items.
        /// </summary>
        private QueryTypeDisplayItem? _selectedQueryType;
        
        /// <summary>
        /// Collection of Daminion items queued for processing.
        /// </summary>
        private ObservableCollection<DaminionQueueItem> _daminionFilesToProcess;
        
        /// <summary>
        /// Indicates whether items are currently being loaded from Daminion.
        /// </summary>
        private bool _isLoadingItems;
        
        /// <summary>
        /// Indicates whether the processing queue is currently running.
        /// </summary>
        private bool _isProcessingDaminionQueue;
        
        /// <summary>
        /// Cancellation token source for stopping the processing queue.
        /// </summary>
        private CancellationTokenSource? _daminionCts;
        #endregion

        #region Public Properties
        /// <summary>
        /// Reference to the application settings containing configuration for:
        /// - Daminion server connection details
        /// - AI service preferences (Ollama/OpenRouter)
        /// - Default prompts and processing options
        /// </summary>
        public AppSettings Settings { get; }

        /// <summary>
        /// Gets or sets whether the user is authenticated with Daminion.
        /// Updates command availability when changed.
        /// </summary>
        public bool IsLoggedIn
        {
            get => _isLoggedIn;
            set { SetProperty(ref _isLoggedIn, value); UpdateCommandStates(); }
        }

        /// <summary>
        /// Gets or sets the current status message for Daminion operations.
        /// Displayed in the UI to inform users of current state.
        /// </summary>
        public string DaminionStatus
        {
            get => _daminionStatus;
            set { SetProperty(ref _daminionStatus, value); }
        }

        /// <summary>
        /// Gets the collection of available query types for loading items from Daminion.
        /// Each query type represents a different way to filter and retrieve items.
        /// </summary>
        public ObservableCollection<QueryTypeDisplayItem> QueryTypes
        {
            get => _queryTypes;
            set { SetProperty(ref _queryTypes, value); }
        }

        /// <summary>
        /// Gets or sets the currently selected query type.
        /// Updates command availability when changed.
        /// </summary>
        public QueryTypeDisplayItem? SelectedQueryType
        {
            get => _selectedQueryType;
            set 
            { 
                SetProperty(ref _selectedQueryType, value);
                UpdateCommandStates();
                
                // Update the settings with the selected query type for persistence
                if (value != null)
                {
                    Settings.DaminionQueryType = value.QueryType;
                    Settings.DaminionQueryLine = value.QueryLine;
                }
            }
        }

        /// <summary>
        /// Gets the collection of Daminion items queued for AI processing.
        /// Each item represents a media file with its current processing status.
        /// </summary>
        public ObservableCollection<DaminionQueueItem> DaminionFilesToProcess
        {
            get => _daminionFilesToProcess;
            set 
            { 
                SetProperty(ref _daminionFilesToProcess, value);
                UpdateCommandStates();
            }
        }

        /// <summary>
        /// Gets or sets whether items are currently being loaded from Daminion.
        /// Disables certain commands during loading to prevent conflicts.
        /// </summary>
        public bool IsLoadingItems
        {
            get => _isLoadingItems;
            set { SetProperty(ref _isLoadingItems, value); UpdateCommandStates(); }
        }

        /// <summary>
        /// Gets or sets whether the processing queue is currently running.
        /// Controls the availability of start/stop commands.
        /// </summary>
        public bool IsProcessingDaminionQueue
        {
            get => _isProcessingDaminionQueue;
            set { SetProperty(ref _isProcessingDaminionQueue, value); UpdateCommandStates(); }
        }
        #endregion

        #region Commands
        /// <summary>
        /// Command to authenticate with the Daminion server.
        /// </summary>
        public ICommand LoginCommand { get; }
        
        /// <summary>
        /// Command to load items from Daminion based on the selected query type.
        /// </summary>
        public ICommand LoadItemsByQueryCommand { get; }
        
        /// <summary>
        /// Command to start processing the queue of loaded Daminion items.
        /// </summary>
        public ICommand StartDaminionQueueCommand { get; }
        
        /// <summary>
        /// Command to stop the currently running processing queue.
        /// </summary>
        public ICommand StopDaminionQueueCommand { get; }
        #endregion

        #region Constructor
        /// <summary>
        /// Initializes a new instance of the DaminionCollectionTaggerViewModel.
        /// Sets up the initial state and available query types.
        /// </summary>
        /// <param name="settings">Application settings instance.</param>
        /// <param name="settingsService">Service for persisting settings.</param>
        public DaminionCollectionTaggerViewModel(AppSettings settings, SettingsService settingsService)
        {
            Settings = settings;
            _settingsService = settingsService;
            
            // Initialize collections
            _daminionFilesToProcess = new ObservableCollection<DaminionQueueItem>();
            _queryTypes = new ObservableCollection<QueryTypeDisplayItem>();
            
            // Set up available query types for different search scenarios
            InitializeQueryTypes();
            
            // Initialize commands with their respective handlers and can-execute predicates
            LoginCommand = new AsyncRelayCommand(async param => await LoginAsync(), CanLogin);
            LoadItemsByQueryCommand = new AsyncRelayCommand(async param => await LoadItemsByQueryAsync(), CanLoadItemsByQuery);
            StartDaminionQueueCommand = new AsyncRelayCommand(async param => await StartDaminionQueueProcessingAsync(), CanStartDaminionQueue);
            StopDaminionQueueCommand = new RelayCommand(param => StopDaminionQueueProcessing(), param => CanStopDaminionQueue());
        }
        #endregion

        #region Private Methods - Command State Management
        /// <summary>
        /// Updates the can-execute state of all commands based on current conditions.
        /// Called whenever a property changes that affects command availability.
        /// </summary>
        private void UpdateCommandStates()
        {
            // Trigger re-evaluation of can-execute predicates
            (LoginCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
            (LoadItemsByQueryCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
            (StartDaminionQueueCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
            (StopDaminionQueueCommand as RelayCommand)?.RaiseCanExecuteChanged();
        }

        /// <summary>
        /// Initializes the available query types for loading items from Daminion.
        /// Each query type represents a different search scenario.
        /// </summary>
        private void InitializeQueryTypes()
        {
            _queryTypes.Add(new QueryTypeDisplayItem 
            { 
                DisplayName = "All Items", 
                QueryType = "all", 
                QueryLine = "" 
            });
            _queryTypes.Add(new QueryTypeDisplayItem 
            { 
                DisplayName = "Items without Description", 
                QueryType = "no_description", 
                QueryLine = "Description is empty" 
            });
            _queryTypes.Add(new QueryTypeDisplayItem 
            { 
                DisplayName = "Items without Keywords", 
                QueryType = "no_keywords", 
                QueryLine = "Keywords is empty" 
            });
            _queryTypes.Add(new QueryTypeDisplayItem 
            { 
                DisplayName = "Items without Categories", 
                QueryType = "no_categories", 
                QueryLine = "Categories is empty" 
            });
            _queryTypes.Add(new QueryTypeDisplayItem 
            { 
                DisplayName = "Custom Query", 
                QueryType = "custom", 
                QueryLine = Settings.DaminionQueryLine 
            });
        }
        #endregion

        #region Command Handlers - Login
        /// <summary>
        /// Determines if the login command can be executed.
        /// </summary>
        /// <returns>True if login is possible, false otherwise.</returns>
        private bool CanLogin() => !IsLoggedIn && !IsLoadingItems && !IsProcessingDaminionQueue;

        /// <summary>
        /// Handles the login process to authenticate with Daminion.
        /// Validates settings and establishes a connection to the server.
        /// </summary>
        private async Task LoginAsync()
        {
            Logger.Information("Attempting Daminion login for server: {Server}", Settings.DaminionServerUrl);
            if (string.IsNullOrWhiteSpace(Settings.DaminionServerUrl) ||
                string.IsNullOrWhiteSpace(Settings.DaminionUsername) ||
                string.IsNullOrWhiteSpace(Settings.DaminionPassword))
            {
                DaminionStatus = "Please configure Daminion settings first.";
                return;
            }

            _daminionClient = new DaminionApiClient();
            DaminionStatus = $"Logging in to {Settings.DaminionServerUrl}...";
            IsLoggedIn = false;

            try
            {
                DaminionStatus = "Logging in...";
                _daminionClient ??= new DaminionApiClient();
                bool loginSuccess = await _daminionClient.LoginAsync(
                    Settings.DaminionServerUrl,
                    Settings.DaminionUsername,
                    Settings.DaminionPassword);
                Logger.Information("Daminion login result: {Result}", loginSuccess);
                if (loginSuccess)
                {
                    IsLoggedIn = true;
                    DaminionStatus = "Successfully logged in to Daminion.";
                    // Restore previously selected query type if available
                    var savedQueryType = QueryTypes.FirstOrDefault(q => q.QueryType == Settings.DaminionQueryType);
                    if (savedQueryType != null)
                    {
                        SelectedQueryType = savedQueryType;
                    }
                }
                else
                {
                    DaminionStatus = "Login failed. Please check your credentials.";
                }
            }
            catch (Exception ex)
            {
                Logger.Error(ex, "Daminion login error");
                DaminionStatus = $"Login error: {ex.Message}";
            }
        }
        #endregion

        #region Command Handlers - Load Items
        /// <summary>
        /// Determines if the load items command can be executed.
        /// </summary>
        /// <returns>True if items can be loaded, false otherwise.</returns>
        private bool CanLoadItemsByQuery() => SelectedQueryType != null && IsLoggedIn && !IsLoadingItems && !IsProcessingDaminionQueue;

        /// <summary>
        /// Loads items from Daminion based on the selected query type.
        /// Retrieves media items and their metadata for processing.
        /// </summary>
        private async Task LoadItemsByQueryAsync()
        {
            if (_daminionClient == null || SelectedQueryType == null)
                return;

            try
            {
                IsLoadingItems = true;
                DaminionStatus = "Loading items from Daminion...";
                
                // Clear existing items
                DaminionFilesToProcess.Clear();

                // Execute the search query
                var response = await _daminionClient.SearchMediaItemsAsync(
                    queryLine: SelectedQueryType.QueryLine,
                    pageSize: 100,
                    pageIndex: 0);

                if (response?.MediaItems != null)
                {
                    // Get absolute file paths for the items
                    var itemIds = response.MediaItems.Select(item => item.Id).ToList();
                    var pathResult = await _daminionClient.GetAbsolutePathsAsync(itemIds);

                    // Create queue items with file paths
                    foreach (var item in response.MediaItems)
                    {
                        var filePath = pathResult.Paths?.ContainsKey(item.Id.ToString()) == true
                            ? pathResult.Paths[item.Id.ToString()]
                            : null;

                        var queueItem = new DaminionQueueItem(item.Id, item.FileName ?? item.Name ?? $"Item {item.Id}")
                        {
                            FilePath = filePath,
                            Status = ProcessingStatus.Unprocessed,
                            StatusMessage = "Ready for processing"
                        };

                        // Add to the processing queue
                        if (queueItem != null)
                        {
                            DaminionFilesToProcess.Add(queueItem);
                        }
                    }

                    DaminionStatus = $"Loaded {DaminionFilesToProcess.Count} items from Daminion.";
                }
                else
                {
                    DaminionStatus = "No items found matching the query.";
                }
            }
            catch (Exception ex)
            {
                DaminionStatus = $"Error loading items: {ex.Message}";
            }
            finally
            {
                IsLoadingItems = false;
            }
        }
        #endregion

        #region Command Handlers - Queue Processing
        /// <summary>
        /// Determines if the queue processing can be started.
        /// </summary>
        /// <returns>True if processing can start, false otherwise.</returns>
        private bool CanStartDaminionQueue() => DaminionFilesToProcess.Any(f => (f.Status == ProcessingStatus.Unprocessed || f.Status == ProcessingStatus.Error) && !string.IsNullOrEmpty(f.FilePath)) && IsLoggedIn && !IsProcessingDaminionQueue && !IsLoadingItems;

        /// <summary>
        /// Starts the batch processing of queued Daminion items.
        /// Processes each item with AI services and updates metadata in Daminion.
        /// </summary>
        private async Task StartDaminionQueueProcessingAsync()
        {
            if (_daminionClient == null)
                return;

            try
            {
                // Initialize cancellation token for stopping the process
                _daminionCts = new CancellationTokenSource();
                IsProcessingDaminionQueue = true;
                
                UpdateOverallDaminionStatus("Processing started...");

                // Get items that need processing
                var itemsToProcess = DaminionFilesToProcess
                    .Where(f => (f.Status == ProcessingStatus.Unprocessed || f.Status == ProcessingStatus.Error) 
                                && !string.IsNullOrEmpty(f.FilePath))
                    .ToList();

                int processedCount = 0;
                int totalCount = itemsToProcess.Count;

                // Process each item individually
                foreach (var item in itemsToProcess)
                {
                    // Check for cancellation
                    if (_daminionCts.Token.IsCancellationRequested)
                    {
                        item.Status = ProcessingStatus.Cancelled;
                        item.StatusMessage = "Processing cancelled";
                        break;
                    }

                    try
                    {
                        // Update item status
                        item.Status = ProcessingStatus.Processing;
                        item.StatusMessage = "Processing...";
                        
                        UpdateOverallDaminionStatus($"Processing item {processedCount + 1} of {totalCount}: {item.FileName}");

                        // Validate file exists
                        if (!File.Exists(item.FilePath))
                        {
                            item.Status = ProcessingStatus.Error;
                            item.StatusMessage = "File not found";
                            continue;
                        }

                        // Read image data
                        byte[] imageBytes = await File.ReadAllBytesAsync(item.FilePath, _daminionCts.Token);

                        // Process with AI service
                        string aiResponse = await ProcessWithAIService(imageBytes, _daminionCts.Token);
                        
                        // Parse the AI response
                        var parsedContent = OllamaResponseParser.ParseLlavaResponse(aiResponse);
                        
                        if (!parsedContent.SuccessfullyParsed)
                        {
                            // If parsing fails but we have a response, use it as description
                            if (!string.IsNullOrWhiteSpace(aiResponse))
                            {
                                parsedContent.Description = aiResponse;
                                parsedContent.SuccessfullyParsed = true;
                            }
                            else
                            {
                                throw new Exception("Failed to parse AI response and no fallback content available");
                            }
                        }
                        
                        // Update metadata in Daminion
                        await UpdateDaminionMetadata(item.Id, parsedContent);

                        // Update item status
                        item.Status = ProcessingStatus.Completed;
                        item.StatusMessage = "Successfully processed";
                        
                        processedCount++;
                    }
                    catch (OperationCanceledException)
                    {
                        item.Status = ProcessingStatus.Cancelled;
                        item.StatusMessage = "Processing cancelled";
                        break;
                    }
                    catch (Exception ex)
                    {
                        item.Status = ProcessingStatus.Error;
                        
                        // Provide more specific error messages based on exception type
                        if (ex is HttpRequestException)
                        {
                            item.StatusMessage = $"Network error: {ex.Message}";
                        }
                        else if (ex is TaskCanceledException)
                        {
                            item.StatusMessage = $"Request timed out: {ex.Message}";
                        }
                        else if (ex.InnerException is HttpRequestException)
                        {
                            item.StatusMessage = $"Network error: {ex.InnerException.Message}";
                        }
                        else
                        {
                            item.StatusMessage = $"Processing error: {ex.Message}";
                        }
                        
                        // Log the full exception for debugging
                        if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] Error processing {item.FileName}: {ex}");
                        else Console.WriteLine($"[DaminionCollectionTaggerViewModel] Error processing {item.FileName}: {ex}");
                    }
                }

                // Update final status
                if (_daminionCts.Token.IsCancellationRequested)
                {
                    UpdateOverallDaminionStatus($"Processing cancelled. {processedCount} of {totalCount} items processed.");
                }
                else
                {
                    UpdateOverallDaminionStatus($"Processing completed. {processedCount} of {totalCount} items processed successfully.");
                }
            }
            catch (Exception ex)
            {
                UpdateOverallDaminionStatus($"Processing error: {ex.Message}");
            }
            finally
            {
                IsProcessingDaminionQueue = false;
                _daminionCts?.Dispose();
                _daminionCts = null;
            }
        }

        /// <summary>
        /// Processes an image with the configured AI service (Ollama or OpenRouter).
        /// </summary>
        /// <param name="imageBytes">The image data to process.</param>
        /// <param name="cancellationToken">Token for canceling the operation.</param>
        /// <returns>The AI-generated response text.</returns>
        private async Task<string> ProcessWithAIService(byte[] imageBytes, CancellationToken cancellationToken)
        {
            try
            {
                if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] Starting AI process. Provider: {(Settings.UseOpenRouter ? "OpenRouter" : "Ollama")}");
                if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] Preparing request payload. Image size: {imageBytes.Length} bytes");
                if (Settings.UseOpenRouter)
                {
                    if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] Sending request to OpenRouter");
                    // Log request metadata
                    if (App.Logger != null)
                    {
                        App.Logger.Log($"OpenRouter request metadata: Model={Settings.OpenRouterModel}, PromptSnippet={Settings.DaminionProcessingPrompt.Substring(0, Math.Min(Settings.DaminionProcessingPrompt.Length, 100))}, ImageSize={imageBytes.Length} bytes, ImageBase64Snippet={Convert.ToBase64String(imageBytes).Substring(0, 40)}...");
                    }
                    var openRouterClient = new OpenRouterApiClient(Settings.OpenRouterApiKey, Settings.OpenRouterHttpReferer);
                    // Pre-check API key by listing models
                    var modelCheck = await openRouterClient.ListModelsAsync();
                    if (modelCheck == null)
                    {
                        if (App.Logger != null) App.Logger.Log($"OpenRouter API key check failed: Unable to list models. Aborting.");
                        throw new Exception("OpenRouter API key invalid or unauthorized.");
                    }
                    if (App.Logger != null) App.Logger.Log($"OpenRouter API key check succeeded: Models listed.");
                    var openRouterResult = await openRouterClient.AnalyzeImageAsync(
                        Settings.OpenRouterModel, 
                        Settings.DaminionProcessingPrompt, 
                        imageBytes);
                    if (App.Logger != null)
                    {
                        App.Logger.Log($"OpenRouter response: StatusCode={openRouterResult.StatusCode}, ContentSnippet={openRouterResult.Content?.Substring(0, Math.Min(openRouterResult.Content?.Length ?? 0, 200))}, ErrorMessage={openRouterResult.ErrorMessage}, RawResponseSnippet={openRouterResult.RawResponse?.Substring(0, Math.Min(openRouterResult.RawResponse?.Length ?? 0, 500))}");
                    }
                    if (string.IsNullOrWhiteSpace(openRouterResult.Content))
                    {
                        throw new Exception("OpenRouter returned an empty response");
                    }
                    if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] Parsing OpenRouter response");
                    return openRouterResult.Content;
                }
                else if (Settings.SelectedAiProvider == AiProvider.Gemma)
                {
                    if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] Sending request to Gemma");
                    var gemmaClient = new DaminionOllamaApp.Services.GemmaApiClient(Settings.GemmaApiKey, Settings.GemmaModelName);
                    var gemmaResponse = await gemmaClient.GenerateContentAsync(Settings.DaminionProcessingPrompt);
                    if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] Gemma response: {gemmaResponse.Substring(0, Math.Min(gemmaResponse.Length, 500))}");
                    if (string.IsNullOrWhiteSpace(gemmaResponse))
                    {
                        throw new Exception("Gemma returned an empty response");
                    }
                    if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] Parsing Gemma response");
                    return gemmaResponse;
                }
                else
                {
                    if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] Sending request to Ollama");
                    var ollamaClient = new OllamaApiClient(Settings.OllamaServerUrl);
                    var response = await ollamaClient.AnalyzeImageAsync(
                        Settings.OllamaModel, 
                        Settings.DaminionProcessingPrompt, 
                        imageBytes);
                    if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] Ollama response received: {response?.Response?.Substring(0, Math.Min(response?.Response?.Length ?? 0, 200))}");
                    if (response?.Response == null)
                    {
                        throw new Exception("Ollama returned an empty response");
                    }
                    if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] Parsing Ollama response");
                    return response.Response;
                }
            }
            catch (HttpRequestException ex)
            {
                var serviceName = Settings.UseOpenRouter ? "OpenRouter" : "Ollama";
                if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] {serviceName} connection error: {ex.Message}");
                throw new Exception($"{serviceName} connection error: {ex.Message}", ex);
            }
            catch (TaskCanceledException ex)
            {
                var serviceName = Settings.UseOpenRouter ? "OpenRouter" : "Ollama";
                if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] {serviceName} request timed out: {ex.Message}");
                throw new Exception($"{serviceName} request timed out: {ex.Message}", ex);
            }
            catch (Exception ex)
            {
                var serviceName = Settings.UseOpenRouter ? "OpenRouter" : "Ollama";
                if (App.Logger != null) App.Logger.Log($"[DaminionCollectionTaggerViewModel] {serviceName} error: {ex.Message}");
                throw new Exception($"{serviceName} error: {ex.Message}", ex);
            }
        }

        /// <summary>
        /// Updates the metadata for a Daminion item with the parsed AI content.
        /// </summary>
        /// <param name="itemId">The ID of the item to update.</param>
        /// <param name="content">The parsed AI-generated content.</param>
        private async Task UpdateDaminionMetadata(long itemId, ParsedOllamaContent content)
        {
            if (_daminionClient == null)
                return;

            var operations = new List<DaminionUpdateOperation>();

            // Update description if available
            if (!string.IsNullOrWhiteSpace(content.Description))
            {
                operations.Add(new DaminionUpdateOperation
                {
                    Guid = Settings.DaminionDescriptionTagGuid,
                    Value = content.Description,
                    Remove = false
                });
            }

            // Update keywords if available
            if (content.Keywords?.Any() == true)
            {
                operations.Add(new DaminionUpdateOperation
                {
                    Guid = Settings.DaminionKeywordsTagGuid,
                    Value = string.Join(", ", content.Keywords),
                    Remove = false
                });
            }

            // Update categories if available
            if (content.Categories?.Any() == true)
            {
                operations.Add(new DaminionUpdateOperation
                {
                    Guid = Settings.DaminionCategoriesTagGuid,
                    Value = string.Join(", ", content.Categories),
                    Remove = false
                });
            }

            // Execute the updates
            if (operations.Any())
            {
                await _daminionClient.UpdateItemMetadataAsync(new List<long> { itemId }, operations);
            }
        }

        /// <summary>
        /// Updates the overall status message for the processing operation.
        /// </summary>
        /// <param name="message">The status message to display.</param>
        private void UpdateOverallDaminionStatus(string message)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                DaminionStatus = message;
            });
        }

        /// <summary>
        /// Determines if the queue processing can be stopped.
        /// </summary>
        /// <returns>True if processing can be stopped, false otherwise.</returns>
        private bool CanStopDaminionQueue() => IsProcessingDaminionQueue;

        /// <summary>
        /// Stops the currently running queue processing operation.
        /// </summary>
        private void StopDaminionQueueProcessing()
        {
            _daminionCts?.Cancel();
            UpdateOverallDaminionStatus("Stopping processing...");
        }
        #endregion

        #region INotifyPropertyChanged Implementation
        /// <summary>
        /// Event raised when a property value changes.
        /// </summary>
        public event PropertyChangedEventHandler? PropertyChanged;

        /// <summary>
        /// Sets a property value and raises the PropertyChanged event if the value has changed.
        /// </summary>
        /// <typeparam name="T">The type of the property.</typeparam>
        /// <param name="storage">Reference to the backing field.</param>
        /// <param name="value">The new value to set.</param>
        /// <param name="propertyName">The name of the property (automatically provided).</param>
        /// <returns>True if the value was changed, false otherwise.</returns>
        protected virtual bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = "")
        {
            if (EqualityComparer<T>.Default.Equals(storage, value)) return false;
            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }

        /// <summary>
        /// Raises the PropertyChanged event for the specified property.
        /// </summary>
        /// <param name="propertyName">The name of the property that changed.</param>
        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = "")
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
        #endregion
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\ViewModels\LocalFileTaggerViewModel.cs">
<![CDATA[
// DaminionOllamaApp/ViewModels/LocalFileTaggerViewModel.cs
using DaminionOllamaApp.Models;
using DaminionOllamaApp.Services;
using DaminionOllamaApp.Utils;
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using Serilog;
using System.IO;

namespace DaminionOllamaApp.ViewModels
{
    /// <summary>
    /// ViewModel for the "Local File Tagger" tab.
    /// Manages the state and logic for processing a queue of local image files.
    /// </summary>
    public class LocalFileTaggerViewModel : INotifyPropertyChanged
    {
        private static readonly ILogger Logger;
        static LocalFileTaggerViewModel()
        {
            var logDir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "DaminionOllamaApp", "logs");
            Directory.CreateDirectory(logDir);
            var logPath = Path.Combine(logDir, "localfiletaggerviewmodel.log");
            Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day, retainedFileCountLimit: 7)
                .CreateLogger();
        }

        // --- Private Fields ---
        private string _currentOperationStatus = "Ready. Add files to begin.";
        private ObservableCollection<FileQueueItem> _filesToProcess;
        private bool _isProcessingQueue;
        private CancellationTokenSource? _cancellationTokenSource;
        private FileQueueItem? _selectedFile;
        private double _actualSpendUSD = -1;

        private readonly ProcessingService _processingService;
        private readonly SettingsService _settingsService;

        // --- Public Properties ---

        /// <summary>
        /// Holds the shared application settings, passed in from the MainViewModel.
        /// This allows the ViewModel to react to global settings changes.
        /// </summary>
        public AppSettings Settings { get; }

        // Add property for free tier alert
        public bool FreeTierExceededForSelectedModel
        {
            get
            {
                var modelName = Settings.SelectedAiProvider switch
                {
                    AiProvider.Gemma => Settings.GemmaModelName,
                    AiProvider.OpenRouter => Settings.OpenRouterModelName,
                    AiProvider.Ollama => Settings.OllamaModelName,
                    _ => null
                };
                if (string.IsNullOrEmpty(modelName)) return false;
                var usage = Settings.GetOrCreateModelUsage(modelName);
                return usage.FreeTierExceeded;
            }
        }

        public double ActualSpendUSD
        {
            get => _actualSpendUSD;
            set { _actualSpendUSD = value; OnPropertyChanged(nameof(ActualSpendUSD)); OnPropertyChanged(nameof(ShowActualSpendAlert)); }
        }

        public bool ShowActualSpendAlert
        {
            get
            {
                // Use actual spend if available, else fallback to estimate
                double freeTier = GetFreeTierForSelectedModel();
                return ActualSpendUSD >= 0 && ActualSpendUSD > freeTier;
            }
        }

        public ICommand RefreshActualSpendCommand { get; }

        /// <summary>
        /// A collection of files that are queued for processing. This is bound to the ListView in the UI.
        /// </summary>
        public ObservableCollection<FileQueueItem> FilesToProcess
        {
            get => _filesToProcess;
            set
            {
                _filesToProcess = value;
                OnPropertyChanged(nameof(FilesToProcess));
            }
        }

        /// <summary>
        /// The currently selected file in the ListView.
        /// </summary>
        public FileQueueItem? SelectedFile
        {
            get => _selectedFile;
            set
            {
                if (_selectedFile != value)
                {
                    _selectedFile = value;
                    OnPropertyChanged(nameof(SelectedFile));
                    // Notify that the "Remove Selected" command's executability might have changed.
                    ((RelayCommand)RemoveSelectedFileCommand).RaiseCanExecuteChanged();
                }
            }
        }

        /// <summary>
        /// A status message displayed to the user, indicating the current operation or result.
        /// </summary>
        public string CurrentOperationStatus
        {
            get => _currentOperationStatus;
            set
            {
                _currentOperationStatus = value;
                OnPropertyChanged(nameof(CurrentOperationStatus));
            }
        }

        /// <summary>
        /// A flag indicating whether the processing queue is currently active.
        /// Used to enable/disable UI controls.
        /// </summary>
        public bool IsProcessingQueue
        {
            get => _isProcessingQueue;
            set
            {
                if (_isProcessingQueue != value)
                {
                    _isProcessingQueue = value;
                    OnPropertyChanged(nameof(IsProcessingQueue));
                    // When this property changes, update the state of all related commands.
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        ((RelayCommand)StartQueueCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)StopQueueCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)AddFilesCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)RemoveSelectedFileCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)ClearProcessedFilesCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)ClearAllFilesCommand).RaiseCanExecuteChanged();
                    });
                }
            }
        }

        // --- Commands ---
        public ICommand AddFilesCommand { get; }
        public ICommand StartQueueCommand { get; }
        public ICommand StopQueueCommand { get; }
        public ICommand RemoveSelectedFileCommand { get; }
        public ICommand ClearProcessedFilesCommand { get; }
        public ICommand ClearAllFilesCommand { get; }

        /// <summary>
        /// Initializes a new instance of the LocalFileTaggerViewModel.
        /// </summary>
        /// <param name="settings">The shared AppSettings instance.</param>
        /// <param name="settingsService">The service for loading/saving settings.</param>
        public LocalFileTaggerViewModel(AppSettings settings, SettingsService settingsService)
        {
            // Store the shared settings instance
            Settings = settings;
            _settingsService = settingsService;
            _filesToProcess = new ObservableCollection<FileQueueItem>();
            _processingService = new ProcessingService();

            // Initialize commands
            AddFilesCommand = new RelayCommand(param => AddFiles(), param => CanAddFiles());
            StartQueueCommand = new RelayCommand(async param => await StartQueueAsync(), param => CanStartQueue());
            StopQueueCommand = new RelayCommand(param => StopQueue(), param => CanStopQueue());
            RemoveSelectedFileCommand = new RelayCommand(param => RemoveSelectedFile(), param => CanRemoveSelectedFile());
            ClearProcessedFilesCommand = new RelayCommand(param => ClearProcessedFiles(), param => CanClearProcessedFiles());
            ClearAllFilesCommand = new RelayCommand(param => ClearAllFiles(), param => CanClearAllFiles());
            RefreshActualSpendCommand = new AsyncRelayCommand(_ => RefreshActualSpendAsync());
        }

        private bool CanAddFiles() => !IsProcessingQueue;
        private void AddFiles()
        {
            var openFileDialog = new OpenFileDialog
            {
                Multiselect = true,
                Filter = "Image Files (*.jpg; *.jpeg; *.png; *.bmp; *.gif; *.tiff)|*.jpg;*.jpeg;*.png;*.bmp;*.gif;*.tiff|All files (*.*)|*.*",
                Title = "Select Image Files"
            };
            if (openFileDialog.ShowDialog() == true)
            {
                int filesAddedCount = 0;
                foreach (string filePath in openFileDialog.FileNames)
                {
                    if (!FilesToProcess.Any(f => f.FilePath.Equals(filePath, StringComparison.OrdinalIgnoreCase)))
                    {
                        FilesToProcess.Add(new FileQueueItem(filePath));
                        filesAddedCount++;
                    }
                }
                CurrentOperationStatus = $"{filesAddedCount} file(s) added to the queue. {FilesToProcess.Count} total.";
                // Update command states after modifying the list
                ((RelayCommand)StartQueueCommand).RaiseCanExecuteChanged();
                ((RelayCommand)ClearAllFilesCommand).RaiseCanExecuteChanged();
                ((RelayCommand)ClearProcessedFilesCommand).RaiseCanExecuteChanged();
                LogFileQueueChange("AddFiles", new { FileCount = filesAddedCount });
            }
        }

        private bool CanStartQueue()
        {
            return !IsProcessingQueue && FilesToProcess.Any(f => f.Status == ProcessingStatus.Unprocessed || f.Status == ProcessingStatus.Error);
        }

        private async Task StartQueueAsync()
        {
            IsProcessingQueue = true;
            _cancellationTokenSource = new CancellationTokenSource();
            var token = _cancellationTokenSource.Token;

            CurrentOperationStatus = "Processing queue...";
            int processedCount = 0;
            int errorCount = 0;

            var itemsToProcessThisRun = FilesToProcess
                                        .Where(f => f.Status == ProcessingStatus.Unprocessed || f.Status == ProcessingStatus.Error)
                                        .ToList();
            foreach (var item in itemsToProcessThisRun)
            {
                if (token.IsCancellationRequested)
                {
                    item.Status = ProcessingStatus.Cancelled;
                    item.StatusMessage = "Queue stopped.";
                    break;
                }
                item.Status = ProcessingStatus.Queued;
                item.StatusMessage = "Waiting for processing...";

                // Use the shared Settings property directly
                await _processingService.ProcessLocalFileAsync(item, Settings, UpdateOverallStatus, token);

                if (item.Status == ProcessingStatus.Processed) processedCount++;
                else if (item.Status == ProcessingStatus.Error || item.Status == ProcessingStatus.Cancelled) errorCount++;
            }

            IsProcessingQueue = false;
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;
            string summary = $"Queue finished. Processed: {processedCount}, Errors/Cancelled: {errorCount}.";
            CurrentOperationStatus = summary;
            UpdateOverallStatus(summary);
            ((RelayCommand)StartQueueCommand).RaiseCanExecuteChanged();
            ((RelayCommand)ClearProcessedFilesCommand).RaiseCanExecuteChanged();
            LogFileQueueChange("StartQueueAsync", new { ProcessedCount = processedCount, ErrorCount = errorCount });
        }

        private void UpdateOverallStatus(string message)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                CurrentOperationStatus = message;
            });
        }

        private bool CanStopQueue() => IsProcessingQueue;
        private void StopQueue()
        {
            if (_cancellationTokenSource != null && !_cancellationTokenSource.IsCancellationRequested)
            {
                CurrentOperationStatus = "Stop request received. Finishing current item then stopping...";
                _cancellationTokenSource.Cancel();
                LogFileQueueChange("StopQueue");
            }
        }

        private bool CanRemoveSelectedFile() => SelectedFile != null && !IsProcessingQueue;
        private void RemoveSelectedFile()
        {
            if (SelectedFile != null)
            {
                FilesToProcess.Remove(SelectedFile);
                SelectedFile = null; // Clear selection
                CurrentOperationStatus = "Selected file removed.";
                ((RelayCommand)StartQueueCommand).RaiseCanExecuteChanged();
                ((RelayCommand)ClearAllFilesCommand).RaiseCanExecuteChanged();
                ((RelayCommand)ClearProcessedFilesCommand).RaiseCanExecuteChanged();
                LogFileQueueChange("RemoveSelectedFile", SelectedFile);
            }
        }

        private bool CanClearProcessedFiles() => FilesToProcess.Any(f => f.Status == ProcessingStatus.Processed) && !IsProcessingQueue;
        private void ClearProcessedFiles()
        {
            var processedFiles = FilesToProcess.Where(f => f.Status == ProcessingStatus.Processed).ToList();
            foreach (var file in processedFiles)
            {
                FilesToProcess.Remove(file);
            }
            CurrentOperationStatus = $"{processedFiles.Count} processed file(s) cleared.";
            ((RelayCommand)StartQueueCommand).RaiseCanExecuteChanged();
            ((RelayCommand)ClearProcessedFilesCommand).RaiseCanExecuteChanged();
            ((RelayCommand)ClearAllFilesCommand).RaiseCanExecuteChanged();
            LogFileQueueChange("ClearProcessedFiles", new { Count = processedFiles.Count });
        }

        private bool CanClearAllFiles() => FilesToProcess.Any() && !IsProcessingQueue;
        private void ClearAllFiles()
        {
            int count = FilesToProcess.Count;
            FilesToProcess.Clear();
            SelectedFile = null; // Clear selection as well
            CurrentOperationStatus = $"{count} file(s) cleared from the queue.";
            ((RelayCommand)StartQueueCommand).RaiseCanExecuteChanged();
            ((RelayCommand)ClearAllFilesCommand).RaiseCanExecuteChanged();
            ((RelayCommand)ClearProcessedFilesCommand).RaiseCanExecuteChanged();
            LogFileQueueChange("ClearAllFiles", new { Count = count });
        }

        private async Task RefreshActualSpendAsync()
        {
            if (string.IsNullOrWhiteSpace(Settings.BigQueryProjectId) ||
                string.IsNullOrWhiteSpace(Settings.BigQueryDataset) ||
                string.IsNullOrWhiteSpace(Settings.BigQueryTable) ||
                string.IsNullOrWhiteSpace(Settings.GemmaServiceAccountJsonPath))
            {
                ActualSpendUSD = -1;
                return;
            }
            var client = new BigQueryBillingClient(Settings.BigQueryProjectId, Settings.BigQueryDataset, Settings.BigQueryTable, Settings.GemmaServiceAccountJsonPath);
            try
            {
                ActualSpendUSD = await client.GetCurrentMonthSpendUSDAsync();
            }
            catch
            {
                ActualSpendUSD = -1;
            }
        }

        private double GetFreeTierForSelectedModel()
        {
            var modelName = Settings.SelectedAiProvider switch
            {
                AiProvider.Gemma => Settings.GemmaModelName,
                AiProvider.OpenRouter => Settings.OpenRouterModelName,
                AiProvider.Ollama => Settings.OllamaModelName,
                _ => null
            };
            if (string.IsNullOrEmpty(modelName)) return 0;
            if (ModelPricingTable.Pricing.TryGetValue(modelName, out var pricing))
            {
                // Free tier is for input tokens; convert to $ using input token price
                return (pricing.FreeInputTokens / 1000.0) * pricing.PricePer1KInputTokens;
            }
            return 0;
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        // Example: Log when files are added to the queue
        private void LogFileQueueChange(string action, object? details = null)
        {
            Logger.Information("File queue action: {Action}, Details: {@Details}", action, details);
        }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\ViewModels\MainViewModel.cs">
<![CDATA[
// DaminionOllamaApp/ViewModels/MainViewModel.cs
using DaminionOllamaApp.Models;
using DaminionOllamaApp.Services;
using DaminionOllamaApp.Utils;
using DaminionOllamaApp.Views;
using System.ComponentModel;
using System.Windows;
using System.Windows.Input;

namespace DaminionOllamaApp.ViewModels
{
    /// <summary>
    /// The main view model that serves as the central hub for the application.
    /// This class coordinates between different tagging modules and manages the global application state.
    /// It implements the MVVM pattern and provides access to:
    /// - Local file tagging functionality
    /// - Daminion collection tagging functionality  
    /// - Metadata tidy-up operations
    /// - Application settings management
    /// </summary>
    public class MainViewModel : INotifyPropertyChanged
    {
        #region Commands
        /// <summary>
        /// Command to open the settings window for configuring application preferences.
        /// </summary>
        public ICommand OpenSettingsCommand { get; }
        
        /// <summary>
        /// Command to gracefully exit the application.
        /// </summary>
        public ICommand ExitCommand { get; }
        #endregion

        #region ViewModels
        /// <summary>
        /// View model for handling local file tagging operations.
        /// Allows users to process images from local file system with AI-generated metadata.
        /// </summary>
        public LocalFileTaggerViewModel LocalFileTaggerVM { get; }
        
        /// <summary>
        /// View model for handling Daminion collection tagging operations.
        /// Interfaces with Daminion DAM system to process cataloged images.
        /// </summary>
        public DaminionCollectionTaggerViewModel DaminionCollectionTaggerVM { get; }
        
        /// <summary>
        /// View model for metadata cleanup and organization operations.
        /// Provides tools to standardize and clean up existing metadata.
        /// </summary>
        public MetadataTidyUpViewModel MetadataTidyUpVM { get; }
        #endregion

        #region Properties
        /// <summary>
        /// The single source of truth for application settings.
        /// Contains configuration for Daminion, Ollama, OpenRouter, and other application preferences.
        /// This instance is shared across all ViewModels to ensure consistency.
        /// </summary>
        public AppSettings AppSettings { get; }
        #endregion

        #region Constructor
        /// <summary>
        /// Initializes a new instance of the MainViewModel.
        /// Sets up the application's core components and loads configuration.
        /// </summary>
        public MainViewModel()
        {
            // Load application settings from storage (typically JSON file)
            var settingsService = new SettingsService();
            AppSettings = settingsService.LoadSettings();

            // Initialize commands with their respective handlers
            OpenSettingsCommand = new RelayCommand(param => OpenSettingsWindow());
            ExitCommand = new RelayCommand(param => ExitApplication());

            // Initialize child ViewModels with shared settings and services
            // Each VM gets the same AppSettings instance to ensure consistency
            LocalFileTaggerVM = new LocalFileTaggerViewModel(AppSettings, settingsService);
            DaminionCollectionTaggerVM = new DaminionCollectionTaggerViewModel(AppSettings, settingsService);
            MetadataTidyUpVM = new MetadataTidyUpViewModel(AppSettings, settingsService);
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Opens the settings window as a modal dialog.
        /// Handles the configuration of application settings including:
        /// - Daminion server connection details
        /// - Ollama/OpenRouter AI service configuration
        /// - Default prompts and processing options
        /// </summary>
        private void OpenSettingsWindow()
        {
            // Create settings view model with current settings
            var settingsViewModel = new SettingsViewModel(this.AppSettings);
            
            // Create and configure the settings window
            var settingsWindow = new SettingsWindow
            {
                Owner = Application.Current.MainWindow, // Set parent for proper modal behavior
                DataContext = settingsViewModel
            };

            // Define the save/close action for the settings window
            settingsViewModel.CloseAction = () =>
            {
                // Persist the modified settings to storage
                var settingsService = new SettingsService();
                settingsService.SaveSettings(this.AppSettings);
                settingsWindow.Close();
            };

            // Configure password box handling (WPF PasswordBox requires special handling)
            settingsViewModel.UpdatePasswordBoxAction = (pwd) => settingsWindow.SetPasswordBox(pwd);
            settingsViewModel.UpdatePasswordBoxAction?.Invoke(settingsViewModel.Settings.DaminionPassword);

            // Show the settings window as a modal dialog
            settingsWindow.ShowDialog();
        }

        /// <summary>
        /// Gracefully shuts down the application.
        /// Ensures all resources are properly cleaned up before exit.
        /// </summary>
        private void ExitApplication()
        {
            Application.Current.Shutdown();
        }
        #endregion

        #region INotifyPropertyChanged Implementation
        /// <summary>
        /// Event raised when a property value changes.
        /// Required for WPF data binding to work properly.
        /// </summary>
        public event PropertyChangedEventHandler? PropertyChanged;
        
        /// <summary>
        /// Raises the PropertyChanged event for the specified property.
        /// </summary>
        /// <param name="propertyName">The name of the property that changed.</param>
        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
        #endregion
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\ViewModels\MetadataTidyUpViewModel.cs">
<![CDATA[
// DaminionOllamaApp/ViewModels/MetadataTidyUpViewModel.cs
using DaminionOllamaApp.Models;
using DaminionOllamaApp.Services;
using DaminionOllamaApp.Utils;
using DaminionOllamaInteractionLib;
using DaminionOllamaInteractionLib.Daminion;
using DaminionOllamaInteractionLib.Services;
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using Serilog;

namespace DaminionOllamaApp.ViewModels
{
    public class MetadataTidyUpViewModel : INotifyPropertyChanged
    {
        private static readonly ILogger Logger;
        static MetadataTidyUpViewModel()
        {
            var logDir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "DaminionOllamaApp", "logs");
            Directory.CreateDirectory(logDir);
            var logPath = Path.Combine(logDir, "metadatatidyupviewmodel.log");
            Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day, retainedFileCountLimit: 7)
                .CreateLogger();
        }
        // --- Fields ---
        private readonly SettingsService _settingsService;
        private DaminionApiClient? _daminionClient;

        private ObservableCollection<FileQueueItem> _filesToProcess;
        private string _currentOperationStatus = "Select processing mode and add files.";
        private bool _isCleaningQueue;
        private CancellationTokenSource? _cleanupCts;

        private bool _isLocalFilesMode = true;
        private bool _isDaminionCatalogMode;
        private bool _isDaminionLoggedIn;
        private string _daminionLoginStatus = "Not logged in.";
        private ObservableCollection<QueryTypeDisplayItem> _daminionQueryTypes;
        private QueryTypeDisplayItem? _selectedDaminionQueryType;
        private bool _isLoadingDaminionItems;
        private bool _splitCategories = true;
        private bool _trimDescriptionPrefix = true;
        private string _descriptionPrefixToTrim = "Okay, here's a detailed description of the image, broken down as requested:";

        // --- Properties ---
        public AppSettings Settings { get; }

        public ObservableCollection<FileQueueItem> FilesToProcess
        {
            get => _filesToProcess;
            set { SetProperty(ref _filesToProcess, value); }
        }

        public string CurrentOperationStatus
        {
            get => _currentOperationStatus;
            set { SetProperty(ref _currentOperationStatus, value); }
        }

        public bool IsCleaningQueue
        {
            get => _isCleaningQueue;
            set { if (SetProperty(ref _isCleaningQueue, value)) UpdateCommandStates(); }
        }

        public bool IsLocalFilesMode
        {
            get => _isLocalFilesMode;
            set
            {
                if (SetProperty(ref _isLocalFilesMode, value))
                {
                    if (_isLocalFilesMode) IsDaminionCatalogMode = false;
                    Application.Current.Dispatcher.Invoke(() => FilesToProcess.Clear());
                    CurrentOperationStatus = "Local files mode selected. Add files to tidy up.";
                    UpdateCommandStates();
                }
            }
        }

        public bool IsDaminionCatalogMode
        {
            get => _isDaminionCatalogMode;
            set
            {
                if (SetProperty(ref _isDaminionCatalogMode, value))
                {
                    if (_isDaminionCatalogMode) IsLocalFilesMode = false;
                    Application.Current.Dispatcher.Invoke(() => FilesToProcess.Clear());
                    CurrentOperationStatus = "Daminion catalog mode selected. Login and select a query.";
                    UpdateCommandStates();
                }
            }
        }

        public bool IsDaminionLoggedIn
        {
            get => _isDaminionLoggedIn;
            set { SetProperty(ref _isDaminionLoggedIn, value); UpdateCommandStates(); }
        }

        public string DaminionLoginStatus
        {
            get => _daminionLoginStatus;
            set { SetProperty(ref _daminionLoginStatus, value); }
        }

        public ObservableCollection<QueryTypeDisplayItem> DaminionQueryTypes
        {
            get => _daminionQueryTypes;
            set { SetProperty(ref _daminionQueryTypes, value); }
        }

        public QueryTypeDisplayItem? SelectedDaminionQueryType
        {
            get => _selectedDaminionQueryType;
            set
            {
                if (SetProperty(ref _selectedDaminionQueryType, value))
                {
                    Application.Current.Dispatcher.Invoke(() => FilesToProcess.Clear());
                    UpdateCommandStates();
                }
            }
        }

        public bool IsLoadingDaminionItems
        {
            get => _isLoadingDaminionItems;
            set { SetProperty(ref _isLoadingDaminionItems, value); UpdateCommandStates(); }
        }

        public bool SplitCategories
        {
            get => _splitCategories;
            set { SetProperty(ref _splitCategories, value); }
        }

        public bool TrimDescriptionPrefix
        {
            get => _trimDescriptionPrefix;
            set { SetProperty(ref _trimDescriptionPrefix, value); }
        }

        public string DescriptionPrefixToTrim
        {
            get => _descriptionPrefixToTrim;
            set { SetProperty(ref _descriptionPrefixToTrim, value); }
        }

        public ICommand AddFilesCommand { get; }
        public ICommand DaminionLoginCommand { get; }
        public ICommand LoadDaminionItemsCommand { get; }
        public ICommand StartCleanupCommand { get; }
        public ICommand StopCleanupCommand { get; }

        public MetadataTidyUpViewModel(AppSettings settings, SettingsService settingsService)
        {
            this.Settings = settings;
            _settingsService = settingsService;

            _filesToProcess = new ObservableCollection<FileQueueItem>();
            _daminionQueryTypes = new ObservableCollection<QueryTypeDisplayItem>
            {
                new QueryTypeDisplayItem { DisplayName = "Unflagged Items", QueryLine = "1,7179;41,1", Operators = "1,any;41,any" },
                new QueryTypeDisplayItem { DisplayName = "Flagged Items", QueryLine = "1,7179;41,2", Operators = "1,any;41,any" },
                new QueryTypeDisplayItem { DisplayName = "Rejected Items", QueryLine = "1,7179;41,3", Operators = "1,any;41,any" }
            };
            SelectedDaminionQueryType = _daminionQueryTypes.FirstOrDefault();

            AddFilesCommand = new RelayCommand(param => AddLocalFiles(), param => CanAddLocalFiles());
            DaminionLoginCommand = new RelayCommand(async param => await LoginToDaminionAsync(), param => CanLoginToDaminion());
            LoadDaminionItemsCommand = new RelayCommand(async param => await LoadDaminionItemsByQueryAsync(), param => CanLoadDaminionItems());
            StartCleanupCommand = new RelayCommand(async param => await StartCleanupAsync(), param => CanStartCleanup());
            StopCleanupCommand = new RelayCommand(param => StopCleanup(), param => CanStopCleanup());
        }

        private void UpdateCommandStates()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                (AddFilesCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (DaminionLoginCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (LoadDaminionItemsCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (StartCleanupCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (StopCleanupCommand as RelayCommand)?.RaiseCanExecuteChanged();
            });
        }

        private bool CanAddLocalFiles() => IsLocalFilesMode && !IsCleaningQueue && !IsLoadingDaminionItems;
        private void AddLocalFiles()
        {
            var openFileDialog = new OpenFileDialog
            {
                Multiselect = true,
                Filter = "Image Files (*.jpg; *.jpeg; *.png; *.bmp; *.gif; *.tiff)|*.jpg;*.jpeg;*.png;*.bmp;*.gif;*.tiff|All files (*.*)|*.*",
                Title = "Select Image Files for Meta Tidy-up"
            };
            if (openFileDialog.ShowDialog() == true)
            {
                int filesAddedCount = 0;
                foreach (string filePath in openFileDialog.FileNames)
                {
                    if (!FilesToProcess.Any(f => f.FilePath.Equals(filePath, StringComparison.OrdinalIgnoreCase)))
                    {
                        FilesToProcess.Add(new FileQueueItem(filePath));
                        filesAddedCount++;
                    }
                }
                CurrentOperationStatus = $"{filesAddedCount} local file(s) added. {FilesToProcess.Count} total.";
                UpdateCommandStates();
            }
        }

        private bool CanLoginToDaminion() => IsDaminionCatalogMode && !IsDaminionLoggedIn && !IsLoadingDaminionItems && !IsCleaningQueue;
        private async Task LoginToDaminionAsync()
        {
            Logger.Information("Attempting Daminion login for server: {Server}", Settings.DaminionServerUrl);
            if (string.IsNullOrWhiteSpace(Settings.DaminionServerUrl) ||
                string.IsNullOrWhiteSpace(Settings.DaminionUsername))
            {
                DaminionLoginStatus = "Error: Daminion server URL or username is not configured.";
                return;
            }

            _daminionClient = new DaminionApiClient();
            DaminionLoginStatus = $"Logging in to Daminion: {Settings.DaminionServerUrl}...";
            IsDaminionLoggedIn = false;
            try
            {
                bool success = await _daminionClient.LoginAsync(
                    Settings.DaminionServerUrl,
                    Settings.DaminionUsername,
                    Settings.DaminionPassword);
                Logger.Information("Daminion login result: {Result}", success);
                IsDaminionLoggedIn = success;
                DaminionLoginStatus = success ? "Daminion login successful. Select query and load items." : "Daminion login failed.";
            }
            catch (Exception ex)
            {
                Logger.Error(ex, "Daminion login error");
                DaminionLoginStatus = $"Daminion login error: {ex.Message}";
                IsDaminionLoggedIn = false;
            }
        }

        private bool CanLoadDaminionItems() => IsDaminionCatalogMode && IsDaminionLoggedIn && SelectedDaminionQueryType != null && !IsLoadingDaminionItems && !IsCleaningQueue;
        private async Task LoadDaminionItemsByQueryAsync()
        {
            if (SelectedDaminionQueryType == null || _daminionClient == null || !_daminionClient.IsAuthenticated)
            {
                CurrentOperationStatus = "Cannot load: No query type selected or not logged in to Daminion.";
                return;
            }

            IsLoadingDaminionItems = true;
            CurrentOperationStatus = $"Loading Daminion items for: '{SelectedDaminionQueryType.DisplayName}'...";
            Application.Current.Dispatcher.Invoke(() => FilesToProcess.Clear());
            try
            {
                DaminionSearchMediaItemsResponse? searchResult = await _daminionClient.SearchMediaItemsAsync(
                    SelectedDaminionQueryType.QueryLine,
                    SelectedDaminionQueryType.Operators,
                    pageSize: 1000);
                if (searchResult != null && searchResult.Success && searchResult.MediaItems != null)
                {
                    if (!searchResult.MediaItems.Any())
                    {
                        CurrentOperationStatus = $"No Daminion items found for: '{SelectedDaminionQueryType.DisplayName}'.";
                    }
                    else
                    {
                        CurrentOperationStatus = $"{searchResult.MediaItems.Count} Daminion item(s) found. Fetching paths...";
                        var itemIds = searchResult.MediaItems.Select(item => item.Id).ToList();

                        if (!itemIds.Any())
                        {
                            CurrentOperationStatus = $"No Daminion item IDs to fetch paths for: '{SelectedDaminionQueryType.DisplayName}'.";
                        }
                        else
                        {
                            DaminionPathResult pathResult = await _daminionClient.GetAbsolutePathsAsync(itemIds);
                            if (pathResult.Success && pathResult.Paths != null)
                            {
                                foreach (var daminionItemFromSearch in searchResult.MediaItems)
                                {
                                    string displayName = !string.IsNullOrWhiteSpace(daminionItemFromSearch.Name) ? daminionItemFromSearch.Name :
                                                         (!string.IsNullOrWhiteSpace(daminionItemFromSearch.FileName) ? daminionItemFromSearch.FileName : $"Item {daminionItemFromSearch.Id}");
                                    if (pathResult.Paths.TryGetValue(daminionItemFromSearch.Id.ToString(), out string? filePath) && !string.IsNullOrEmpty(filePath))
                                    {
                                        FilesToProcess.Add(new FileQueueItem(filePath, displayName, daminionItemFromSearch.Id));
                                    }
                                    else
                                    {
                                        FilesToProcess.Add(new FileQueueItem(string.Empty, displayName, daminionItemFromSearch.Id)
                                        { Status = ProcessingStatus.Error, StatusMessage = $"Path not found for Daminion ID {daminionItemFromSearch.Id}." });
                                    }
                                }
                                CurrentOperationStatus = $"{FilesToProcess.Count(f => f.Status != ProcessingStatus.Error)} Daminion items loaded. Ready for cleanup.";
                            }
                            else
                            {
                                CurrentOperationStatus = $"Found {searchResult.MediaItems.Count} items, but failed to get paths: {pathResult.ErrorMessage}";
                                foreach (var daminionItemFromSearch in searchResult.MediaItems)
                                {
                                    string displayName = !string.IsNullOrWhiteSpace(daminionItemFromSearch.Name) ? daminionItemFromSearch.Name :
                                                        (!string.IsNullOrWhiteSpace(daminionItemFromSearch.FileName) ? daminionItemFromSearch.FileName : $"Item {daminionItemFromSearch.Id}");
                                    FilesToProcess.Add(new FileQueueItem(string.Empty, displayName, daminionItemFromSearch.Id)
                                    { Status = ProcessingStatus.Error, StatusMessage = $"Path retrieval failed. API Error: {pathResult.ErrorMessage}" });
                                }
                            }
                        }
                    }
                }
                else
                {
                    CurrentOperationStatus = $"Failed to search Daminion items: {searchResult?.Error ?? "Unknown API error."}";
                }
            }
            catch (Exception ex)
            {
                CurrentOperationStatus = $"Error loading Daminion items: {ex.Message}";
                System.Diagnostics.Debug.WriteLine($"Error in LoadDaminionItemsByQueryAsync (TidyUpVM): {ex}");
            }
            finally
            {
                IsLoadingDaminionItems = false;
            }
        }

        private bool CanStartCleanup() => FilesToProcess.Any(f => (f.Status == ProcessingStatus.Unprocessed || f.Status == ProcessingStatus.Error) && !string.IsNullOrEmpty(f.FilePath)) && !IsCleaningQueue && !IsLoadingDaminionItems;
        private async Task StartCleanupAsync()
        {
            IsCleaningQueue = true;
            _cleanupCts = new CancellationTokenSource();
            var token = _cleanupCts.Token;

            CurrentOperationStatus = "Starting metadata cleanup...";
            int processedCount = 0;
            int errorCount = 0;

            var itemsToClean = FilesToProcess.Where(f => (f.Status == ProcessingStatus.Unprocessed || f.Status == ProcessingStatus.Error) && !string.IsNullOrEmpty(f.FilePath)).ToList();
            if (IsDaminionCatalogMode &&
                (string.IsNullOrWhiteSpace(Settings.DaminionDescriptionTagGuid) ||
                 string.IsNullOrWhiteSpace(Settings.DaminionKeywordsTagGuid) ||
                 string.IsNullOrWhiteSpace(Settings.DaminionCategoriesTagGuid)))
            {
                CurrentOperationStatus = "Error: Key Daminion Tag GUIDs (Description, Keywords, Categories) are not set in AppSettings. Cannot update Daminion catalog.";
                IsCleaningQueue = false;
                return;
            }

            System.Diagnostics.Debug.WriteLine($"Starting cleanup. SplitCategories: {SplitCategories}, TrimDescriptionPrefix: {TrimDescriptionPrefix}, Prefix: '{DescriptionPrefixToTrim}'");
            try
            {
                foreach (var item in itemsToClean)
                {
                    if (token.IsCancellationRequested)
                    {
                        item.Status = ProcessingStatus.Cancelled;
                        item.StatusMessage = "Cleanup cancelled by user.";
                        break;
                    }

                    item.Status = ProcessingStatus.Processing;
                    item.StatusMessage = "";
                    UpdateOverallStatus($"Tidying: {item.FileName}");
                    System.Diagnostics.Debug.WriteLine($"Tidying: {item.FileName}");

                    bool changesMadeToLocalFile = false;
                    ImageMetadataService metadataService = new ImageMetadataService(item.FilePath);
                    try
                    {
                        metadataService.Read();
                        System.Diagnostics.Debug.WriteLine($"  Read metadata. Desc: '{metadataService.Description?.Substring(0, Math.Min(50, metadataService.Description?.Length ?? 0))}', Cats: {string.Join(";", metadataService.Categories ?? new List<string>())}");

                        // 1. Trim Description Prefix
                        if (TrimDescriptionPrefix && !string.IsNullOrEmpty(metadataService.Description))
                        {
                            string originalDesc = metadataService.Description;
                            string currentDesc = metadataService.Description;

                            string[] prefixesToTrim = {
                                DescriptionPrefixToTrim,
                                "Okay, here’s a detailed description of the image, broken down as requested:",
                                "Okay, here's a detailed description of the image, broken down as requested:",
                                "Okay, here’s a detailed description of the image, categorized and with keywords as requested:",
                                "Here's a detailed description of the image:",
                                "Here’s a detailed description of the image:"
                            };
                            foreach (var prefix in prefixesToTrim.Where(p => !string.IsNullOrWhiteSpace(p)))
                            {
                                if (currentDesc.TrimStart().StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
                                {
                                    currentDesc = currentDesc.TrimStart().Substring(prefix.Length);
                                    System.Diagnostics.Debug.WriteLine($"    Trimmed prefix '{prefix}' from description.");
                                    break;
                                }
                            }

                            string followUpPattern = "<br><br>**Description:**";
                            int followUpIndex = currentDesc.IndexOf(followUpPattern, StringComparison.OrdinalIgnoreCase);
                            if (followUpIndex != -1)
                            {
                                currentDesc = currentDesc.Substring(followUpIndex + followUpPattern.Length);
                                System.Diagnostics.Debug.WriteLine($"    Trimmed follow-up pattern '{followUpPattern}' from description.");
                            }

                            currentDesc = currentDesc.Trim();
                            if (currentDesc != originalDesc.Trim())
                            {
                                metadataService.Description = currentDesc;
                                changesMadeToLocalFile = true;
                                item.StatusMessage += "Description trimmed. ";
                                System.Diagnostics.Debug.WriteLine($"    Description changed. New: '{metadataService.Description?.Substring(0, Math.Min(50, metadataService.Description?.Length ?? 0))}'");
                            }
                        }

                        // 2. Split and Clean Categories
                        if (SplitCategories && metadataService.Categories != null && metadataService.Categories.Any())
                        {
                            System.Diagnostics.Debug.WriteLine($"    Original categories: [{string.Join("] | [", metadataService.Categories)}]");
                            var newCategoriesList = new List<string>();

                            foreach (var catString in metadataService.Categories)
                            {
                                if (string.IsNullOrWhiteSpace(catString)) continue;
                                if (catString.Contains(','))
                                {
                                    var splitParts = catString.Split(',')
                                        .Select(s => s.Trim().Trim('*', ' ').Trim())
                                        .Where(s => !string.IsNullOrWhiteSpace(s) &&
                                                    !(s.Contains(@"\") || s.Contains(@"/")) &&
                                                    !Regex.IsMatch(s, @"^\d{4}$") &&
                                                    s.Length > 1)
                                        .ToList();
                                    newCategoriesList.AddRange(splitParts);
                                }
                                else
                                {
                                    string cleanedSingleCat = catString.Trim().Trim('*', ' ').Trim();
                                    if (!string.IsNullOrWhiteSpace(cleanedSingleCat) &&
                                        !(cleanedSingleCat.Contains(@"\") || cleanedSingleCat.Contains(@"/")) &&
                                        !Regex.IsMatch(cleanedSingleCat, @"^\d{4}$") &&
                                        cleanedSingleCat.Length > 1)
                                    {
                                        newCategoriesList.Add(cleanedSingleCat);
                                    }
                                }
                            }

                            var distinctCleanedCategories = newCategoriesList
                                .Distinct(StringComparer.OrdinalIgnoreCase)
                                .OrderBy(c => c)
                                .ToList();

                            var originalEffectiveCategories = metadataService.Categories
                               .SelectMany(c => c.Split(','))
                               .Select(s => s.Trim().Trim('*', ' ').Trim())
                               .Where(s => !string.IsNullOrWhiteSpace(s) && !(s.Contains(@"\") || s.Contains(@"/")) && !Regex.IsMatch(s, @"^\d{4}$") && s.Length > 1)
                               .Distinct(StringComparer.OrdinalIgnoreCase)
                               .OrderBy(c => c)
                               .ToList();

                            if (!originalEffectiveCategories.SequenceEqual(distinctCleanedCategories, StringComparer.OrdinalIgnoreCase))
                            {
                                metadataService.Categories = distinctCleanedCategories;
                                changesMadeToLocalFile = true;
                                item.StatusMessage += "Categories split/cleaned. ";
                                System.Diagnostics.Debug.WriteLine($"    Categories changed. New: [{string.Join("] | [", metadataService.Categories)}]");
                            }
                        }

                        if (changesMadeToLocalFile)
                        {
                            metadataService.Save();
                            item.StatusMessage += "Local file updated. ";
                            System.Diagnostics.Debug.WriteLine($"    Local file saved for {item.FileName}");
                        }
                        else
                        {
                            item.StatusMessage = string.IsNullOrWhiteSpace(item.StatusMessage) ? "No applicable tidy-up changes to local file." : item.StatusMessage;
                        }

                        // 3. If Daminion Catalog mode, changes were made, and client is ready -> Update Daminion
                        if (IsDaminionCatalogMode && item.DaminionItemId.HasValue && changesMadeToLocalFile && _daminionClient != null && _daminionClient.IsAuthenticated)
                        {
                            item.StatusMessage += "Updating Daminion...";
                            UpdateOverallStatus($"Updating Daminion for: {item.FileName}");
                            System.Diagnostics.Debug.WriteLine($"    Attempting Daminion update for {item.FileName} (ID: {item.DaminionItemId.Value})");

                            var operations = new List<DaminionUpdateOperation>();
                            if (!string.IsNullOrWhiteSpace(metadataService.Description) && !string.IsNullOrWhiteSpace(Settings.DaminionDescriptionTagGuid))
                                operations.Add(new DaminionUpdateOperation { Guid = Settings.DaminionDescriptionTagGuid, Value = metadataService.Description, Id = 0, Remove = false });
                            if (metadataService.Categories != null && metadataService.Categories.Any() && !string.IsNullOrWhiteSpace(Settings.DaminionCategoriesTagGuid))
                            {
                                System.Diagnostics.Debug.WriteLine($"      Adding to Daminion Categories ({Settings.DaminionCategoriesTagGuid}): [{string.Join(" | ", metadataService.Categories)}]");
                                foreach (var category in metadataService.Categories.Where(c => !string.IsNullOrWhiteSpace(c)))
                                    operations.Add(new DaminionUpdateOperation { Guid = Settings.DaminionCategoriesTagGuid, Value = category, Id = 0, Remove = false });
                            }

                            if (operations.Any())
                            {
                                var updateResult = await _daminionClient.UpdateItemMetadataAsync(new List<long> { item.DaminionItemId.Value }, operations);
                                if (updateResult != null && updateResult.Success)
                                {
                                    item.StatusMessage += "Daminion metadata updated.";
                                    System.Diagnostics.Debug.WriteLine($"      Daminion update successful for {item.FileName}.");
                                }
                                else
                                {
                                    item.StatusMessage += $"Daminion update failed: {updateResult?.Error ?? "Unknown"}.";
                                    item.Status = ProcessingStatus.Error;
                                    System.Diagnostics.Debug.WriteLine($"      Daminion update FAILED for {item.FileName}: {updateResult?.Error}");
                                }
                            }
                            else
                            {
                                item.StatusMessage += "No metadata operations to send to Daminion.";
                                System.Diagnostics.Debug.WriteLine($"      No operations to send to Daminion for {item.FileName}.");
                            }
                        }

                        item.StatusMessage = item.StatusMessage.Trim();
                        if (item.Status != ProcessingStatus.Error)
                        {
                            item.Status = ProcessingStatus.Processed;
                            if (string.IsNullOrWhiteSpace(item.StatusMessage))
                                item.StatusMessage = changesMadeToLocalFile ? "Cleanup successful." : "No changes applied.";
                        }

                        if (item.Status == ProcessingStatus.Processed) processedCount++;
                        else errorCount++;
                    }
                    catch (OperationCanceledException)
                    {
                        item.Status = ProcessingStatus.Cancelled;
                        item.StatusMessage = "Cancelled during item processing.";
                        System.Diagnostics.Debug.WriteLine($"    Item {item.FileName} cancelled.");
                        throw;
                    }
                    catch (Exception ex)
                    {
                        item.Status = ProcessingStatus.Error;
                        item.StatusMessage = $"Error cleaning file {item.FileName}: {ex.Message}";
                        System.Diagnostics.Debug.WriteLine($"    Error cleaning {item.FileName}: {ex}");
                        errorCount++;
                    }
                }
            }
            catch (OperationCanceledException)
            {
                UpdateOverallStatus("Metadata cleanup cancelled by user.");
                foreach (var item in FilesToProcess.Where(i => i.Status == ProcessingStatus.Processing || i.Status == ProcessingStatus.Queued))
                {
                    item.Status = ProcessingStatus.Cancelled;
                    item.StatusMessage = "Queue cancelled.";
                }
            }
            catch (Exception ex)
            {
                UpdateOverallStatus($"An error occurred during metadata cleanup: {ex.Message}");
                System.Diagnostics.Debug.WriteLine($"Error in StartCleanupAsync loop: {ex}");
                foreach (var item in FilesToProcess.Where(i => i.Status == ProcessingStatus.Processing || i.Status == ProcessingStatus.Queued))
                {
                    item.Status = ProcessingStatus.Error;
                    item.StatusMessage = "Queue processing error.";
                }
            }
            finally
            {
                IsCleaningQueue = false;
                _cleanupCts?.Dispose();
                _cleanupCts = null;

                processedCount = FilesToProcess.Count(i => i.Status == ProcessingStatus.Processed);
                errorCount = FilesToProcess.Count(i => i.Status == ProcessingStatus.Error);
                int cancelledCount = FilesToProcess.Count(i => i.Status == ProcessingStatus.Cancelled);
                CurrentOperationStatus = $"Cleanup finished. Processed: {processedCount}, Errors: {errorCount}, Cancelled: {cancelledCount}.";
                System.Diagnostics.Debug.WriteLine(CurrentOperationStatus);
            }
        }

        private void UpdateOverallStatus(string message)
        {
            Application.Current.Dispatcher.Invoke(() => CurrentOperationStatus = message);
        }

        private bool CanStopCleanup() => IsCleaningQueue;
        private void StopCleanup()
        {
            _cleanupCts?.Cancel();
            CurrentOperationStatus = "Cleanup stop requested.";
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected virtual bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = "")
        {
            if (EqualityComparer<T>.Default.Equals(storage, value)) return false;
            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }
        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = "")
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
            });
        }

        // Example: Log when files are added to the queue
        private void LogFileQueueChange(string action, object? details = null)
        {
            Logger.Information("File queue action: {Action}, Details: {@Details}", action, details);
        }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\ViewModels\SettingsViewModel.cs">
<![CDATA[
// DaminionOllamaApp/ViewModels/SettingsViewModel.cs
using DaminionOllamaApp.Models;
using DaminionOllamaApp.Services;
using DaminionOllamaApp.Utils;
using DaminionOllamaInteractionLib;
using DaminionOllamaInteractionLib.Daminion;
using DaminionOllamaInteractionLib.Ollama;
using DaminionOllamaInteractionLib.OpenRouter;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using Serilog;
using System.IO;
using DaminionOllamaApp;

namespace DaminionOllamaApp.ViewModels
{
    public class SettingsViewModel : INotifyPropertyChanged
    {
        private static readonly ILogger Logger;
        static SettingsViewModel()
        {
            var logDir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "DaminionOllamaApp", "logs");
            Directory.CreateDirectory(logDir);
            var logPath = Path.Combine(logDir, "settingsviewmodel.log");
            Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day, retainedFileCountLimit: 7)
                .CreateLogger();
        }

        private AppSettings _settings;

        // --- Ollama Settings ---
        private string _ollamaConnectionStatus = "Ollama connection not verified.";
        private bool _isVerifyingOllamaConnection;
        private bool _isFetchingOllamaModels;
        private ObservableCollection<string> _ollamaModels;

        // --- OpenRouter Settings ---
        private string _openRouterConnectionStatus = "OpenRouter connection not verified.";
        private bool _isVerifyingOpenRouterConnection;
        private bool _isFetchingOpenRouterModels;
        private ObservableCollection<string> _openRouterModels;

        // --- Daminion Settings ---
        private bool _isDiscoveringGuids;
        private string _discoveryStatusMessage = string.Empty;
        private string _daminionConnectionTestStatus = "Daminion connection not verified.";
        private bool _isVerifyingDaminionConnectionTest;

        // --- Gemma Settings ---
        private ObservableCollection<string> _gemmaModels = new ObservableCollection<string>();
        private string _gemmaConnectionStatus = "Gemma connection not verified.";
        private bool _isVerifyingGemmaConnection;

        // --- Free Model Filter ---
        private bool _onlyShowFreeGeminiGemmaModels = false;
        public bool OnlyShowFreeGeminiGemmaModels
        {
            get => _onlyShowFreeGeminiGemmaModels;
            set
            {
                if (_onlyShowFreeGeminiGemmaModels != value)
                {
                    _onlyShowFreeGeminiGemmaModels = value;
                    OnPropertyChanged(nameof(OnlyShowFreeGeminiGemmaModels));
                }
            }
        }

        // --- GCP/BigQuery Billing Export Selectors ---
        public ObservableCollection<string> GcpProjects { get; } = new ObservableCollection<string>();
        public ObservableCollection<string> BigQueryDatasets { get; } = new ObservableCollection<string>();
        public ObservableCollection<string> BigQueryTables { get; } = new ObservableCollection<string>();

        private string _billingExportInstructions = string.Empty;
        public string BillingExportInstructions
        {
            get => _billingExportInstructions;
            set { _billingExportInstructions = value; OnPropertyChanged(nameof(BillingExportInstructions)); }
        }

        public AppSettings Settings
        {
            get => _settings;
            set { SetProperty(ref _settings, value); }
        }

        // --- Ollama Properties ---
        public string OllamaConnectionStatus
        {
            get => _ollamaConnectionStatus;
            private set { SetProperty(ref _ollamaConnectionStatus, value); }
        }

        public bool IsVerifyingOllamaConnection
        {
            get => _isVerifyingOllamaConnection;
            private set
            {
                if (SetProperty(ref _isVerifyingOllamaConnection, value))
                {
                    Application.Current.Dispatcher.Invoke(() =>
                        (VerifyOllamaConnectionCommand as RelayCommand)?.RaiseCanExecuteChanged());
                }
            }
        }

        public bool IsFetchingOllamaModels
        {
            get => _isFetchingOllamaModels;
            private set { SetProperty(ref _isFetchingOllamaModels, value); }
        }

        public ObservableCollection<string> OllamaModels
        {
            get => _ollamaModels;
            private set { SetProperty(ref _ollamaModels, value); }
        }

        public string? SelectedOllamaModelName
        {
            get => Settings?.OllamaModelName;
            set
            {
                if (Settings != null && Settings.OllamaModelName != value)
                {
                    Settings.OllamaModelName = value ?? string.Empty;
                    OnPropertyChanged(nameof(SelectedOllamaModelName));
                }
            }
        }

        // --- OpenRouter Properties ---
        public string OpenRouterConnectionStatus
        {
            get => _openRouterConnectionStatus;
            private set { SetProperty(ref _openRouterConnectionStatus, value); }
        }

        public bool IsVerifyingOpenRouterConnection
        {
            get => _isVerifyingOpenRouterConnection;
            private set
            {
                if (SetProperty(ref _isVerifyingOpenRouterConnection, value))
                {
                    Application.Current.Dispatcher.Invoke(() =>
                        (VerifyOpenRouterConnectionCommand as RelayCommand)?.RaiseCanExecuteChanged());
                }
            }
        }

        public bool IsFetchingOpenRouterModels
        {
            get => _isFetchingOpenRouterModels;
            private set { SetProperty(ref _isFetchingOpenRouterModels, value); }
        }

        public ObservableCollection<string> OpenRouterModels
        {
            get => _openRouterModels;
            private set { SetProperty(ref _openRouterModels, value); }
        }

        public string? SelectedOpenRouterModelName
        {
            get => Settings?.OpenRouterModelName;
            set
            {
                if (Settings != null && Settings.OpenRouterModelName != value)
                {
                    Settings.OpenRouterModelName = value ?? string.Empty;
                    OnPropertyChanged(nameof(SelectedOpenRouterModelName));
                }
            }
        }

        // Daminion GUID Discovery Properties
        public bool IsDiscoveringGuids
        {
            get => _isDiscoveringGuids;
            private set
            {
                if (SetProperty(ref _isDiscoveringGuids, value))
                {
                    Application.Current.Dispatcher.Invoke(() =>
                        (DiscoverTagGuidsCommand as RelayCommand)?.RaiseCanExecuteChanged());
                }
            }
        }

        public string DiscoveryStatusMessage
        {
            get => _discoveryStatusMessage;
            private set { SetProperty(ref _discoveryStatusMessage, value); }
        }

        // Daminion Connection Test Properties
        public string DaminionConnectionTestStatus
        {
            get => _daminionConnectionTestStatus;
            private set { SetProperty(ref _daminionConnectionTestStatus, value); }
        }

        public bool IsVerifyingDaminionConnectionTest
        {
            get => _isVerifyingDaminionConnectionTest;
            private set
            {
                if (SetProperty(ref _isVerifyingDaminionConnectionTest, value))
                {
                    Application.Current.Dispatcher.Invoke(() =>
                        (TestDaminionConnectionCommand as RelayCommand)?.RaiseCanExecuteChanged());
                }
            }
        }

        // --- Gemma Properties ---
        public ObservableCollection<string> GemmaModels
        {
            get => _gemmaModels;
            private set { SetProperty(ref _gemmaModels, value); }
        }

        public string? SelectedGemmaModelName
        {
            get => Settings?.GemmaModelName;
            set
            {
                if (Settings != null && Settings.GemmaModelName != value)
                {
                    Settings.GemmaModelName = value ?? string.Empty;
                    OnPropertyChanged(nameof(SelectedGemmaModelName));
                }
            }
        }

        public string GemmaConnectionStatus
        {
            get => _gemmaConnectionStatus;
            private set { SetProperty(ref _gemmaConnectionStatus, value); }
        }

        public bool IsVerifyingGemmaConnection
        {
            get => _isVerifyingGemmaConnection;
            private set
            {
                if (SetProperty(ref _isVerifyingGemmaConnection, value))
                {
                    Application.Current.Dispatcher.Invoke(() =>
                        (VerifyGemmaConnectionCommand as RelayCommand)?.RaiseCanExecuteChanged());
                }
            }
        }

        // --- Commands ---
        public ICommand SaveCommand { get; }
        public ICommand CloseCommand { get; }
        public ICommand DiscoverTagGuidsCommand { get; }
        public ICommand VerifyOllamaConnectionCommand { get; }
        public ICommand TestDaminionConnectionCommand { get; }
        public ICommand VerifyOpenRouterConnectionCommand { get; }
        public ICommand VerifyGemmaConnectionCommand { get; }
        public ICommand RefreshProjectsCommand { get; }
        public ICommand RefreshDatasetsCommand { get; }
        public ICommand RefreshTablesCommand { get; }
        public ICommand CheckBillingExportTableCommand { get; }

        // Actions for View Interaction
        public Action? CloseAction { get; set; }
        public Action<string>? UpdatePasswordBoxAction { get; set; }

        public SettingsViewModel(AppSettings settings)
        {
            _settings = settings;

            _ollamaModels = new ObservableCollection<string>();
            _openRouterModels = new ObservableCollection<string>();
            _gemmaModels = new ObservableCollection<string>();

            SaveCommand = new RelayCommand(param => CloseAction?.Invoke());
            CloseCommand = new RelayCommand(param => CloseAction?.Invoke());

            DiscoverTagGuidsCommand = new RelayCommand(async param => await DiscoverTagGuidsAsync(), param => CanDiscoverTagGuids());
            VerifyOllamaConnectionCommand = new RelayCommand(async param => await VerifyAndFetchOllamaModelsAsync(), param => CanVerifyOllamaConnection());
            TestDaminionConnectionCommand = new RelayCommand(async param => await TestDaminionConnectionAsync(), param => CanTestDaminionConnection());
            VerifyOpenRouterConnectionCommand = new RelayCommand(async param => await VerifyAndFetchOpenRouterModelsAsync(), param => CanVerifyOpenRouterConnection());
            VerifyGemmaConnectionCommand = new RelayCommand(async param => await VerifyAndFetchGemmaModelsAsync(), param => CanVerifyGemmaConnection());
            RefreshProjectsCommand = new AsyncRelayCommand(_ => RefreshProjectsAsync());
            RefreshDatasetsCommand = new AsyncRelayCommand(_ => RefreshDatasetsAsync());
            RefreshTablesCommand = new AsyncRelayCommand(_ => RefreshTablesAsync());
            CheckBillingExportTableCommand = new AsyncRelayCommand(_ => CheckBillingExportTableAsync());
        }

        public void SetDaminionPassword(string password)
        {
            if (Settings != null)
            {
                Settings.DaminionPassword = password;
                Application.Current.Dispatcher.Invoke(() => {
                    (DiscoverTagGuidsCommand as RelayCommand)?.RaiseCanExecuteChanged();
                    (TestDaminionConnectionCommand as RelayCommand)?.RaiseCanExecuteChanged();
                });
            }
        }

        private bool CanDiscoverTagGuids()
        {
            return !IsDiscoveringGuids && Settings != null &&
                   !string.IsNullOrWhiteSpace(Settings.DaminionServerUrl) &&
                   !string.IsNullOrWhiteSpace(Settings.DaminionUsername) &&
                   !string.IsNullOrWhiteSpace(Settings.DaminionPassword);
        }

        private async Task DiscoverTagGuidsAsync()
        {
            if (!CanDiscoverTagGuids()) return;

            IsDiscoveringGuids = true;
            DiscoveryStatusMessage = "Connecting to Daminion to discover GUIDs...";

            using (var tempDaminionClient = new DaminionApiClient())
            {
                try
                {
                    bool loginSuccess = await tempDaminionClient.LoginAsync(Settings.DaminionServerUrl, Settings.DaminionUsername, Settings.DaminionPassword);
                    if (loginSuccess)
                    {
                        DiscoveryStatusMessage = "Login successful. Fetching all tags...";
                        DaminionGetTagsResponse? tagsResponse = await tempDaminionClient.GetTagsAsync();
                        if (tagsResponse != null && tagsResponse.Success && tagsResponse.Data != null)
                        {
                            var tags = tagsResponse.Data;
                            int foundCount = 0;
                            List<string> notFoundNames = new List<string>();

                            var descTag = tags.FirstOrDefault(t => t.Name.Equals("Description", StringComparison.OrdinalIgnoreCase) || t.Name.Equals("Caption", StringComparison.OrdinalIgnoreCase) || t.Name.Equals("Image Description", StringComparison.OrdinalIgnoreCase));
                            if (descTag != null) { Settings.DaminionDescriptionTagGuid = descTag.Guid; foundCount++; } else { notFoundNames.Add("Description/Caption"); }

                            var keywordsTag = tags.FirstOrDefault(t => t.Name.Equals("Keywords", StringComparison.OrdinalIgnoreCase));
                            if (keywordsTag != null) { Settings.DaminionKeywordsTagGuid = keywordsTag.Guid; foundCount++; } else { notFoundNames.Add("Keywords"); }

                            var categoriesTag = tags.FirstOrDefault(t => t.Name.Equals("Categories", StringComparison.OrdinalIgnoreCase));
                            if (categoriesTag != null) { Settings.DaminionCategoriesTagGuid = categoriesTag.Guid; foundCount++; } else { notFoundNames.Add("Categories"); }

                            var flagTag = tags.FirstOrDefault(t => t.Name.Equals("Flag", StringComparison.OrdinalIgnoreCase));
                            if (flagTag != null) { Settings.DaminionFlagTagGuid = flagTag.Guid; foundCount++; } else { notFoundNames.Add("Flag"); }

                            string report = $"Discovered {foundCount} GUID(s).";
                            if (notFoundNames.Any()) report += $" Could not find: {string.Join(", ", notFoundNames)}.";
                            DiscoveryStatusMessage = report + " Review and Save.";
                        }
                        else
                        {
                            DiscoveryStatusMessage = $"Failed to fetch tags: {tagsResponse?.Error ?? "Unknown error"}.";
                        }
                    }
                    else
                    {
                        DiscoveryStatusMessage = "Login failed for discovery. Check credentials/URL.";
                    }
                }
                catch (Exception ex)
                {
                    DiscoveryStatusMessage = $"Error during GUID discovery: {ex.Message}";
                    System.Diagnostics.Debug.WriteLine($"GUID Discovery Exception: {ex}");
                }
                finally
                {
                    IsDiscoveringGuids = false;
                }
            }
        }

        private bool CanVerifyOpenRouterConnection()
        {
            return !IsVerifyingOpenRouterConnection && Settings != null && !string.IsNullOrWhiteSpace(Settings.OpenRouterApiKey);
        }

        private async Task VerifyAndFetchOpenRouterModelsAsync()
        {
            if (!CanVerifyOpenRouterConnection() || Settings == null) return;

            IsVerifyingOpenRouterConnection = true;
            IsFetchingOpenRouterModels = true;
            OpenRouterConnectionStatus = "Verifying OpenRouter connection...";
            Application.Current.Dispatcher.Invoke(() => OpenRouterModels.Clear());

            try
            {
                using (var client = new OpenRouterApiClient(Settings.OpenRouterApiKey, Settings.OpenRouterHttpReferer))
                {
                    var modelsResponse = await client.ListModelsAsync();
                    if (modelsResponse?.Data != null)
                    {
                        var multimodalModels = modelsResponse.Data
                            .Where(m => m.Id != null && (m.Id.Contains("vision") || m.Id.Contains("claude-3") || 
                                                        m.Id.Contains("gpt-4") || m.Id.Contains("gemini")))
                            .OrderBy(m => m.Name)
                            .ToList();

                        foreach (var model in multimodalModels)
                        {
                            OpenRouterModels.Add(model.Id!);
                        }
                        OpenRouterConnectionStatus = $"{OpenRouterModels.Count} multimodal models found.";

                        if (!string.IsNullOrWhiteSpace(Settings.OpenRouterModelName) && OpenRouterModels.Contains(Settings.OpenRouterModelName))
                        {
                            SelectedOpenRouterModelName = Settings.OpenRouterModelName;
                        }
                        else if (OpenRouterModels.Any())
                        {
                            SelectedOpenRouterModelName = OpenRouterModels.FirstOrDefault();
                        }
                    }
                    else
                    {
                        OpenRouterConnectionStatus = "Failed to fetch models from OpenRouter. Check API Key.";
                    }
                }
            }
            catch (Exception ex)
            {
                OpenRouterConnectionStatus = $"Error: {ex.Message}";
                if (App.Logger != null) App.Logger.Log($"OpenRouter Verification Exception: {ex}");
                System.Diagnostics.Debug.WriteLine($"OpenRouter Verification Exception: {ex}");
            }
            finally
            {
                IsFetchingOpenRouterModels = false;
                IsVerifyingOpenRouterConnection = false;
            }
        }

        private bool CanVerifyOllamaConnection()
        {
            return !IsVerifyingOllamaConnection && Settings != null && !string.IsNullOrWhiteSpace(Settings.OllamaServerUrl);
        }

        private async Task VerifyAndFetchOllamaModelsAsync()
        {
            if (!CanVerifyOllamaConnection() || Settings == null) return;

            IsVerifyingOllamaConnection = true;
            IsFetchingOllamaModels = false;
            OllamaConnectionStatus = $"Verifying Ollama connection to {Settings.OllamaServerUrl}...";
            if (App.Logger != null) App.Logger.Log($"Verifying Ollama connection to {Settings.OllamaServerUrl}...");

            Application.Current.Dispatcher.Invoke(() => OllamaModels.Clear());

            try
            {
                using (var tempOllamaClient = new OllamaApiClient(Settings.OllamaServerUrl))
                {
                    bool connected = await tempOllamaClient.CheckConnectionAsync();
                    if (connected)
                    {
                        OllamaConnectionStatus = "Ollama server connected. Fetching models...";
                        IsFetchingOllamaModels = true;
                        OllamaListTagsResponse? modelsResponse = await tempOllamaClient.ListLocalModelsAsync();
                        if (modelsResponse != null && modelsResponse.Models != null)
                        {
                            foreach (var modelInfo in modelsResponse.Models.OrderBy(m => m.Name))
                            {
                                OllamaModels.Add(modelInfo.Name);
                            }
                            OllamaConnectionStatus = $"{OllamaModels.Count} Ollama models found.";

                            if (!string.IsNullOrWhiteSpace(Settings.OllamaModelName) && OllamaModels.Contains(Settings.OllamaModelName))
                            {
                                SelectedOllamaModelName = Settings.OllamaModelName;
                            }
                            else if (OllamaModels.Any())
                            {
                                SelectedOllamaModelName = OllamaModels.FirstOrDefault();
                            }
                        }
                        else
                        {
                            OllamaConnectionStatus = "Connected, but failed to fetch models or no models found.";
                        }
                        IsFetchingOllamaModels = false;
                    }
                    else
                    {
                        OllamaConnectionStatus = "Failed to connect to Ollama server. Check URL and ensure server is running.";
                    }
                }
            }
            catch (ArgumentException ex)
            {
                OllamaConnectionStatus = $"Error: Invalid Ollama Server URL - {ex.Message}";
            }
            catch (Exception ex)
            {
                OllamaConnectionStatus = $"Error interacting with Ollama: {ex.Message}";
                System.Diagnostics.Debug.WriteLine($"Ollama Interaction Exception: {ex}");
            }
            finally
            {
                IsVerifyingOllamaConnection = false;
                IsFetchingOllamaModels = false;
            }
        }

        private bool CanTestDaminionConnection()
        {
            return !IsVerifyingDaminionConnectionTest && Settings != null &&
                   !string.IsNullOrWhiteSpace(Settings.DaminionServerUrl) &&
                   !string.IsNullOrWhiteSpace(Settings.DaminionUsername) &&
                   !string.IsNullOrWhiteSpace(Settings.DaminionPassword);
        }

        private async Task TestDaminionConnectionAsync()
        {
            if (!CanTestDaminionConnection() || Settings == null) return;

            IsVerifyingDaminionConnectionTest = true;
            DaminionConnectionTestStatus = $"Testing Daminion connection to {Settings.DaminionServerUrl}...";

            using (var testDaminionClient = new DaminionApiClient())
            {
                try
                {
                    bool loginSuccess = await testDaminionClient.LoginAsync(Settings.DaminionServerUrl, Settings.DaminionUsername, Settings.DaminionPassword);
                    DaminionConnectionTestStatus = loginSuccess ? "Daminion connection successful!" : "Daminion login failed. Check credentials/URL. See Output window for DaminionApiClient logs.";
                }
                catch (Exception ex)
                {
                    DaminionConnectionTestStatus = $"Daminion connection error: {ex.Message}";
                    System.Diagnostics.Debug.WriteLine($"Daminion Connection Test Exception: {ex}");
                }
                finally
                {
                    IsVerifyingDaminionConnectionTest = false;
                }
            }
        }

        private bool CanVerifyGemmaConnection()
        {
            return !IsVerifyingGemmaConnection && Settings != null && !string.IsNullOrWhiteSpace(Settings.GemmaServiceAccountJsonPath);
        }

        private async Task VerifyAndFetchGemmaModelsAsync()
        {
            if (!CanVerifyGemmaConnection() || Settings == null) return;
            IsVerifyingGemmaConnection = true;
            GemmaConnectionStatus = "Verifying Gemma credentials and loading models...";
            Application.Current.Dispatcher.Invoke(() => GemmaModels.Clear());
            try
            {
                string maskedPath = string.IsNullOrEmpty(Settings.GemmaServiceAccountJsonPath) ? "(empty)" : System.IO.Path.GetFileName(Settings.GemmaServiceAccountJsonPath);
                string logMsg = $"[Gemma] Credential/model list check: Service Account JSON: {maskedPath}";
                Logger.Information(logMsg);
                if (App.Logger != null) App.Logger.Log(logMsg);

                var client = new DaminionOllamaApp.Services.GemmaApiClient(Settings.GemmaServiceAccountJsonPath, ""); // No model name needed for listing
                string requestUrl = $"https://generativelanguage.googleapis.com/v1beta/models (OAuth2 Bearer)";
                Logger.Information($"[Gemma] Request URL: {requestUrl}");
                if (App.Logger != null) App.Logger.Log($"[Gemma] Request URL: {requestUrl}");

                var models = await client.ListModelsAsync();
                Logger.Information($"[Gemma] ListModelsAsync returned {models?.Count ?? 0} models.");
                if (App.Logger != null) App.Logger.Log($"[Gemma] ListModelsAsync returned {models?.Count ?? 0} models.");

                // Filtering for free models if requested
                List<string> filteredModels = new List<string>();
                if (OnlyShowFreeGeminiGemmaModels && models != null)
                {
                    filteredModels = models.Where(m =>
                        m.StartsWith("models/gemini-1.5-pro") ||
                        m.StartsWith("models/gemini-1.5-flash") ||
                        m.StartsWith("models/gemma-2-9b-it") ||
                        m.StartsWith("models/gemma-2-27b-it")
                    ).ToList();
                }
                else if (models != null)
                {
                    filteredModels = models;
                }

                if (filteredModels.Count > 0)
                {
                    foreach (var model in filteredModels)
                    {
                        Logger.Information($"[Gemma] Model found: {model}");
                        if (App.Logger != null) App.Logger.Log($"[Gemma] Model found: {model}");
                        GemmaModels.Add(model);
                    }
                    GemmaConnectionStatus = $"{GemmaModels.Count} models found.";
                    // Only set SelectedGemmaModelName if the current setting is in the list, otherwise pick the first
                    if (!string.IsNullOrWhiteSpace(Settings.GemmaModelName) && GemmaModels.Contains(Settings.GemmaModelName))
                    {
                        SelectedGemmaModelName = Settings.GemmaModelName;
                    }
                    else if (GemmaModels.Any())
                    {
                        SelectedGemmaModelName = GemmaModels.FirstOrDefault();
                    }
                }
                else
                {
                    Logger.Warning("[Gemma] Failed to fetch models from Gemma. Check Service Account JSON or filter.");
                    if (App.Logger != null) App.Logger.Log("[Gemma] Failed to fetch models from Gemma. Check Service Account JSON or filter.");
                    GemmaConnectionStatus = "Failed to fetch models from Gemma. Check Service Account JSON or filter.";
                }
            }
            catch (Exception ex)
            {
                Logger.Error(ex, $"[Gemma] Exception during credential/model check: {ex.Message}");
                if (App.Logger != null) App.Logger.Log($"[Gemma] Exception during credential/model check: {ex}");
                GemmaConnectionStatus = $"Error: {ex.Message}";
            }
            finally
            {
                IsVerifyingGemmaConnection = false;
            }
        }

        private async Task RefreshProjectsAsync()
        {
            GcpProjects.Clear();
            if (string.IsNullOrWhiteSpace(Settings.GemmaServiceAccountJsonPath)) return;
            var projects = await GoogleCloudResourceHelper.ListProjectsAsync(Settings.GemmaServiceAccountJsonPath);
            foreach (var p in projects) GcpProjects.Add(p);
        }
        private async Task RefreshDatasetsAsync()
        {
            BigQueryDatasets.Clear();
            if (string.IsNullOrWhiteSpace(Settings.GemmaServiceAccountJsonPath) || string.IsNullOrWhiteSpace(Settings.BigQueryProjectId)) return;
            var datasets = await GoogleCloudResourceHelper.ListDatasetsAsync(Settings.BigQueryProjectId, Settings.GemmaServiceAccountJsonPath);
            foreach (var d in datasets) BigQueryDatasets.Add(d);
        }
        private async Task RefreshTablesAsync()
        {
            BigQueryTables.Clear();
            if (string.IsNullOrWhiteSpace(Settings.GemmaServiceAccountJsonPath) || string.IsNullOrWhiteSpace(Settings.BigQueryProjectId) || string.IsNullOrWhiteSpace(Settings.BigQueryDataset)) return;
            var tables = await GoogleCloudResourceHelper.ListTablesAsync(Settings.BigQueryProjectId, Settings.BigQueryDataset, Settings.GemmaServiceAccountJsonPath);
            foreach (var t in tables) BigQueryTables.Add(t);
        }
        private async Task CheckBillingExportTableAsync()
        {
            BillingExportInstructions = string.Empty;
            if (string.IsNullOrWhiteSpace(Settings.GemmaServiceAccountJsonPath) || string.IsNullOrWhiteSpace(Settings.BigQueryProjectId) || string.IsNullOrWhiteSpace(Settings.BigQueryDataset) || string.IsNullOrWhiteSpace(Settings.BigQueryTable))
            {
                BillingExportInstructions = "Please select a project, dataset, and table.";
                return;
            }
            bool isBilling = false;
            try
            {
                isBilling = await GoogleCloudResourceHelper.IsBillingExportTableAsync(Settings.BigQueryProjectId, Settings.BigQueryDataset, Settings.BigQueryTable, Settings.GemmaServiceAccountJsonPath);
            }
            catch
            {
                BillingExportInstructions = "Could not access table. Check permissions and selections.";
                return;
            }
            if (!isBilling)
            {
                BillingExportInstructions = "The selected table is not a GCP Billing Export table.\nTo enable billing export, go to the GCP Console > Billing > Reports > Export > Enable BigQuery Export.";
            }
            else
            {
                BillingExportInstructions = "Billing export table detected.";
            }
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected virtual bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = "")
        {
            if (EqualityComparer<T>.Default.Equals(storage, value)) return false;
            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }
        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = "")
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
                LogSettingChange(propertyName, GetType().GetProperty(propertyName)?.GetValue(this));
            });
        }

        // Example: Log when settings are changed
        private void LogSettingChange(string property, object? value)
        {
            Logger.Information("Setting changed: {Property} = {Value}", property, value);
        }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Views\SettingsWindow.xaml">
<![CDATA[
<Window x:Class="DaminionOllamaApp.Views.SettingsWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:DaminionOllamaApp.Views" 
        xmlns:viewModels="clr-namespace:DaminionOllamaApp.ViewModels"
        xmlns:converters="clr-namespace:DaminionOllamaApp.Converters"
        mc:Ignorable="d"
        Title="Settings" Width="650" Height="Auto"
        SizeToContent="Height"
        WindowStartupLocation="CenterOwner" ResizeMode="NoResize"
        MaxHeight="850">
    <Window.Resources>
        <converters:CountToBooleanConverter x:Key="CountToBoolConverter" />
    </Window.Resources>
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <TabControl Margin="10" Grid.Row="0">
            <TabItem Header="Daminion">
                <ScrollViewer VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Disabled">
                    <StackPanel>
                        <GroupBox Header="Daminion API Settings" Margin="0,0,0,5" Padding="5">
                            <StackPanel>
                                <Label Content="Daminion Server URL:" Padding="0,0,0,1"/>
                                <TextBox Text="{Binding Settings.DaminionServerUrl, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,3" />
                                <Label Content="Username:" Padding="0,0,0,1"/>
                                <TextBox Text="{Binding Settings.DaminionUsername, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,3" />
                                <Label Content="Password:" Padding="0,0,0,1"/>
                                <PasswordBox x:Name="DaminionPasswordBox" PasswordChanged="DaminionPasswordBox_PasswordChanged" Margin="0,0,0,3" />
                                <Button Content="Test Daminion Connection" 
                                        Command="{Binding TestDaminionConnectionCommand}" 
                                        HorizontalAlignment="Left" 
                                        Margin="0,8,0,0" Padding="5,2"/>
                                <TextBlock Text="{Binding DaminionConnectionTestStatus}" Margin="0,3,0,3" TextWrapping="Wrap" Foreground="Gray" MinHeight="16"/>
                            </StackPanel>
                        </GroupBox>
                        <GroupBox Header="Daminion Target Tag GUIDs" Margin="0,5,0,5" Padding="5">
                            <StackPanel>
                                <Button Content="Discover Standard GUIDs" 
                                        Command="{Binding DiscoverTagGuidsCommand}" 
                                        HorizontalAlignment="Left" 
                                        Margin="0,0,0,3" Padding="5,2"/>
                                <TextBlock Text="{Binding DiscoveryStatusMessage}" Foreground="DimGray" TextWrapping="Wrap" Margin="0,0,0,8" MinHeight="20" VerticalAlignment="Top"/>
                                <Label Content="Description Tag GUID:" Padding="0,0,0,1"/>
                                <TextBox Text="{Binding Settings.DaminionDescriptionTagGuid, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,3" FontFamily="Consolas"/>
                                <Label Content="Keywords Tag GUID:" Padding="0,0,0,1"/>
                                <TextBox Text="{Binding Settings.DaminionKeywordsTagGuid, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,3" FontFamily="Consolas"/>
                                <Label Content="Categories Tag GUID:" Padding="0,0,0,1"/>
                                <TextBox Text="{Binding Settings.DaminionCategoriesTagGuid, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,3" FontFamily="Consolas"/>
                                <Label Content="Flag Tag GUID (Optional):" Padding="0,0,0,1"/>
                                <TextBox Text="{Binding Settings.DaminionFlagTagGuid, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,3" FontFamily="Consolas"/>
                            </StackPanel>
                        </GroupBox>
                        <GroupBox Header="Post-Ollama Processing Daminion Flag Options" Margin="0,5,0,5" Padding="5">
                            <StackPanel>
                                <CheckBox Content="Automatically update Daminion flag after successful Ollama processing"
                                          IsChecked="{Binding Settings.AutomaticallyUpdateFlagAfterOllama}" Margin="0,0,0,5"/>
                                <Grid IsEnabled="{Binding Settings.AutomaticallyUpdateFlagAfterOllama}">
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="Auto"/>
                                        <ColumnDefinition Width="*"/>
                                    </Grid.ColumnDefinitions>
                                    <Grid.RowDefinitions>
                                        <RowDefinition Height="Auto"/>
                                        <RowDefinition Height="Auto"/>
                                    </Grid.RowDefinitions>
                                    <Label Grid.Row="0" Grid.Column="0" Content="Flag Value ID to Clear (e.g., 'Unflagged' ID):" VerticalAlignment="Center" Margin="20,0,5,0"/>
                                    <TextBox Grid.Row="0" Grid.Column="1" Text="{Binding Settings.FlagValueIdToClearAfterOllama, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,3" FontFamily="Consolas"/>
                                    <Label Grid.Row="1" Grid.Column="0" Content="Flag Value ID to Set (e.g., 'Processed' ID):" VerticalAlignment="Center" Margin="20,0,5,0"/>
                                    <TextBox Grid.Row="1" Grid.Column="1" Text="{Binding Settings.FlagValueIdToSetAfterOllama, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,3" FontFamily="Consolas"/>
                                </Grid>
                                <TextBlock Text="Note: 'Flag Tag GUID' must be set in 'Daminion Target Tag GUIDs' section for this to work." FontStyle="Italic" FontSize="10" Margin="20,5,0,0" TextWrapping="Wrap"/>
                            </StackPanel>
                        </GroupBox>
                    </StackPanel>
                </ScrollViewer>
            </TabItem>
            <TabItem Header="Ollama">
                <ScrollViewer VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Disabled">
                    <StackPanel>
                        <GroupBox Header="Ollama API Settings" Margin="0,5,0,5" Padding="5">
                            <StackPanel>
                                <Label Content="Ollama Server URL:" Padding="0,0,0,1"/>
                                <Grid Margin="0,0,0,3">
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="*" />
                                        <ColumnDefinition Width="Auto" />
                                    </Grid.ColumnDefinitions>
                                    <TextBox Grid.Column="0" Text="{Binding Settings.OllamaServerUrl, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,5,0" VerticalAlignment="Center"/>
                                    <Button Grid.Column="1" Content="Verify &amp; Load Models" 
                                            Command="{Binding VerifyOllamaConnectionCommand}" 
                                            MinWidth="140" Padding="5,2"/>
                                </Grid>
                                <TextBlock Text="{Binding OllamaConnectionStatus}" Margin="0,3,0,3" TextWrapping="Wrap" Foreground="Gray" MinHeight="16"/>
                                <Label Content="Select Ollama Model:" Margin="0,8,0,0" Padding="0,0,0,1"/>
                                <ComboBox ItemsSource="{Binding OllamaModels}" 
                                          SelectedItem="{Binding SelectedOllamaModelName}"
                                          IsEnabled="{Binding OllamaModels.Count, Converter={StaticResource CountToBoolConverter}}" 
                                          Margin="0,0,0,3">
                                    <ComboBox.Style>
                                        <Style TargetType="ComboBox" BasedOn="{StaticResource {x:Type ComboBox}}">
                                            <Style.Triggers>
                                                <Trigger Property="IsEnabled" Value="False">
                                                    <Setter Property="ToolTip" Value="Verify connection to load models, or no models found."/>
                                                </Trigger>
                                            </Style.Triggers>
                                        </Style>
                                    </ComboBox.Style>
                                </ComboBox>
                            </StackPanel>
                        </GroupBox>
                    </StackPanel>
                </ScrollViewer>
            </TabItem>
            <TabItem Header="OpenRouter">
                <ScrollViewer VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Disabled">
                    <StackPanel>
                        <GroupBox Header="OpenRouter API Settings" Margin="0,5,0,5" Padding="5">
                            <StackPanel>
                                <Label Content="OpenRouter API Key:" Padding="0,0,0,1"/>
                                <TextBox Text="{Binding Settings.OpenRouterApiKey, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,3" />
                                <Label Content="Your Site URL / App Name (HTTP-Referer):" Padding="0,0,0,1" Margin="0,5,0,0"/>
                                <TextBox Text="{Binding Settings.OpenRouterHttpReferer, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,3" />
                                <Button Content="Verify &amp; Load Models" 
                                        Command="{Binding VerifyOpenRouterConnectionCommand}" 
                                        HorizontalAlignment="Left" 
                                        MinWidth="140" Padding="5,2" Margin="0,8,0,0"/>
                                <TextBlock Text="{Binding OpenRouterConnectionStatus}" Margin="0,3,0,3" TextWrapping="Wrap" Foreground="Gray" MinHeight="16"/>
                                <Label Content="Select OpenRouter Model:" Margin="0,8,0,0" Padding="0,0,0,1"/>
                                <ComboBox ItemsSource="{Binding OpenRouterModels}" 
                                          SelectedItem="{Binding SelectedOpenRouterModelName}"
                                          IsEnabled="{Binding OpenRouterModels.Count, Converter={StaticResource CountToBoolConverter}}">
                                    <ComboBox.Style>
                                        <Style TargetType="ComboBox" BasedOn="{StaticResource {x:Type ComboBox}}">
                                            <Style.Triggers>
                                                <Trigger Property="IsEnabled" Value="False">
                                                    <Setter Property="ToolTip" Value="Verify connection to load models, or no models found."/>
                                                </Trigger>
                                            </Style.Triggers>
                                        </Style>
                                    </ComboBox.Style>
                                </ComboBox>
                            </StackPanel>
                        </GroupBox>
                    </StackPanel>
                </ScrollViewer>
            </TabItem>
            <TabItem Header="Gemma">
                <ScrollViewer VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Disabled">
                    <StackPanel>
                        <GroupBox Header="Gemma API Settings" Margin="0,5,0,5" Padding="5">
                            <StackPanel>
                                <Label Content="Gemma Service Account JSON Path:" Padding="0,0,0,1"/>
                                <DockPanel Margin="0,0,0,3">
                                    <TextBox Text="{Binding Settings.GemmaServiceAccountJsonPath, UpdateSourceTrigger=PropertyChanged}" Width="340" VerticalAlignment="Center"/>
                                    <Button Content="Browse..." Width="70" Margin="5,0,0,0" VerticalAlignment="Center" Click="GemmaServiceAccountBrowse_Click" />
                                </DockPanel>
                                <StackPanel Orientation="Horizontal" Margin="0,8,0,0">
                                    <Button Content="Test Credentials &amp; Load Models" 
                                            Command="{Binding VerifyGemmaConnectionCommand}" 
                                            MinWidth="140" Padding="5,2"/>
                                    <CheckBox Content="Only free" Margin="12,0,0,0" VerticalAlignment="Center"
                                              IsChecked="{Binding OnlyShowFreeGeminiGemmaModels, Mode=TwoWay}"/>
                                </StackPanel>
                                <TextBlock Text="{Binding GemmaConnectionStatus}" Margin="0,3,0,3" TextWrapping="Wrap" Foreground="Gray" MinHeight="16"/>
                                <Label Content="Select Gemma Model:" Margin="0,8,0,0" Padding="0,0,0,1"/>
                                <ComboBox ItemsSource="{Binding GemmaModels}" 
                                          SelectedItem="{Binding SelectedGemmaModelName}"
                                          IsEnabled="{Binding GemmaModels.Count, Converter={StaticResource CountToBoolConverter}}">
                                    <ComboBox.Style>
                                        <Style TargetType="ComboBox" BasedOn="{StaticResource {x:Type ComboBox}}">
                                            <Style.Triggers>
                                                <Trigger Property="IsEnabled" Value="False">
                                                    <Setter Property="ToolTip" Value="Test credentials to load models, or no models found."/>
                                                </Trigger>
                                            </Style.Triggers>
                                        </Style>
                                    </ComboBox.Style>
                                </ComboBox>
                            </StackPanel>
                        </GroupBox>
                        <GroupBox Header="Gemma Model Name (Manual Entry)" Margin="0,5,0,5" Padding="5">
                            <TextBox Text="{Binding Settings.GemmaModelName, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,3" />
                        </GroupBox>
                        <GroupBox Header="BigQuery Billing Export (for Spend Tracking)" Margin="0,5,0,5" Padding="5">
                            <StackPanel>
                                <StackPanel Orientation="Horizontal" Margin="0,0,0,3">
                                    <Label Content="Project:" Width="60"/>
                                    <ComboBox ItemsSource="{Binding GcpProjects}" SelectedItem="{Binding Settings.BigQueryProjectId, Mode=TwoWay}" Width="220" Margin="0,0,5,0"/>
                                    <Button Content="Refresh" Command="{Binding RefreshProjectsCommand}" Width="70"/>
                                </StackPanel>
                                <StackPanel Orientation="Horizontal" Margin="0,0,0,3">
                                    <Label Content="Dataset:" Width="60"/>
                                    <ComboBox ItemsSource="{Binding BigQueryDatasets}" SelectedItem="{Binding Settings.BigQueryDataset, Mode=TwoWay}" Width="220" Margin="0,0,5,0"/>
                                    <Button Content="Refresh" Command="{Binding RefreshDatasetsCommand}" Width="70"/>
                                </StackPanel>
                                <StackPanel Orientation="Horizontal" Margin="0,0,0,3">
                                    <Label Content="Table:" Width="60"/>
                                    <ComboBox ItemsSource="{Binding BigQueryTables}" SelectedItem="{Binding Settings.BigQueryTable, Mode=TwoWay}" Width="220" Margin="0,0,5,0"/>
                                    <Button Content="Refresh" Command="{Binding RefreshTablesCommand}" Width="70"/>
                                    <Button Content="Check" Command="{Binding CheckBillingExportTableCommand}" Width="60" Margin="5,0,0,0"/>
                                </StackPanel>
                                <TextBlock Text="{Binding BillingExportInstructions}" Foreground="DarkRed" TextWrapping="Wrap" Margin="0,5,0,0"/>
                            </StackPanel>
                        </GroupBox>
                    </StackPanel>
                </ScrollViewer>
            </TabItem>
            <TabItem Header="Other">
                <ScrollViewer VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Disabled">
                    <StackPanel>
                        <GroupBox Header="Ollama Prompt" Margin="0,5,0,5" Padding="5">
                            <TextBox Text="{Binding Settings.OllamaPrompt, UpdateSourceTrigger=PropertyChanged}"
                                     AcceptsReturn="True" TextWrapping="Wrap" VerticalScrollBarVisibility="Auto"
                                     MinHeight="70" MaxHeight="120" FontFamily="Consolas"/>
                        </GroupBox>
                    </StackPanel>
                </ScrollViewer>
            </TabItem>
        </TabControl>
        <StackPanel Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,10,10,0" Grid.Row="1">
            <Button Content="Save" Command="{Binding SaveCommand}" Width="75" Margin="0,0,10,0" IsDefault="True" />
            <Button Content="Close" Command="{Binding CloseCommand}" Width="75" IsCancel="True" />
        </StackPanel>
    </Grid>
</Window>
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\Views\SettingsWindow.xaml.cs">
<![CDATA[
// DaminionOllamaApp/Views/SettingsWindow.xaml.cs
using DaminionOllamaApp.ViewModels;
using System.Windows;
using System.Windows.Controls; // Required for PasswordBox
using Microsoft.Win32; // For OpenFileDialog

namespace DaminionOllamaApp.Views
{
    public partial class SettingsWindow : Window
    {
        public SettingsWindow()
        {
            InitializeComponent();
        }

        // This event handler updates the ViewModel's password property when the PasswordBox changes.
        private void DaminionPasswordBox_PasswordChanged(object sender, RoutedEventArgs e)
        {
            if (DataContext is SettingsViewModel viewModel && sender is PasswordBox passwordBox)
            {
                viewModel.SetDaminionPassword(passwordBox.Password);
            }
        }

        // This method can be called by the ViewModel (or the code that shows the window)
        // to set the initial value of the PasswordBox when settings are loaded.
        public void SetPasswordBox(string password)
        {
            DaminionPasswordBox.Password = password;
        }

        // Event handler for the Gemma Service Account JSON file picker
        private void GemmaServiceAccountBrowse_Click(object sender, RoutedEventArgs e)
        {
            var dlg = new OpenFileDialog
            {
                Filter = "JSON files (*.json)|*.json|All files (*.*)|*.*",
                Title = "Select Google Service Account JSON File"
            };
            if (dlg.ShowDialog() == true)
            {
                if (DataContext is SettingsViewModel viewModel)
                {
                    viewModel.Settings.GemmaServiceAccountJsonPath = dlg.FileName;
                }
            }
        }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\App.xaml">
<![CDATA[
<Application x:Class="DaminionOllamaApp.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:DaminionOllamaApp"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
         
    </Application.Resources>
</Application>

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\App.xaml.cs">
<![CDATA[
using System.Configuration;
using System.Data;
using System.Windows;
using DaminionOllamaApp.Services;

namespace DaminionOllamaApp
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
        public static LogService? Logger { get; private set; }

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            Logger = new LogService();
            Logger.Log("Application started.");
        }

        protected override void OnExit(ExitEventArgs e)
        {
            Logger?.Log("Application exiting.");
            Logger?.Dispose();
            base.OnExit(e);
        }
    }
}

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\AssemblyInfo.cs">
<![CDATA[
using System.Windows;

[assembly: ThemeInfo(
    ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
                                                //(used if a resource is not found in the page,
                                                // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
                                                //(used if a resource is not found in the page,
                                                // app, or any theme specific resource dictionaries)
)]

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\DaminionOllamaApp.csproj">
<![CDATA[
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows10.0.26100.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UseWPF>true</UseWPF>
    <ApplicationIcon>Daminion-Llama.ico</ApplicationIcon>
  </PropertyGroup>

  <ItemGroup>
    <Content Include="Daminion-Llama.ico" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\DaminionOllamaInteractionLib\DaminionOllamaInteractionLib.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Google.Apis.Auth" Version="1.70.0" />
    <PackageReference Include="Google.Apis.CloudResourceManager.v1" Version="1.70.0.3809" />
    <PackageReference Include="Google.Cloud.BigQuery.V2" Version="3.11.0" />
    <PackageReference Include="System.Text.Json" Version="9.0.5" />
  </ItemGroup>

</Project>

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\MainWindow.xaml">
<![CDATA[
<Window x:Class="DaminionOllamaApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:DaminionOllamaApp"
        xmlns:viewModels="clr-namespace:DaminionOllamaApp.ViewModels"
        xmlns:models="clr-namespace:DaminionOllamaApp.Models"
        xmlns:converters="clr-namespace:DaminionOllamaApp.Converters"
        mc:Ignorable="d"
        Title="Daminion Llama Processor" Height="600" Width="900">
    <Window.Resources>
        <BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>

        <converters:EnumToBooleanConverter x:Key="EnumToBooleanConverter"/>

    </Window.Resources>
    <Window.DataContext>
        <viewModels:MainViewModel/>
    </Window.DataContext>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>

        <Menu Grid.Row="0">
            <MenuItem Header="_File">
                <MenuItem Header="_Settings" Command="{Binding OpenSettingsCommand}" />
                <Separator />
                <MenuItem Header="E_xit" Command="{Binding ExitCommand}" />
            </MenuItem>
        </Menu>

        <TabControl Grid.Row="1" Margin="5">
            <TabItem Header="Local File Tagger">
                <Grid Margin="5" DataContext="{Binding LocalFileTaggerVM}">
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto" /> <!-- Real spend alert -->
                        <RowDefinition Height="Auto" /> <!-- Actual spend and refresh -->
                        <RowDefinition Height="Auto" /> <!-- Free tier exceeded alert -->
                        <RowDefinition Height="Auto" /> <!-- AI Provider group -->
                        <RowDefinition Height="Auto" /> <!-- File operation buttons -->
                        <RowDefinition Height="*" />   <!-- ListView -->
                        <RowDefinition Height="Auto" /> <!-- Status TextBox -->
                    </Grid.RowDefinitions>

                    <!-- Real spend alert -->
                    <TextBlock Grid.Row="0" Text="Actual spend this month exceeds the free tier! Paid usage in effect."
                               Foreground="Red" FontWeight="Bold" Margin="0,0,0,5"
                               Visibility="{Binding ShowActualSpendAlert, Converter={StaticResource BooleanToVisibilityConverter}}"/>

                    <!-- Actual spend and refresh -->
                    <StackPanel Grid.Row="1" Orientation="Horizontal" Margin="0,0,0,5">
                        <TextBlock Text="Actual spend this month: " FontWeight="Bold"/>
                        <TextBlock Text="{Binding ActualSpendUSD, StringFormat=$\u200E{0:F2}}" Margin="5,0,0,0"/>
                        <Button Content="Refresh Spend" Command="{Binding RefreshActualSpendCommand}" Margin="10,0,0,0"/>
                    </StackPanel>

                    <!-- Free tier exceeded alert (estimate) -->
                    <TextBlock Grid.Row="2" Text="Warning: Free tier exceeded for the selected model! Paid usage in effect."
                               Foreground="Red" FontWeight="Bold" Margin="0,0,0,10"
                               Visibility="{Binding FreeTierExceededForSelectedModel, Converter={StaticResource BooleanToVisibilityConverter}}"/>

                    <!-- AI Provider group -->
                    <GroupBox Grid.Row="3" Header="AI Provider" Padding="5" Margin="0,0,0,10">
                        <StackPanel Orientation="Horizontal">
                            <RadioButton GroupName="LocalProvider" Content="Ollama" Margin="0,0,20,0"
                                         IsChecked="{Binding Settings.SelectedAiProvider, Converter={StaticResource EnumToBooleanConverter}, ConverterParameter={x:Static models:AiProvider.Ollama}}"/>
                            <RadioButton GroupName="LocalProvider" Content="OpenRouter"
                                         IsChecked="{Binding Settings.SelectedAiProvider, Converter={StaticResource EnumToBooleanConverter}, ConverterParameter={x:Static models:AiProvider.OpenRouter}}"/>
                            <RadioButton GroupName="LocalProvider" Content="Gemma"
                                         IsChecked="{Binding Settings.SelectedAiProvider, Converter={StaticResource EnumToBooleanConverter}, ConverterParameter={x:Static models:AiProvider.Gemma}}"/>
                        </StackPanel>
                    </GroupBox>

                    <!-- File operation buttons -->
                    <StackPanel Grid.Row="4" Orientation="Horizontal" Margin="0,5,0,10">
                        <Button Content="Add Files..." Command="{Binding AddFilesCommand}" Width="100" Margin="0,0,5,0" />
                        <Button Content="Start Queue" Command="{Binding StartQueueCommand}" Width="100" Margin="0,0,5,0" />
                        <Button Content="Stop Queue" Command="{Binding StopQueueCommand}" Width="100" Margin="0,0,15,0" />
                        <Button Content="Remove Selected" Command="{Binding RemoveSelectedFileCommand}" Width="120" Margin="0,0,5,0" />
                        <Button Content="Clear Processed" Command="{Binding ClearProcessedFilesCommand}" Width="110" Margin="0,0,5,0" />
                        <Button Content="Clear All" Command="{Binding ClearAllFilesCommand}" Width="80" />
                    </StackPanel>

                    <!-- ListView -->
                    <ListView Grid.Row="5" ItemsSource="{Binding FilesToProcess}" SelectionMode="Single"
                              SelectedItem="{Binding SelectedFile}" Margin="0,0,0,5">
                        <ListView.View>
                            <GridView>
                                <GridViewColumn Header="File Name" Width="300" DisplayMemberBinding="{Binding FileName}" />
                                <GridViewColumn Header="Status" Width="150" DisplayMemberBinding="{Binding Status}" />
                                <GridViewColumn Header="Details" Width="300" DisplayMemberBinding="{Binding StatusMessage}" />
                            </GridView>
                        </ListView.View>
                    </ListView>

                    <!-- Status TextBox -->
                    <TextBox Grid.Row="6" Text="{Binding CurrentOperationStatus}"
                             IsReadOnly="True" TextWrapping="Wrap" VerticalScrollBarVisibility="Auto"
                             MinHeight="60" MaxHeight="150" Margin="0,10,0,0" />
                </Grid>
            </TabItem>

            <TabItem Header="Daminion Query Tagger">
                <Grid Margin="5" DataContext="{Binding DaminionCollectionTaggerVM}">
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto" /> <!-- AI Provider group -->
                        <RowDefinition Height="Auto" /> <!-- Login and Query Type -->
                        <RowDefinition Height="Auto" /> <!-- Queue buttons -->
                        <RowDefinition Height="*" />   <!-- ListView -->
                        <RowDefinition Height="Auto" /> <!-- Status TextBox -->
                    </Grid.RowDefinitions>

                    <!-- AI Provider group -->
                    <GroupBox Grid.Row="0" Header="AI Provider" Padding="5" Margin="0,0,0,10">
                        <StackPanel Orientation="Horizontal">
                            <RadioButton GroupName="DaminionProvider" Content="Ollama" Margin="0,0,20,0"
                                         IsChecked="{Binding Settings.SelectedAiProvider, Converter={StaticResource EnumToBooleanConverter}, ConverterParameter={x:Static models:AiProvider.Ollama}}"/>
                            <RadioButton GroupName="DaminionProvider" Content="OpenRouter"
                                         IsChecked="{Binding Settings.SelectedAiProvider, Converter={StaticResource EnumToBooleanConverter}, ConverterParameter={x:Static models:AiProvider.OpenRouter}}"/>
                            <RadioButton GroupName="DaminionProvider" Content="Gemma"
                                         IsChecked="{Binding Settings.SelectedAiProvider, Converter={StaticResource EnumToBooleanConverter}, ConverterParameter={x:Static models:AiProvider.Gemma}}"/>
                        </StackPanel>
                    </GroupBox>

                    <!-- Login and Query Type -->
                    <StackPanel Grid.Row="1" Orientation="Vertical" Margin="0,0,0,10">
                        <StackPanel Orientation="Horizontal">
                            <Button Content="Login to Daminion" Command="{Binding LoginCommand}" Width="150" Margin="0,0,10,0" />
                            <TextBlock Text="{Binding DaminionStatus}" VerticalAlignment="Center" Margin="10,0,0,0" TextWrapping="Wrap" />
                        </StackPanel>

                        <StackPanel Orientation="Horizontal" Margin="0,10,0,0">
                            <Label Content="Select Query Type:" VerticalAlignment="Center" IsEnabled="{Binding IsLoggedIn}" />
                            <ComboBox ItemsSource="{Binding QueryTypes}"
                                      SelectedItem="{Binding SelectedQueryType}"
                                      DisplayMemberPath="DisplayName" 
                                      MinWidth="200" Margin="5,0,10,0"
                                      IsEnabled="{Binding IsLoggedIn}" />
                            <Button Content="Load Daminion Items" Command="{Binding LoadItemsByQueryCommand}" Width="150" IsEnabled="{Binding IsLoggedIn}"/>
                        </StackPanel>
                    </StackPanel>

                    <!-- Queue buttons -->
                    <StackPanel Grid.Row="2" Orientation="Horizontal" Margin="0,5,0,10">
                        <Button Content="Start Daminion Queue" Command="{Binding StartDaminionQueueCommand}" Width="160" Margin="0,0,5,0" />
                        <Button Content="Stop Daminion Queue" Command="{Binding StopDaminionQueueCommand}" Width="160" />
                    </StackPanel>

                    <!-- ListView -->
                    <ListView Grid.Row="3" ItemsSource="{Binding DaminionFilesToProcess}" SelectionMode="Single" Margin="0,0,0,5">
                        <ListView.View>
                            <GridView>
                                <GridViewColumn Header="Daminion ID" Width="100" DisplayMemberBinding="{Binding DaminionItemId}" />
                                <GridViewColumn Header="Item Name" Width="250" DisplayMemberBinding="{Binding FileName}" />
                                <GridViewColumn Header="File Path" Width="250" DisplayMemberBinding="{Binding FilePath}" />
                                <GridViewColumn Header="Status" Width="120" DisplayMemberBinding="{Binding Status}" />
                                <GridViewColumn Header="Details" Width="200" DisplayMemberBinding="{Binding StatusMessage}" />
                            </GridView>
                        </ListView.View>
                    </ListView>

                    <!-- Status TextBox -->
                    <TextBox Grid.Row="4" Text="{Binding DaminionStatus}"
                             IsReadOnly="True" TextWrapping="Wrap" VerticalScrollBarVisibility="Auto"
                             MinHeight="40" MaxHeight="100" Margin="0,10,0,0" />
                </Grid>
            </TabItem>

            <TabItem Header="Metadata Tidy-up">
                <Grid Margin="5" DataContext="{Binding MetadataTidyUpVM}">
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto" /> <!-- Processing Mode -->
                        <RowDefinition Height="Auto" /> <!-- Daminion login/query (border) -->
                        <RowDefinition Height="Auto" /> <!-- Add Local Files -->
                        <RowDefinition Height="Auto" /> <!-- Cleanup Options -->
                        <RowDefinition Height="Auto" /> <!-- Cleanup buttons -->
                        <RowDefinition Height="*" />   <!-- ListView -->
                        <RowDefinition Height="Auto" /> <!-- Status TextBox -->
                    </Grid.RowDefinitions>

                    <!-- Processing Mode -->
                    <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,0,0,10">
                        <Label Content="Processing Mode:" VerticalAlignment="Center"/>
                        <RadioButton Content="Local Files" GroupName="TidyUpMode" Margin="5,0,0,0"
                                     IsChecked="{Binding IsLocalFilesMode, UpdateSourceTrigger=PropertyChanged}" VerticalAlignment="Center"/>
                        <RadioButton Content="Daminion Catalog" GroupName="TidyUpMode" Margin="10,0,0,0"
                                     IsChecked="{Binding IsDaminionCatalogMode, UpdateSourceTrigger=PropertyChanged}" VerticalAlignment="Center"/>
                    </StackPanel>

                    <!-- Daminion login/query (border) -->
                    <Border Grid.Row="1" BorderBrush="LightGray" BorderThickness="0,0,0,1" Margin="0,0,0,5" Padding="0,0,0,5"
                            Visibility="{Binding IsDaminionCatalogMode, Converter={StaticResource BooleanToVisibilityConverter}}">
                        <StackPanel Orientation="Vertical">
                            <StackPanel Orientation="Horizontal" Margin="0,0,0,5">
                                <Button Content="Login to Daminion" Command="{Binding DaminionLoginCommand}" Width="150" Margin="0,0,10,0" />
                                <TextBlock Text="{Binding DaminionLoginStatus}" VerticalAlignment="Center" TextWrapping="Wrap" />
                            </StackPanel>
                            <StackPanel Orientation="Horizontal" Margin="0,5,0,0" IsEnabled="{Binding IsDaminionLoggedIn}">
                                <Label Content="Select Daminion Query:" VerticalAlignment="Center"/>
                                <ComboBox ItemsSource="{Binding DaminionQueryTypes}"
                                          SelectedItem="{Binding SelectedDaminionQueryType}"
                                          DisplayMemberPath="DisplayName" 
                                          MinWidth="200" Margin="5,0,10,0" />
                                <Button Content="Load Daminion Items" Command="{Binding LoadDaminionItemsCommand}" Width="150"/>
                            </StackPanel>
                        </StackPanel>
                    </Border>

                    <!-- Add Local Files -->
                    <StackPanel Grid.Row="2" Orientation="Horizontal" Margin="0,0,0,5"
                                Visibility="{Binding IsLocalFilesMode, Converter={StaticResource BooleanToVisibilityConverter}}">
                        <Button Content="Add Local Files..." Command="{Binding AddFilesCommand}" Width="130"/>
                    </StackPanel>

                    <!-- Cleanup Options -->
                    <GroupBox Header="Cleanup Options" Grid.Row="3" Margin="0,5,0,10" Padding="5">
                        <StackPanel>
                            <CheckBox Content="Split comma-separated categories into individual items" 
                                      IsChecked="{Binding SplitCategories}" Margin="0,0,0,3"/>
                            <CheckBox Content="Trim standard prefix from descriptions" 
                                      IsChecked="{Binding TrimDescriptionPrefix}" Margin="0,0,0,3"/>
                            <StackPanel Orientation="Horizontal" IsEnabled="{Binding TrimDescriptionPrefix}">
                                <Label Content="Prefix to trim:" VerticalAlignment="Center" Margin="20,0,5,0"/>
                                <TextBox Text="{Binding DescriptionPrefixToTrim}" MinWidth="300" MaxWidth="450" VerticalAlignment="Center"/>
                            </StackPanel>
                        </StackPanel>
                    </GroupBox>

                    <!-- Cleanup buttons -->
                    <StackPanel Grid.Row="4" Orientation="Horizontal" Margin="0,5,0,10">
                        <Button Content="Start Cleanup" Command="{Binding StartCleanupCommand}" Width="120" Margin="0,0,5,0" />
                        <Button Content="Stop Cleanup" Command="{Binding StopCleanupCommand}" Width="120" />
                    </StackPanel>

                    <!-- ListView -->
                    <ListView Grid.Row="5" ItemsSource="{Binding FilesToProcess}" SelectionMode="Single" Margin="0,0,0,5">
                        <ListView.View>
                            <GridView>
                                <GridViewColumn Header="Source ID / Path" Width="150">
                                    <GridViewColumn.CellTemplate>
                                        <DataTemplate>
                                            <TextBlock Text="{Binding DisplayIdentifier}" ToolTip="{Binding FilePath}"/>
                                        </DataTemplate>
                                    </GridViewColumn.CellTemplate>
                                </GridViewColumn>
                                <GridViewColumn Header="File Name" Width="250" DisplayMemberBinding="{Binding FileName}" />
                                <GridViewColumn Header="Status" Width="120" DisplayMemberBinding="{Binding Status}" />
                                <GridViewColumn Header="Details" Width="200" DisplayMemberBinding="{Binding StatusMessage}" />
                            </GridView>
                        </ListView.View>
                    </ListView>

                    <!-- Status TextBox -->
                    <TextBox Grid.Row="6" Text="{Binding CurrentOperationStatus}"
                             IsReadOnly="True" TextWrapping="Wrap" VerticalScrollBarVisibility="Auto"
                             MinHeight="60" MaxHeight="100" Margin="0,10,0,0" />
                </Grid>
            </TabItem>
        </TabControl>
    </Grid>
</Window>
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaApp\MainWindow.xaml.cs">
<![CDATA[
// DaminionOllamaApp/MainWindow.xaml.cs
using DaminionOllamaApp.ViewModels; // For MainViewModel
using System.Windows;

namespace DaminionOllamaApp
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            DataContext = new MainViewModel(); // Set the DataContext here
        }

        // Ensure the old OpenSettings_Click handler from the test button is removed
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Daminion\DaminionMediaItem.cs">
<![CDATA[
// DaminionOllamaInteractionLib/Daminion/DaminionMediaItem.cs
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace DaminionOllamaInteractionLib.Daminion
{
    // This class corresponds to the 'Item' structure described on page 16
    // of the "API v4 original by Yuri.pdf" document.
    public class DaminionMediaItem
    {
        [JsonPropertyName("id")]
        public long Id { get; set; } // [cite: 84]

        [JsonPropertyName("hashCode")]
        public long? HashCode { get; set; } // [cite: 84]

        [JsonPropertyName("name")]
        public string? Name { get; set; } // [cite: 85]

        [JsonPropertyName("fileName")]
        public string? FileName { get; set; } // [cite: 86]

        [JsonPropertyName("mediaFormat")]
        public string? MediaFormat { get; set; } // [cite: 86]

        [JsonPropertyName("versionControlState")]
        public int? VersionControlState { get; set; } // [cite: 87]

        [JsonPropertyName("colorLabel")]
        public long? ColorLabel { get; set; } // ID of the value, [cite: 89]

        [JsonPropertyName("width")]
        public int? Width { get; set; } // [cite: 90]

        [JsonPropertyName("height")]
        public int? Height { get; set; } // [cite: 91]

        [JsonPropertyName("fileSize")]
        public long? FileSize { get; set; } // [cite: 92]

        [JsonPropertyName("formatType")]
        public string? FormatType { get; set; } // [cite: 92]

        [JsonPropertyName("expirationDate")]
        public string? ExpirationDate { get; set; } // [cite: 92]
    }

    // This class is a wrapper for the response from the GET /api/mediaItems/get endpoint
    // as described on page 15 of the "API v4 original by Yuri.pdf" document.
    public class DaminionSearchMediaItemsResponse
    {
        [JsonPropertyName("mediaItems")]
        public List<DaminionMediaItem>? MediaItems { get; set; } // [cite: 83]

        [JsonPropertyName("error")]
        public string? Error { get; set; } // [cite: 82]

        [JsonPropertyName("errorCode")]
        public int ErrorCode { get; set; } // [cite: 82]

        [JsonPropertyName("success")]
        public bool Success { get; set; } // [cite: 83]

        // The API documentation for /api/mediaItems/get (page 15) does not explicitly show "totalCount".
        // However, /api/mediaItems/getSort (page 13) does. If you find "totalCount" in the actual
        // response for /api/mediaItems/get, you can add it here.
        // [JsonPropertyName("totalCount")]
        // public int TotalCount { get; set; }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Daminion\DaminionPathInfo.cs">
<![CDATA[
// DaminionOllamaInteractionLib/Daminion/DaminionPathInfo.cs
using System.Collections.Generic;

namespace DaminionOllamaInteractionLib.Daminion
{
    /// <summary>
    /// Represents the result of a Daminion path operation. 
    /// </summary>
    public class DaminionPathResult // Must be public
    {
        /// <summary>
        /// Gets or sets the paths returned by the Daminion operation.
        /// </summary>
        public Dictionary<string, string>? Paths { get; set; }
        /// <summary>
        /// Gets or sets the success status of the Daminion operation.
        /// </summary>
        public bool Success { get; set; }
        /// <summary>
        /// Gets or sets the error message if the operation was not successful.
        /// </summary>
        public string? ErrorMessage { get; set; }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Daminion\DaminionTagInfo.cs">
<![CDATA[
// DaminionOllamaInteractionLib/Daminion/DaminionTagInfo.cs
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace DaminionOllamaInteractionLib.Daminion // <--- Check this namespace
{
    /// <summary>
    /// Represents the response from the Daminion API for getting tags.
    /// </summary>
    public class DaminionGetTagsResponse // <--- Must be public
    {
        [JsonPropertyName("data")]
        public List<DaminionTag>? Data { get; set; }

        [JsonPropertyName("error")]
        public string? Error { get; set; }

        [JsonPropertyName("errorCode")]
        public int ErrorCode { get; set; }

        [JsonPropertyName("success")]
        public bool Success { get; set; }
    }

    /// <summary>
    /// Represents a tag in Daminion.
    /// </summary>
    public class DaminionTag // <--- Must be public
    {
        [JsonPropertyName("id")]
        public long Id { get; set; }

        [JsonPropertyName("indexed")]
        public bool Indexed { get; set; }

        [JsonPropertyName("guid")]
        public string Guid { get; set; } = string.Empty;

        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        [JsonPropertyName("originName")]
        public string? OriginName { get; set; }

        [JsonPropertyName("readOnly")]
        public bool ReadOnly { get; set; }

        [JsonPropertyName("dataType")]
        public string DataType { get; set; } = string.Empty;

        /// <summary>
        /// Returns a string representation of the DaminionTag object.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return $"{Name} (ID: {Id}, GUID: {Guid}, Type: {DataType}, Indexed: {Indexed})";
        }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Daminion\DaminionTagValueInfo.cs">
<![CDATA[
// DaminionOllamaInteractionLib/Daminion/DaminionTagValueInfo.cs
using System.Collections.Generic;
using System.Text.Json.Serialization; // Ensure this using directive is present

namespace DaminionOllamaInteractionLib.Daminion
{
    /// <summary>
    /// Represents a tag value in Daminion.
    /// </summary>
    public class DaminionTagValue
    {
        [JsonPropertyName("text")]
        public string Text { get; set; } = string.Empty;

        [JsonPropertyName("id")]
        public long Id { get; set; }

        [JsonPropertyName("isDefaultValue")]
        public bool IsDefaultValue { get; set; }

        [JsonPropertyName("tagId")]
        public long TagId { get; set; }

        [JsonPropertyName("rawValue")]
        public string RawValue { get; set; } = string.Empty;

        [JsonPropertyName("tagName")]
        public string TagName { get; set; } = string.Empty;

        [JsonPropertyName("hasChilds")]
        public bool HasChilds { get; set; }
    }

    /// <summary>
    /// Represents the response from the Daminion API for getting tag values.
    /// </summary>
    public class DaminionGetTagValuesResponse
    {
        [JsonPropertyName("values")]
        public List<DaminionTagValue>? Values { get; set; }

        [JsonPropertyName("path")]
        public List<DaminionTagValue>? Path { get; set; }

        [JsonPropertyName("tag")]
        public DaminionTag? Tag { get; set; }

        [JsonPropertyName("error")]
        public string? Error { get; set; }

        [JsonPropertyName("errorCode")]
        public int ErrorCode { get; set; }

        [JsonPropertyName("success")]
        public bool Success { get; set; }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Daminion\DaminionUpdatePayload.cs">
<![CDATA[
// DaminionOllamaInteractionLib/Daminion/DaminionUpdatePayload.cs
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace DaminionOllamaInteractionLib.Daminion
{
    /// <summary>
    /// This class is used to create a batch change request for Daminion.
    /// </summary>
    public class DaminionBatchChangeRequest // Must be public
    {
        [JsonPropertyName("ids")]
        public List<long> Ids { get; set; } = new List<long>();

        [JsonPropertyName("data")]
        public List<DaminionUpdateOperation> Data { get; set; } = new List<DaminionUpdateOperation>();
    }

    /// <summary>
    /// This class is used to create a batch change request for Daminion.
    /// </summary>
    public class DaminionUpdateOperation // Must be public
    {
        [JsonPropertyName("guid")]
        public string Guid { get; set; } = string.Empty;

        [JsonPropertyName("id")]
        public long Id { get; set; } // Tag value ID. Set to 0 if assigning by text.

        [JsonPropertyName("value")]
        public string Value { get; set; } = string.Empty;

        [JsonPropertyName("remove")]
        public bool Remove { get; set; } = false;

        // Alias properties for compatibility with existing code
        public string TagGuid => Guid;
        public string Operation => Remove ? "remove" : "add";
    }

    /// <summary>
    /// This class is used to create a batch change response for Daminion.
    /// </summary>
    public class DaminionBatchChangeResponse // Must be public
    {
        [JsonPropertyName("success")]
        public bool Success { get; set; } // Must be public

        [JsonPropertyName("error")]
        public string? Error { get; set; }

        [JsonPropertyName("errorCode")]
        public int ErrorCode { get; set; }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs">
<![CDATA[
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\obj\Debug\net8.0\DaminionOllamaInteractionLib.AssemblyInfo.cs">
<![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DaminionOllamaInteractionLib")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+d27e96757a5cc501ab80f07942cb323fe92f9e2c")]
[assembly: System.Reflection.AssemblyProductAttribute("DaminionOllamaInteractionLib")]
[assembly: System.Reflection.AssemblyTitleAttribute("DaminionOllamaInteractionLib")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\obj\Debug\net8.0\DaminionOllamaInteractionLib.GlobalUsings.g.cs">
<![CDATA[
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Ollama\OllamaApiClient.cs">
<![CDATA[
// DaminionOllamaInteractionLib/Ollama/OllamaApiClient.cs
using System;
using System.Collections.Generic; // For List in OllamaModelInfo if used directly
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json; // For JsonSerializer
using System.Threading.Tasks;
// Ensure this using statement correctly points to where your Ollama DTOs are:
using DaminionOllamaInteractionLib.Ollama;
using Serilog;
using System.IO;
using Serilog.Sinks.File;

namespace DaminionOllamaInteractionLib.Ollama
{
    /// <summary>
    /// Client for interacting with the Ollama API.
    /// </summary>
    public class OllamaApiClient : IDisposable
    {
        private static readonly ILogger Logger;
        static OllamaApiClient()
        {
            var logDir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "DaminionOllamaApp", "logs");
            Directory.CreateDirectory(logDir);
            var logPath = Path.Combine(logDir, "ollamaapiclient.log");
            Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day, retainedFileCountLimit: 7)
                .CreateLogger();
        }

        private readonly HttpClient _httpClient;
        private string _apiBaseUrl;

        /// <summary>
        /// Initializes a new instance of the <see cref="OllamaApiClient"/> class.
        /// </summary>
        /// <param name="ollamaServerUrl"></param>
        /// <exception cref="ArgumentException"></exception>
        public OllamaApiClient(string ollamaServerUrl)
        {
            if (string.IsNullOrWhiteSpace(ollamaServerUrl))
                throw new ArgumentException("Ollama server URL cannot be empty.", nameof(ollamaServerUrl));

            _apiBaseUrl = ollamaServerUrl.TrimEnd('/');
            _httpClient = new HttpClient();
            _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
            // Increased timeout for potentially long-running Ollama requests
            _httpClient.Timeout = TimeSpan.FromMinutes(5);
            Console.WriteLine($"[OllamaApiClient] Initialized with base URL: {_apiBaseUrl}");
        }

        /// <summary>
        /// Sends a request to the Ollama API to analyze an image with a given prompt.
        /// </summary>
        /// <param name="modelName"></param>
        /// <param name="prompt"></param>
        /// <param name="imageBytes"></param>
        /// <returns></returns>
        /// <exception cref="ArgumentNullException"></exception>
        public async Task<OllamaGenerateResponse?> AnalyzeImageAsync(string modelName, string prompt, byte[] imageBytes)
        {
            if (string.IsNullOrWhiteSpace(modelName))
                throw new ArgumentNullException(nameof(modelName), "Model name cannot be empty.");
            if (string.IsNullOrWhiteSpace(prompt))
                throw new ArgumentNullException(nameof(prompt), "Prompt cannot be empty.");
            if (imageBytes == null || imageBytes.Length == 0)
                throw new ArgumentNullException(nameof(imageBytes), "Image bytes cannot be null or empty.");

            string generateUrl = $"{_apiBaseUrl}/api/generate";
            Console.WriteLine($"[OllamaApiClient] Attempting to analyze image. URL: {generateUrl}, Model: {modelName}");

            string base64Image = Convert.ToBase64String(imageBytes);
            var requestPayload = new OllamaGenerateRequest
            {
                Model = modelName,
                Prompt = prompt,
                Images = new List<string> { base64Image },
                Stream = false
            };

            try
            {
                string jsonRequest = JsonSerializer.Serialize(requestPayload,
                    new JsonSerializerOptions { DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull });
                var content = new StringContent(jsonRequest, Encoding.UTF8, "application/json");

                // Log a snippet of the request for brevity, as Base64 images are large.
                Console.WriteLine($"[OllamaApiClient] Request Payload (snippet): {{ \"model\": \"{modelName}\", \"prompt\": \"{prompt.Substring(0, Math.Min(prompt.Length, 50))}...\", \"images\": [\"Base64ImageSnippet...\"] }}");

                Console.WriteLine($"[OllamaApiClient] Sending POST request to {generateUrl}...");
                HttpResponseMessage response = await _httpClient.PostAsync(generateUrl, content);
                string responseBody = await response.Content.ReadAsStringAsync();

                Console.WriteLine($"[OllamaApiClient] Response Status Code: {response.StatusCode}");
                Console.WriteLine($"[OllamaApiClient] Response Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");

                if (response.IsSuccessStatusCode)
                {
                    OllamaGenerateResponse? ollamaResponse = null;
                    try
                    {
                        ollamaResponse = JsonSerializer.Deserialize<OllamaGenerateResponse>(responseBody);
                    }
                    catch (System.Text.Json.JsonException jsonEx)
                    {
                        Console.Error.WriteLine($"[OllamaApiClient] Error deserializing successful Ollama response: {jsonEx.Message}\n{jsonEx.StackTrace}. Body: {responseBody}");
                        return new OllamaGenerateResponse { Model = modelName, Response = $"Error: Failed to parse successful response. {jsonEx.Message}", Done = false };
                    }

                    if (ollamaResponse == null || (string.IsNullOrEmpty(ollamaResponse.Response) && ollamaResponse.Done))
                    {
                        Console.Error.WriteLine($"[OllamaApiClient] Ollama API returned success status but the response content is missing, invalid, or indicates an issue.");
                        return new OllamaGenerateResponse { Model = modelName, Response = $"Error: Successful API call but problematic response body. Raw: {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}", Done = ollamaResponse?.Done ?? false };
                    }
                    Console.WriteLine("[OllamaApiClient] Successfully deserialized Ollama response.");
                    return ollamaResponse;
                }
                else
                {
                    Console.Error.WriteLine($"[OllamaApiClient] Ollama API request failed. Status: {response.StatusCode}, Reason: {response.ReasonPhrase}.");
                    // The responseBody is already logged above.
                    return new OllamaGenerateResponse { Model = modelName, Response = $"Error: {response.StatusCode} - {response.ReasonPhrase}. See debug output for full body.", Done = false };
                }
            }
            catch (HttpRequestException ex)
            {
                Console.Error.WriteLine($"[OllamaApiClient] HTTP request error to Ollama: {ex.Message}\n{ex.StackTrace}");
                if (ex.InnerException != null)
                {
                    Console.Error.WriteLine($"[OllamaApiClient] Inner Exception: {ex.InnerException.Message}");
                }
                Console.Error.WriteLine($"[OllamaApiClient] StackTrace: {ex.StackTrace}");
                return new OllamaGenerateResponse { Model = modelName, Response = $"Error: HTTP request failed. {ex.Message}", Done = false };
            }
            catch (System.Text.Json.JsonException ex) // For errors during request serialization
            {
                Console.Error.WriteLine($"[OllamaApiClient] Error serializing Ollama request: {ex.Message}\n{ex.StackTrace}");
                return new OllamaGenerateResponse { Model = modelName, Response = $"Error: JSON processing for request failed. {ex.Message}", Done = false };
            }
            catch (TaskCanceledException ex) // Often indicates a timeout
            {
                Console.Error.WriteLine($"[OllamaApiClient] Ollama request timed out: {ex.Message}\n{ex.StackTrace}");
                if (ex.InnerException != null)
                {
                    Console.Error.WriteLine($"[OllamaApiClient] Inner Exception (Timeout): {ex.InnerException.Message}");
                }
                Console.Error.WriteLine($"[OllamaApiClient] StackTrace: {ex.StackTrace}");
                return new OllamaGenerateResponse { Model = modelName, Response = $"Error: Request to Ollama timed out. Timeout is {_httpClient.Timeout.TotalSeconds}s. {ex.Message}", Done = false };
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"[OllamaApiClient] An unexpected error occurred: {ex.Message}\n{ex.StackTrace}");
                if (ex.InnerException != null)
                {
                    Console.Error.WriteLine($"[OllamaApiClient] Inner Exception: {ex.InnerException.Message}");
                }
                Console.Error.WriteLine($"[OllamaApiClient] StackTrace: {ex.StackTrace}");
                return new OllamaGenerateResponse { Model = modelName, Response = $"Error: An unexpected error occurred. {ex.Message}", Done = false };
            }
        }

        // These methods go INSIDE the OllamaApiClient class

        /// <summary>
        /// Checks if the Ollama server is running and reachable.
        /// </summary>
        /// <returns>True if the server responds positively, false otherwise.</returns>
        public async Task<bool> CheckConnectionAsync()
        {
            if (string.IsNullOrWhiteSpace(_apiBaseUrl))
            {
                Console.Error.WriteLine("[OllamaApiClient] CheckConnection Error: API base URL is not set.");
                return false;
            }

            string healthCheckUrl = _apiBaseUrl;
            Console.WriteLine($"[OllamaApiClient] Checking Ollama connection at: {healthCheckUrl}");

            try
            {
                // Use a temporary HttpClient for a quick check with a shorter timeout
                // Or, if _httpClient is already initialized with a suitable default timeout, you could use it.
                // Creating a new one here ensures a specific short timeout for this check.
                using (var tempHttpClient = new HttpClient { Timeout = TimeSpan.FromSeconds(10) }) // Increased timeout slightly
                {
                    HttpResponseMessage response = await tempHttpClient.GetAsync(healthCheckUrl);
                    Console.WriteLine($"[OllamaApiClient] Connection check response status: {response.StatusCode}");
                    // Optional: Check response body if needed, e.g., response.Content.ReadAsStringAsync();
                    return response.IsSuccessStatusCode;
                }
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"[OllamaApiClient] Error checking Ollama connection to '{healthCheckUrl}': {ex.Message}\n{ex.StackTrace}");
                return false;
            }
        }

        /// <summary>
        /// Lists local models available on the Ollama server using the /api/tags endpoint.
        /// </summary>
        /// <returns>An OllamaListTagsResponse containing the list of models, or null if an error occurs.</returns>
        public async Task<OllamaListTagsResponse?> ListLocalModelsAsync()
        {
            if (string.IsNullOrWhiteSpace(_apiBaseUrl))
            {
                Console.Error.WriteLine("[OllamaApiClient] ListLocalModels Error: API base URL is not set.");
                return null;
            }

            string listModelsUrl = $"{_apiBaseUrl}/api/tags";
            Console.WriteLine($"[OllamaApiClient] Listing Ollama models from: {listModelsUrl}");

            try
            {
                // Use the class member _httpClient, assuming its timeout is appropriate for this call.
                // If not, you might consider adjusting _httpClient.Timeout or using a temporary client like in CheckConnectionAsync.
                HttpResponseMessage response = await _httpClient.GetAsync(listModelsUrl);
                string responseBody = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"[OllamaApiClient] ListLocalModels Response Status Code: {response.StatusCode}");

                if (response.IsSuccessStatusCode)
                {
                    OllamaListTagsResponse? listResponse = null;
                    try
                    {
                        // Ensure System.Text.Json.JsonSerializer is used. Add 'using System.Text.Json;' if missing.
                        listResponse = System.Text.Json.JsonSerializer.Deserialize<OllamaListTagsResponse>(responseBody,
                            new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                    }
                    catch (System.Text.Json.JsonException jsonEx)
                    {
                        Console.Error.WriteLine($"[OllamaApiClient] Error deserializing ListLocalModels response: {jsonEx.Message}\nBody (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                        return null;
                    }

                    if (listResponse != null)
                    {
                        Console.WriteLine($"[OllamaApiClient] Successfully fetched {listResponse.Models?.Count ?? 0} local models.");
                    }
                    else
                    {
                        Console.Error.WriteLine($"[OllamaApiClient] ListLocalModels deserialization resulted in null object. Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                    }
                    return listResponse;
                }
                else
                {
                    Console.Error.WriteLine($"[OllamaApiClient] ListLocalModels HTTP call failed. Status: {response.StatusCode}, Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                    return null;
                }
            }
            catch (Exception ex) // Catch general exceptions including HttpRequestException, TaskCanceledException (timeout)
            {
                Console.Error.WriteLine($"[OllamaApiClient] An unexpected error occurred during ListLocalModels from '{listModelsUrl}': {ex.Message}\n{ex.StackTrace}");
                return null;
            }
        }

        // Example: Log API requests and responses
        private void LogApiRequest(string endpoint, object? payload = null)
        {
            Console.WriteLine($"Ollama API Request: Endpoint: {endpoint}, Payload: {JsonSerializer.Serialize(payload, new JsonSerializerOptions { WriteIndented = true })}");
        }
        private void LogApiResponse(string endpoint, object? response = null)
        {
            Console.WriteLine($"Ollama API Response: Endpoint: {endpoint}, Response: {JsonSerializer.Serialize(response, new JsonSerializerOptions { WriteIndented = true })}");
        }
        private void LogApiError(string endpoint, Exception ex)
        {
            Console.Error.WriteLine($"Ollama API Error: Endpoint: {endpoint}, Exception: {ex.Message}\n{ex.StackTrace}");
        }

        public void Dispose()
        {
            _httpClient?.Dispose();
            GC.SuppressFinalize(this);
        }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Ollama\OllamaGenerateRequest.cs">
<![CDATA[
// DaminionOllamaInteractionLib/Ollama/OllamaGenerateRequest.cs
using System.Text.Json.Serialization; // Required for JsonPropertyName
using System.Collections.Generic;     // Required for List

namespace DaminionOllamaInteractionLib.Ollama
{
    /// <summary>
    /// Represents a request to generate text using the Ollama API.
    /// </summary>
    public class OllamaGenerateRequest
    {
        [JsonPropertyName("model")]
        public string Model { get; set; } = string.Empty;

        [JsonPropertyName("prompt")]
        public string Prompt { get; set; } = string.Empty;

        [JsonPropertyName("images")]
        public List<string>? Images { get; set; } // List of Base64 encoded images

        [JsonPropertyName("stream")]
        public bool Stream { get; set; } = false; // We want the full response, not a stream
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Ollama\OllamaGenerateResponse.cs">
<![CDATA[
// DaminionOllamaInteractionLib/Ollama/OllamaGenerateResponse.cs
using System.Text.Json.Serialization; // Required for JsonPropertyName
using System.Collections.Generic;     // Required for List

namespace DaminionOllamaInteractionLib.Ollama
{
    /// <summary>
    /// Represents the response from the Ollama API for a generation request.
    /// </summary>
    public class OllamaGenerateResponse
    {
        [JsonPropertyName("model")]
        public string Model { get; set; } = string.Empty;

        [JsonPropertyName("created_at")]
        public string CreatedAt { get; set; } = string.Empty; // ISO 8601 date string

        [JsonPropertyName("response")]
        public string Response { get; set; } = string.Empty; // This is the main content from Llava

        [JsonPropertyName("done")]
        public bool Done { get; set; }

        // Optional fields that might be present in the response
        [JsonPropertyName("total_duration")]
        public long? TotalDuration { get; set; }

        [JsonPropertyName("load_duration")]
        public long? LoadDuration { get; set; }

        [JsonPropertyName("prompt_eval_count")]
        public int? PromptEvalCount { get; set; }

        [JsonPropertyName("prompt_eval_duration")]
        public long? PromptEvalDuration { get; set; }

        [JsonPropertyName("eval_count")]
        public int? EvalCount { get; set; }

        [JsonPropertyName("eval_duration")]
        public long? EvalDuration { get; set; }

        // Context is usually a large array of numbers, you might not need to deserialize it fully
        // unless you plan to use it for follow-up requests.
        // For now, we can ignore it or deserialize as JsonElement if needed later.
        // [JsonPropertyName("context")]
        // public List<int>? Context { get; set; }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Ollama\OllamaModelInfo.cs">
<![CDATA[
// DaminionOllamaInteractionLib/Ollama/OllamaModelInfo.cs
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace DaminionOllamaInteractionLib.Ollama
{
    /// <summary>
    /// Represents the details of an Ollama model.
    /// </summary>
    public class OllamaModelDetails
    {
        [JsonPropertyName("format")]
        public string? Format { get; set; }

        [JsonPropertyName("family")]
        public string? Family { get; set; }

        [JsonPropertyName("families")]
        public List<string>? Families { get; set; }

        [JsonPropertyName("parameter_size")]
        public string? ParameterSize { get; set; }

        [JsonPropertyName("quantization_level")]
        public string? QuantizationLevel { get; set; }
    }

    /// <summary>
    /// Represents the information of an Ollama model.
    /// </summary>
    public class OllamaModelInfo
    {
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        [JsonPropertyName("model")]
        public string Model { get; set; } = string.Empty;

        [JsonPropertyName("modified_at")]
        public string ModifiedAt { get; set; } = string.Empty;

        [JsonPropertyName("size")]
        public long Size { get; set; }

        [JsonPropertyName("digest")]
        public string Digest { get; set; } = string.Empty;

        [JsonPropertyName("details")]
        public OllamaModelDetails? Details { get; set; }
    }

    /// <summary>
    /// Represents the response from the Ollama API for listing tags.
    /// </summary>
    public class OllamaListTagsResponse
    {
        [JsonPropertyName("models")]
        public List<OllamaModelInfo>? Models { get; set; }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Ollama\OllamaResponseParser.cs">
<![CDATA[
// DaminionOllamaInteractionLib/Ollama/OllamaResponseParser.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Text.Json;

namespace DaminionOllamaInteractionLib.Ollama
{
    /// <summary>
    /// Static utility class responsible for parsing responses from the Ollama AI service.
    /// This parser extracts structured metadata (categories, keywords, descriptions) 
    /// from free-form AI text responses using regex patterns.
    /// 
    /// The parser expects AI responses to follow a specific format with sections like:
    /// - Categories: [list of categories]
    /// - Keywords: [list of keywords]
    /// - Description: [descriptive text]
    /// 
    /// If the expected format is not found, the parser falls back to treating
    /// the entire response as a description.
    /// </summary>
    public static class OllamaResponseParser // Must be public and static
    {
        #region Constants
        /// <summary>
        /// Regular expression pattern for extracting categories from AI responses.
        /// Matches "Categories:" followed by content until double newline or end of string.
        /// </summary>
        private static readonly Regex CategoriesRegex = new Regex(
            @"Categories:(.*?)(\n\n|\z)", 
            RegexOptions.Singleline | RegexOptions.IgnoreCase | RegexOptions.Compiled
        );

        /// <summary>
        /// Regular expression pattern for extracting keywords from AI responses.
        /// Matches "Keywords:" followed by content until double newline or end of string.
        /// </summary>
        private static readonly Regex KeywordsRegex = new Regex(
            @"Keywords:(.*?)(\n\n|\z)", 
            RegexOptions.Singleline | RegexOptions.IgnoreCase | RegexOptions.Compiled
        );

        /// <summary>
        /// Regular expression pattern for extracting description from AI responses.
        /// Matches "Description:" followed by content until double newline or end of string.
        /// </summary>
        private static readonly Regex DescriptionRegex = new Regex(
            @"Description:(.*?)(\n\n|\z)", 
            RegexOptions.Singleline | RegexOptions.IgnoreCase | RegexOptions.Compiled
        );

        /// <summary>
        /// Characters used to split list items in categories and keywords sections.
        /// </summary>
        private static readonly char[] ListSeparators = { '\n', '-', ',' };
        #endregion

        #region Public Methods
        /// <summary>
        /// Parses the response from the Ollama AI service and extracts structured metadata.
        /// 
        /// The method attempts to extract:
        /// 1. Categories - organized classification tags
        /// 2. Keywords - searchable terms and tags
        /// 3. Description - detailed textual description
        /// 
        /// If structured sections are not found, the entire response is treated as a description.
        /// </summary>
        /// <param name="llavaResponseText">The raw text response from the Ollama AI service.</param>
        /// <returns>A ParsedOllamaContent object containing the extracted metadata.</returns>
        public static ParsedOllamaContent ParseLlavaResponse(string llavaResponseText)
        {
            var parsedContent = new ParsedOllamaContent { RawResponse = llavaResponseText };
            if (string.IsNullOrWhiteSpace(llavaResponseText))
            {
                parsedContent.Description = "Ollama returned an empty response.";
                return parsedContent;
            }

            // Try to parse as JSON and extract the text field
            string? textBlock = null;
            try
            {
                using var doc = JsonDocument.Parse(llavaResponseText);
                var root = doc.RootElement;
                if (root.TryGetProperty("candidates", out var candidates) && candidates.GetArrayLength() > 0)
                {
                    var candidate = candidates[0];
                    if (candidate.TryGetProperty("content", out var content) &&
                        content.TryGetProperty("parts", out var parts) &&
                        parts.GetArrayLength() > 0)
                    {
                        var part = parts[0];
                        if (part.TryGetProperty("text", out var textProp))
                        {
                            textBlock = textProp.GetString();
                        }
                    }
                }
            }
            catch { /* Not JSON, fallback to old logic */ }

            if (!string.IsNullOrWhiteSpace(textBlock))
            {
                // Use the extracted text for section splitting
                llavaResponseText = textBlock;
            }

            // --- Extract clean Description (first paragraph before Categories/Keywords) ---
            string description = llavaResponseText;
            int catIdx = llavaResponseText.IndexOf("Categories:", StringComparison.OrdinalIgnoreCase);
            int keyIdx = llavaResponseText.IndexOf("Keywords:", StringComparison.OrdinalIgnoreCase);
            int firstSectionIdx = -1;
            if (catIdx >= 0 && keyIdx >= 0) firstSectionIdx = Math.Min(catIdx, keyIdx);
            else if (catIdx >= 0) firstSectionIdx = catIdx;
            else if (keyIdx >= 0) firstSectionIdx = keyIdx;
            if (firstSectionIdx > 0)
                description = llavaResponseText.Substring(0, firstSectionIdx).Trim();
            var descParagraph = description.Split(new[] { "\n", "\r\n" }, StringSplitOptions.RemoveEmptyEntries).FirstOrDefault()?.Trim();
            parsedContent.Description = string.IsNullOrWhiteSpace(descParagraph) ? description.Trim() : descParagraph;

            // --- Extract Categories ---
            if (TryExtractCategories(llavaResponseText, out var categories))
                parsedContent.Categories = categories;

            // --- Extract Keywords ---
            if (TryExtractKeywords(llavaResponseText, out var keywords))
                parsedContent.Keywords = keywords;

            parsedContent.SuccessfullyParsed =
                !string.IsNullOrWhiteSpace(parsedContent.Description) ||
                (parsedContent.Categories?.Count > 0) ||
                (parsedContent.Keywords?.Count > 0);

            return parsedContent;
        }
        #endregion

        #region Private Helper Methods
        /// <summary>
        /// Attempts to extract categories from the AI response text.
        /// </summary>
        /// <param name="responseText">The full AI response text.</param>
        /// <param name="categories">Output parameter containing the extracted categories.</param>
        /// <returns>True if categories were successfully extracted, false otherwise.</returns>
        private static bool TryExtractCategories(string responseText, out List<string> categories)
        {
            categories = new List<string>();
            
            var match = CategoriesRegex.Match(responseText);
            if (!match.Success)
                return false;

            var categoriesBlock = match.Groups[1].Value.Trim();
            if (string.IsNullOrWhiteSpace(categoriesBlock))
                return false;

            // Parse the categories block into individual items
            categories = ParseListItems(categoriesBlock);
            return categories.Any();
        }

        /// <summary>
        /// Attempts to extract keywords from the AI response text.
        /// </summary>
        /// <param name="responseText">The full AI response text.</param>
        /// <param name="keywords">Output parameter containing the extracted keywords.</param>
        /// <returns>True if keywords were successfully extracted, false otherwise.</returns>
        private static bool TryExtractKeywords(string responseText, out List<string> keywords)
        {
            keywords = new List<string>();
            
            var match = KeywordsRegex.Match(responseText);
            if (!match.Success)
                return false;

            var keywordsBlock = match.Groups[1].Value.Trim();
            if (string.IsNullOrWhiteSpace(keywordsBlock))
                return false;

            // Parse the keywords block into individual items
            keywords = ParseListItems(keywordsBlock);
            return keywords.Any();
        }

        /// <summary>
        /// Attempts to extract a description from the AI response text.
        /// </summary>
        /// <param name="responseText">The full AI response text.</param>
        /// <param name="description">Output parameter containing the extracted description.</param>
        /// <returns>True if a description was successfully extracted, false otherwise.</returns>
        private static bool TryExtractDescription(string responseText, out string description)
        {
            description = string.Empty;
            
            var match = DescriptionRegex.Match(responseText);
            if (!match.Success)
                return false;

            description = match.Groups[1].Value.Trim();
            return !string.IsNullOrWhiteSpace(description);
        }

        /// <summary>
        /// Parses a block of text into individual list items.
        /// Handles various separators like newlines, dashes, and commas.
        /// </summary>
        /// <param name="listBlock">The text block containing list items.</param>
        /// <returns>A list of cleaned, non-empty items.</returns>
        private static List<string> ParseListItems(string listBlock)
        {
            return listBlock
                .Split(ListSeparators, StringSplitOptions.RemoveEmptyEntries)
                .Select(item => item.Trim())
                .Where(item => !string.IsNullOrWhiteSpace(item))
                .ToList();
        }

        /// <summary>
        /// Removes a matched section from the text using the specified regex pattern.
        /// Used to clean up the description after extracting structured sections.
        /// </summary>
        /// <param name="text">The text to process.</param>
        /// <param name="pattern">The regex pattern to match and remove.</param>
        /// <returns>The text with the matched section removed.</returns>
        private static string RemoveSection(string text, Regex pattern)
        {
            var match = pattern.Match(text);
            if (match.Success)
            {
                return text.Replace(match.Value, "").Trim();
            }
            return text;
        }
        #endregion
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Ollama\ParsedOllamaContent.cs">
<![CDATA[
// DaminionOllamaInteractionLib/Ollama/ParsedOllamaContent.cs
using System.Collections.Generic;

namespace DaminionOllamaInteractionLib.Ollama
{
    /// <summary>
    /// Represents the structured metadata extracted from an Ollama AI response.
    /// This class serves as a data container for the parsed content after processing
    /// an AI-generated response through the OllamaResponseParser.
    /// 
    /// The class contains both the extracted structured data and the original raw response
    /// for reference and debugging purposes.
    /// </summary>
    public class ParsedOllamaContent // Must be public
    {
        /// <summary>
        /// Gets or sets the descriptive text extracted from the AI response.
        /// This typically contains the main content describing the analyzed image.
        /// If structured parsing fails, this may contain the entire raw response.
        /// </summary>
        public string Description { get; set; } = string.Empty;

        /// <summary>
        /// Gets or sets the list of categories extracted from the AI response.
        /// Categories represent high-level classifications or themes identified in the content.
        /// Examples: "Nature", "Architecture", "Portrait", "Landscape".
        /// </summary>
        public List<string> Categories { get; set; } = new List<string>();

        /// <summary>
        /// Gets or sets the list of keywords extracted from the AI response.
        /// Keywords are specific terms and tags that can be used for searching and indexing.
        /// Examples: "sunset", "mountain", "blue sky", "reflection".
        /// </summary>
        public List<string> Keywords { get; set; } = new List<string>();

        /// <summary>
        /// Gets or sets the original, unprocessed response text from the AI service.
        /// This is stored for reference, debugging, and fallback purposes.
        /// Useful for troubleshooting parsing issues or when structured extraction fails.
        /// </summary>
        public string RawResponse { get; set; } = string.Empty;

        /// <summary>
        /// Gets or sets a value indicating whether the parsing operation successfully
        /// extracted structured content from the AI response.
        /// 
        /// True if at least one structured section (categories, keywords, or description)
        /// was successfully identified and parsed. False if parsing failed or only
        /// the raw response could be used as a fallback description.
        /// </summary>
        public bool SuccessfullyParsed { get; set; } = false;
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\OpenRouter\OpenRouterApiClient.cs">
<![CDATA[
// DaminionOllamaInteractionLib/OpenRouter/OpenRouterApiClient.cs
using DaminionOllamaInteractionLib.Ollama;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using Serilog;
using System.IO;
using Serilog.Sinks.File;

namespace DaminionOllamaInteractionLib.OpenRouter
{
    /// <summary>
    /// Client for interacting with the OpenRouter.ai API service.
    /// OpenRouter provides access to multiple AI models through a unified API interface.
    /// This client handles authentication, model listing, and image analysis requests.
    /// 
    /// The client supports:
    /// - Authentication with API keys
    /// - Model discovery and listing
    /// - Image analysis with various AI models
    /// - Base64 image encoding and processing
    /// </summary>
    public class OpenRouterApiClient : IDisposable
    {
        private static readonly ILogger Logger;
        static OpenRouterApiClient()
        {
            var logDir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "DaminionOllamaApp", "logs");
            Directory.CreateDirectory(logDir);
            var logPath = Path.Combine(logDir, "openrouterapiclient.log");
            Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day, retainedFileCountLimit: 7)
                .CreateLogger();
        }
        #region Private Fields
        /// <summary>
        /// HTTP client for making API requests to OpenRouter.
        /// </summary>
        private readonly HttpClient _httpClient;
        
        /// <summary>
        /// API key for authenticating with the OpenRouter service.
        /// </summary>
        private readonly string _apiKey;
        #endregion

        #region Constructor
        /// <summary>
        /// Initializes a new instance of the OpenRouterApiClient class.
        /// Sets up HTTP client with proper authentication headers and base URL.
        /// </summary>
        /// <param name="apiKey">The API key for OpenRouter authentication.</param>
        /// <param name="httpReferer">The HTTP referer header, required by OpenRouter for tracking.</param>
        /// <exception cref="ArgumentException">Thrown when the API key is null or empty.</exception>
        public OpenRouterApiClient(string apiKey, string httpReferer)
        {
            if (string.IsNullOrWhiteSpace(apiKey))
                throw new ArgumentException("OpenRouter API key cannot be empty.", nameof(apiKey));

            _apiKey = apiKey;
            _httpClient = new HttpClient();
            
            // Configure HTTP client for OpenRouter API
            _httpClient.BaseAddress = new Uri("https://openrouter.ai/api/v1/");
            _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", _apiKey);
            
            // Add HTTP referer if provided (required by OpenRouter)
            if (!string.IsNullOrWhiteSpace(httpReferer))
            {
                _httpClient.DefaultRequestHeaders.Add("HTTP-Referer", httpReferer);
            }
            
            // Set content type and timeout
            _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
            _httpClient.Timeout = TimeSpan.FromMinutes(5); // Extended timeout for AI processing

            Console.WriteLine("[OpenRouterApiClient] Initialized.");
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Retrieves the list of available AI models from the OpenRouter API.
        /// This can be used to discover which models are available for image analysis.
        /// </summary>
        /// <returns>A response object containing the list of available models, or null if the request fails.</returns>
        public async Task<OpenRouterListModelsResponse?> ListModelsAsync()
        {
            try
            {
                Console.WriteLine("[OpenRouterApiClient] Fetching available models...");
                
                var response = await _httpClient.GetAsync("models");
                
                if (response.IsSuccessStatusCode)
                {
                    var json = await response.Content.ReadAsStringAsync();
                    var result = JsonSerializer.Deserialize<OpenRouterListModelsResponse>(json);
                    
                    Console.WriteLine($"[OpenRouterApiClient] Found {result?.Data?.Count ?? 0} models.");
                    return result;
                }
                else
                {
                    var errorContent = await response.Content.ReadAsStringAsync();
                    Console.Error.WriteLine($"[OpenRouterApiClient] Failed to fetch models: {response.StatusCode} - {errorContent}");
                    return null;
                }
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"[OpenRouterApiClient] Error fetching models: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Analyzes an image using the specified AI model and prompt.
        /// Sends the image as base64 data to the OpenRouter API for processing.
        /// </summary>
        /// <param name="modelName">The name of the AI model to use for analysis (e.g., "openai/gpt-4-vision-preview").</param>
        /// <param name="prompt">The text prompt describing what analysis to perform on the image.</param>
        /// <param name="base64Image">The image data encoded as a base64 string.</param>
        /// <returns>The AI-generated analysis text, or null if the request fails.</returns>
        public async Task<OpenRouterApiResult> AnalyzeImageAsync(string modelName, string prompt, string base64Image)
        {
            var result = new OpenRouterApiResult();
            try
            {
                Console.WriteLine($"[OpenRouterApiClient] Analyzing image with model: {modelName}");
                var requestData = new
                {
                    model = modelName,
                    messages = new[]
                    {
                        new
                        {
                            role = "user",
                            content = new object[]
                            {
                                new { type = "text", text = prompt },
                                new { type = "image_url", image_url = new { url = $"data:image/jpeg;base64,{base64Image}" } }
                            }
                        }
                    }
                };
                var jsonContent = JsonSerializer.Serialize(requestData);
                var content = new StringContent(jsonContent, Encoding.UTF8, "application/json");
                result.Content = null;
                result.ErrorMessage = null;
                result.RawResponse = null;
                var response = await _httpClient.PostAsync("chat/completions", content);
                result.StatusCode = (int)response.StatusCode;
                var responseBody = await response.Content.ReadAsStringAsync();
                result.RawResponse = responseBody;
                if (response.IsSuccessStatusCode)
                {
                    var responseJson = responseBody;
                    var apiResponse = JsonSerializer.Deserialize<OpenRouterChatCompletionResponse>(responseJson);
                    var analysisResult = apiResponse?.Choices?.FirstOrDefault()?.Message?.Content;
                    result.Content = analysisResult;
                    Console.WriteLine($"[OpenRouterApiClient] Analysis completed. Length: {analysisResult?.Length ?? 0} characters");
                }
                else
                {
                    result.ErrorMessage = $"Status: {response.StatusCode} - {responseBody}";
                    Console.Error.WriteLine($"[OpenRouterApiClient] Analysis failed: {result.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                result.ErrorMessage = ex.Message;
                Console.Error.WriteLine($"[OpenRouterApiClient] Error analyzing image: {ex.Message}");
            }
            return result;
        }

        /// <summary>
        /// Analyzes an image using a multimodal model on OpenRouter (byte array version).
        /// Automatically detects the image format and converts to base64.
        /// </summary>
        /// <param name="modelName">The name of the model to use (e.g., "google/gemini-pro-vision").</param>
        /// <param name="prompt">The text prompt for the analysis.</param>
        /// <param name="imageBytes">The image bytes.</param>
        /// <returns>The content of the AI's response.</returns>
        public async Task<OpenRouterApiResult> AnalyzeImageAsync(string modelName, string prompt, byte[] imageBytes)
        {
            string base64Image = Convert.ToBase64String(imageBytes);
            return await AnalyzeImageAsync(modelName, prompt, base64Image);
        }

        /// <summary>
        /// Checks if a model supports multimodal/vision capabilities.
        /// </summary>
        /// <param name="modelName">The model name to check.</param>
        /// <returns>True if the model supports vision, false otherwise.</returns>
        public async Task<bool> IsModelMultimodalAsync(string modelName)
        {
            var modelsResponse = await ListModelsAsync();
            if (modelsResponse?.Data == null) return false;
            
            var model = modelsResponse.Data.FirstOrDefault(m => m.Id == modelName);
            if (model == null) return false;
            
            // Check if model supports vision/multimodal
            return modelName.Contains("vision") || 
                   modelName.Contains("claude-3") || 
                   modelName.Contains("gpt-4") || 
                   modelName.Contains("gemini");
        }

        /// <summary>
        /// Detects the MIME type of an image from its byte signature.
        /// </summary>
        /// <param name="imageBytes">The image bytes.</param>
        /// <returns>The MIME type string.</returns>
        private static string GetImageMimeType(byte[] imageBytes)
        {
            if (imageBytes.Length >= 4)
            {
                // PNG signature
                if (imageBytes[0] == 0x89 && imageBytes[1] == 0x50 && imageBytes[2] == 0x4E && imageBytes[3] == 0x47)
                    return "image/png";
                
                // JPEG signature
                if (imageBytes[0] == 0xFF && imageBytes[1] == 0xD8)
                    return "image/jpeg";
            }
            
            return "image/jpeg"; // Default fallback
        }
        #endregion

        #region IDisposable Implementation
        /// <summary>
        /// Disposes of the HTTP client and releases associated resources.
        /// </summary>
        public void Dispose()
        {
            _httpClient?.Dispose();
        }
        #endregion

        // Example: Log API requests and responses
        private void LogApiRequest(string endpoint, object? payload = null)
        {
            Logger.Information("OpenRouter API Request: {Endpoint}, Payload: {@Payload}", endpoint, payload);
        }
        private void LogApiResponse(string endpoint, object? response = null)
        {
            Logger.Information("OpenRouter API Response: {Endpoint}, Response: {@Response}", endpoint, response);
        }
        private void LogApiError(string endpoint, Exception ex)
        {
            Logger.Error(ex, "OpenRouter API Error: {Endpoint}", endpoint);
        }
    }

    #region Data Models
    /// <summary>
    /// Represents the response from the OpenRouter models list API endpoint.
    /// Contains the list of available AI models that can be used for processing.
    /// </summary>
    public class OpenRouterListModelsResponse
    {
        /// <summary>
        /// Gets or sets the list of available AI models.
        /// </summary>
        [JsonPropertyName("data")]
        public List<OpenRouterModel>? Data { get; set; }
    }

    /// <summary>
    /// Represents an individual AI model available through OpenRouter.
    /// Contains metadata about the model's capabilities and identification.
    /// </summary>
    public class OpenRouterModel
    {
        /// <summary>
        /// Gets or sets the unique identifier for the model (e.g., "openai/gpt-4-vision-preview").
        /// </summary>
        [JsonPropertyName("id")]
        public string? Id { get; set; }
        
        /// <summary>
        /// Gets or sets the human-readable name of the model.
        /// </summary>
        [JsonPropertyName("name")]
        public string? Name { get; set; }
    }

    /// <summary>
    /// Represents the response from the OpenRouter chat completion API endpoint.
    /// Contains the AI-generated responses and metadata about the completion.
    /// </summary>
    public class OpenRouterChatCompletionResponse
    {
        /// <summary>
        /// Gets or sets the list of choice responses from the AI model.
        /// Typically contains one choice with the generated content.
        /// </summary>
        [JsonPropertyName("choices")]
        public List<OpenRouterChoice>? Choices { get; set; }
    }

    /// <summary>
    /// Represents a single choice/response from the AI model.
    /// Contains the generated message content and metadata.
    /// </summary>
    public class OpenRouterChoice
    {
        /// <summary>
        /// Gets or sets the message content generated by the AI model.
        /// </summary>
        [JsonPropertyName("message")]
        public OpenRouterMessage? Message { get; set; }
    }

    /// <summary>
    /// Represents a message in the chat completion response.
    /// Contains the actual text content generated by the AI model.
    /// </summary>
    public class OpenRouterMessage
    {
        /// <summary>
        /// Gets or sets the text content of the AI-generated response.
        /// This contains the actual analysis results for image processing requests.
        /// </summary>
        [JsonPropertyName("content")]
        public string? Content { get; set; }
    }

    /// <summary>
    /// Represents an error response from the OpenRouter API.
    /// Used for parsing detailed error information when requests fail.
    /// </summary>
    public class OpenRouterErrorResponse
    {
        /// <summary>
        /// Gets or sets the error details from the API response.
        /// </summary>
        [JsonPropertyName("error")]
        public OpenRouterError? Error { get; set; }
    }

    /// <summary>
    /// Represents detailed error information from the OpenRouter API.
    /// Contains specific error messages and error codes.
    /// </summary>
    public class OpenRouterError
    {
        /// <summary>
        /// Gets or sets the human-readable error message.
        /// </summary>
        [JsonPropertyName("message")]
        public string? Message { get; set; }

        /// <summary>
        /// Gets or sets the error type classification.
        /// </summary>
        [JsonPropertyName("type")]
        public string? Type { get; set; }

        /// <summary>
        /// Gets or sets the specific error code.
        /// </summary>
        [JsonPropertyName("code")]
        public string? Code { get; set; }
    }

    public class OpenRouterApiResult
    {
        public string? Content { get; set; }
        public int StatusCode { get; set; }
        public string? ErrorMessage { get; set; }
        public string? RawResponse { get; set; }
    }
    #endregion
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Services\ImageMetadataEditor.cs">
<![CDATA[
using System;
using System.Collections.Generic;
using System.Linq;
using ImageMagick;
using System.Xml.Linq;

namespace DaminionOllamaInteractionLib.Services
{
    /// <summary>
    /// A class to read and write image metadata using ImageMagick.
    /// </summary>
    public class ImageMetadataEditor : IDisposable
    {
        private readonly string _filePath;
        private MagickImage? _image;
        private IExifProfile? _exifProfile;
        private IIptcProfile? _iptcProfile;
        private IXmpProfile? _xmpProfile;

        private static readonly XNamespace RdfNS = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
        private static readonly XNamespace DcNS = "http://purl.org/dc/elements/1.1/";
        private static readonly XNamespace XmpMetaNS = "adobe:ns:meta/";

        /// <summary>
        /// Initializes a new instance of the <see cref="ImageMetadataEditor"/> class.
        /// </summary>
        /// <param name="filePath"></param>
        /// <exception cref="ArgumentNullException"></exception>
        public ImageMetadataEditor(string filePath)
        {
            _filePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
        }

        /// <summary>
        /// Reads the image metadata from the specified file.
        /// </summary>
        public void Read()
        {
            _image?.Dispose();
            _image = new MagickImage(_filePath);

            _exifProfile = _image.GetExifProfile();
            _iptcProfile = _image.GetIptcProfile();
            _xmpProfile = _image.GetXmpProfile();

            PopulateMainProperties();
        }

        /// <summary>
        /// Saves the image metadata to the specified file.
        /// </summary>
        /// <exception cref="InvalidOperationException"></exception>
        public void Save()
        {
            if (_image == null)
                throw new InvalidOperationException("Image has not been read. Call Read() first.");

            UpdateMainProperties();

            if (_exifProfile is { Values.Count: > 0 })
                _image.SetProfile(_exifProfile);
            else
                _image.RemoveProfile("exif");

            if (_iptcProfile is { Values.Count: > 0 })
                _image.SetProfile(_iptcProfile);
            else
                _image.RemoveProfile("iptc");

            if (_xmpProfile != null)
            {
                var xdoc = TryGetXmpDocument(_xmpProfile);
                var rdfDesc = xdoc?.Root?.Element(RdfNS + "RDF")?.Element(RdfNS + "Description");

                bool hasContent = rdfDesc?.Elements().Any(el =>
                    el.Name.Namespace != XmpMetaNS &&
                    el.Name.Namespace != RdfNS &&
                    !el.Name.LocalName.StartsWith("xmlns", StringComparison.Ordinal)) ?? false;

                if (hasContent)
                    _image.SetProfile(_xmpProfile);
                else
                    _image.RemoveProfile("xmp");
            }

            _image.Write(_filePath);
        }

        public string? Description { get; set; } 
        public List<string> Keywords { get; set; } = new();
        public List<string> Categories { get; set; } = new();
        public string? ExifImageDescription { get; set; }

        /// <summary>
        /// Populates the main properties of the image metadata.
        /// </summary>
        private void PopulateMainProperties()
        {
            Description = GetXmpSimpleString(DcNS + "description")
                          ?? GetIptcSingleValue(IptcTag.Caption)
                          ?? GetExifStringValue(ExifTag.ImageDescription);

            ExifImageDescription = GetExifStringValue(ExifTag.ImageDescription);

            Keywords = GetIptcMultipleValues(IptcTag.Keyword)
                .Concat(GetXmpBag(DcNS + "subject"))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .ToList();

            Categories = GetXmpBag(DcNS + "type");
        }

        /// <summary>
        /// Updates the main properties of the image metadata.
        /// </summary>
        private void UpdateMainProperties()
        {
            SetXmpSimpleString(DcNS + "description", Description);
            SetIptcSingleValue(IptcTag.Caption, Description);
            SetExifStringValue(ExifTag.ImageDescription, ExifImageDescription);
            SetIptcMultipleValues(IptcTag.Keyword, Keywords);
            SetXmpBag(DcNS + "subject", Keywords);
            SetXmpBag(DcNS + "type", Categories);
        }

        /// <summary>
        ///     Gets the string value of the specified EXIF tag.
        /// </summary>
        /// <param name="tagIdentifier"></param>
        /// <returns></returns>
        private string? GetExifStringValue(ExifTag tagIdentifier)
        {
            if (_exifProfile == null) return null;

            if (tagIdentifier == ExifTag.ImageDescription)
                return _exifProfile.GetValue(ExifTag<string>.ImageDescription)?.Value;

            Console.WriteLine($"EXIF tag {tagIdentifier} not supported.");
            return null;
        }

        /// <summary>
        ///    Sets the string value of the specified EXIF tag.
        /// </summary>
        /// <param name="tagIdentifier"></param>
        /// <param name="value"></param>
        private void SetExifStringValue(ExifTag tagIdentifier, string? value)
        {
            if (tagIdentifier != ExifTag.ImageDescription) return;

            _exifProfile ??= new ExifProfile();

            if (string.IsNullOrEmpty(value))
                _exifProfile.RemoveValue(ExifTag<string>.ImageDescription);
            else
                _exifProfile.SetValue(ExifTag<string>.ImageDescription, value);
        }

        /// <summary>
        ///   Gets the single value of the specified IPTC tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <returns></returns>
        private string? GetIptcSingleValue(IptcTag tag)
        {
            return _iptcProfile?.Values.FirstOrDefault(v => v.Tag == tag)?.Value;
        }

        /// <summary>
        ///     Gets the multiple values of the specified IPTC tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <returns></returns>
        private List<string> GetIptcMultipleValues(IptcTag tag)
        {
            return _iptcProfile?.Values
                       .Where(v => v.Tag == tag && !string.IsNullOrEmpty(v.Value))
                       .Select(v => v.Value)
                       .ToList() ?? new List<string>();
        }

        /// <summary>
        ///   Sets the single value of the specified IPTC tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="value"></param>
        private void SetIptcSingleValue(IptcTag tag, string? value)
        {
            if (string.IsNullOrEmpty(value)) return;

            _iptcProfile ??= new IptcProfile();
            _iptcProfile.RemoveValue(tag);
            _iptcProfile.SetValue(tag, value);
        }

        /// <summary>
        ///     Sets the multiple values of the specified IPTC tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="values"></param>
        private void SetIptcMultipleValues(IptcTag tag, List<string> values)
        {
            if (values == null || values.All(string.IsNullOrWhiteSpace)) return;

            _iptcProfile ??= new IptcProfile();
            _iptcProfile.RemoveValue(tag);

            foreach (var val in values.Where(s => !string.IsNullOrWhiteSpace(s)))
                _iptcProfile.SetValue(tag, val);
        }

        /// <summary>
        ///     Attempts to get the XMP document from the profile.
        /// </summary>
        /// <param name="profile"></param>
        /// <returns></returns>
        private XDocument? TryGetXmpDocument(IXmpProfile? profile)
        {
            try { return profile?.ToXDocument(); }
            catch (Exception ex) { Console.WriteLine($"Failed to parse XMP: {ex.Message}"); return null; }
        }

        /// <summary>
        ///    Attempts to get or create an XMP document.
        /// </summary>
        /// <returns></returns>
        private XDocument GetOrCreateXmpDocument()
        {
            var xdoc = TryGetXmpDocument(_xmpProfile);
            if (xdoc != null) return xdoc;

            var newDoc = new XDocument(
                new XElement(XmpMetaNS + "xmpmeta",
                    new XAttribute(XNamespace.Xmlns + "x", XmpMetaNS.NamespaceName),
                    new XElement(RdfNS + "RDF",
                        new XAttribute(XNamespace.Xmlns + "rdf", RdfNS.NamespaceName),
                        new XElement(RdfNS + "Description",
                            new XAttribute(RdfNS + "about", ""),
                            new XAttribute(XNamespace.Xmlns + "dc", DcNS.NamespaceName)))));

            try { _xmpProfile = XmpProfile.FromXDocument(newDoc); }
            catch (Exception ex) { Console.WriteLine($"Failed to create XMP profile: {ex.Message}"); }

            return newDoc;
        }

        /// <summary>
        ///    Updates the XMP profile from the given XDocument.
        /// </summary>
        /// <param name="xdoc"></param>
        private void UpdateXmpProfileFromDocument(XDocument xdoc)
        {
            try { _xmpProfile = XmpProfile.FromXDocument(xdoc); }
            catch (Exception ex) { Console.WriteLine($"Failed to update XMP profile: {ex.Message}"); }
        }

        /// <summary>
        ///   Gets or creates the RDF description element in the XMP document.
        /// </summary>
        /// <param name="xdoc"></param>
        /// <returns></returns>
        private static XElement GetOrCreateRdfDescription(XDocument xdoc)
        {
            var root = xdoc.Root ?? new XElement(XmpMetaNS + "xmpmeta");
            if (xdoc.Root == null) xdoc.Add(root);

            var rdf = root.Element(RdfNS + "RDF") ?? new XElement(RdfNS + "RDF");
            if (root.Element(RdfNS + "RDF") == null) root.Add(rdf);

            var desc = rdf.Element(RdfNS + "Description") ?? new XElement(RdfNS + "Description");
            if (rdf.Element(RdfNS + "Description") == null) rdf.Add(desc);

            if (desc.Attribute(XNamespace.Xmlns + "dc") == null)
                desc.SetAttributeValue(XNamespace.Xmlns + "dc", DcNS.NamespaceName);

            return desc;
        }

        /// <summary>
        ///    Gets the simple string value of the specified XMP tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <returns></returns>
        private string? GetXmpSimpleString(XName tag)
        {
            var xdoc = TryGetXmpDocument(_xmpProfile ?? _image?.GetXmpProfile());
            if (xdoc == null) return null;

            var rdf = xdoc.Root?.Element(RdfNS + "RDF")?.Element(RdfNS + "Description");
            var element = rdf?.Element(tag);

            if (element != null) return element.Value;

            if (tag == DcNS + "description")
                return rdf?.Element(tag)?.Element(RdfNS + "Alt")?.Elements(RdfNS + "li")
                    .FirstOrDefault(li => (string?)li.Attribute(XNamespace.Xml + "lang") == "x-default")?.Value;

            return null;
        }

        /// <summary>
        ///     Sets the simple string value of the specified XMP tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="value"></param>
        private void SetXmpSimpleString(XName tag, string? value)
        {
            var xdoc = GetOrCreateXmpDocument();
            var desc = GetOrCreateRdfDescription(xdoc);

            desc.Element(tag)?.Remove();

            if (!string.IsNullOrEmpty(value))
            {
                if (tag == DcNS + "description")
                {
                    desc.Add(new XElement(tag,
                        new XElement(RdfNS + "Alt",
                            new XElement(RdfNS + "li", value, new XAttribute(XNamespace.Xml + "lang", "x-default")))));
                }
                else
                {
                    desc.Add(new XElement(tag, value));
                }
            }

            UpdateXmpProfileFromDocument(xdoc);
        }

        /// <summary>
        ///   Gets the bag of values for the specified XMP tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <returns></returns>
        private List<string> GetXmpBag(XName tag)
        {
            var xdoc = TryGetXmpDocument(_xmpProfile ?? _image?.GetXmpProfile());
            var bag = xdoc?.Root?.Element(RdfNS + "RDF")?.Element(RdfNS + "Description")?.Element(tag)?.Element(RdfNS + "Bag");

            return bag?.Elements(RdfNS + "li").Select(li => li.Value).ToList() ?? new List<string>();
        }

        /// <summary>
        ///   Sets the bag of values for the specified XMP tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="values"></param>
        private void SetXmpBag(XName tag, List<string> values)
        {
            if (values == null || values.All(string.IsNullOrWhiteSpace)) return;

            var xdoc = GetOrCreateXmpDocument();
            var desc = GetOrCreateRdfDescription(xdoc);
            desc.Element(tag)?.Remove();

            var bag = new XElement(RdfNS + "Bag");
            foreach (var val in values.Where(s => !string.IsNullOrWhiteSpace(s)))
                bag.Add(new XElement(RdfNS + "li", val));

            desc.Add(new XElement(tag, bag));
            UpdateXmpProfileFromDocument(xdoc);
        }

        private bool _disposed;
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        /// <summary>
        ///   Disposes the image and releases resources.
        /// </summary>
        /// <param name="disposing"></param>
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed && disposing)
                _image?.Dispose();
            _disposed = true;
        }
        ~ImageMetadataEditor() => Dispose(false);
    }
}

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Services\ImageMetadataService.cs">
<![CDATA[
// DaminionOllamaWpfApp/Services/ImageMetadataService.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ImageMagick;
using System.Xml.Linq;
using DaminionOllamaInteractionLib.Ollama;

namespace DaminionOllamaInteractionLib.Services
{
    /// <summary>
    /// Service for reading and writing image metadata using ImageMagick.
    /// </summary>
    public class ImageMetadataService : IDisposable
    {
        private readonly string _filePath;
        private MagickImage? _image;
        private IExifProfile? _exifProfile;
        private IIptcProfile? _iptcProfile;
        private IXmpProfile? _xmpProfile;

        private static readonly XNamespace RdfNS = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
        private static readonly XNamespace DcNS = "http://purl.org/dc/elements/1.1/";
        private static readonly XNamespace XmpMetaNS = "adobe:ns:meta/";

        public string? Description { get; set; }
        public List<string> Keywords { get; set; } = new();
        public List<string> Categories { get; set; } = new();
        public string? ExifImageDescription { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ImageMetadataService"/> class.
        /// </summary>
        /// <param name="filePath"></param>
        /// <exception cref="ArgumentNullException"></exception>
        public ImageMetadataService(string filePath)
        {
            _filePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
        }

        /// <summary>
        /// Reads the image metadata from the specified file.
        /// </summary>
        public void Read()
        {
            _image?.Dispose();
            _image = new MagickImage(_filePath);

            _exifProfile = _image.GetExifProfile();
            _iptcProfile = _image.GetIptcProfile();
            _xmpProfile = _image.GetXmpProfile();

            PopulateMainProperties();
        }

        /// <summary>
        /// Saves the image metadata to the specified file.
        /// </summary>
        /// <exception cref="InvalidOperationException"></exception>
        public void Save()
        {
            if (_image == null)
                throw new InvalidOperationException("Image has not been read. Call Read() first.");

            UpdateMainProperties();

            if (_exifProfile is { Values.Count: > 0 })
                _image.SetProfile(_exifProfile);
            else
                _image.RemoveProfile("exif");

            if (_iptcProfile is { Values.Count: > 0 })
                _image.SetProfile(_iptcProfile);
            else
                _image.RemoveProfile("iptc");

            if (_xmpProfile != null)
            {
                var xdoc = TryGetXmpDocument(_xmpProfile);
                var rdfDesc = xdoc?.Root?.Element(RdfNS + "RDF")?.Element(RdfNS + "Description");

                bool hasContent = rdfDesc?.Elements().Any(el =>
                    el.Name.Namespace != XmpMetaNS &&
                    el.Name.Namespace != RdfNS &&
                    !el.Name.LocalName.StartsWith("xmlns", StringComparison.Ordinal)) ?? false;

                if (hasContent)
                    _image.SetProfile(_xmpProfile);
                else
                    _image.RemoveProfile("xmp");
            }

            _image.Write(_filePath);
        }

        /// <summary>
        /// Populates the metadata properties from the parsed Ollama content.
        /// </summary>
        /// <param name="content"></param>
        public void PopulateFromOllamaContent(ParsedOllamaContent content)
        {
            Description = content.Description;
            Keywords = new List<string>(content.Keywords);
            Categories = new List<string>(content.Categories);
            ExifImageDescription = content.Description;
        }

        /// <summary>
        /// Populates the main properties from the XMP, IPTC, and EXIF profiles.
        /// </summary>
        private void PopulateMainProperties()
        {
            Description = GetXmpSimpleString(DcNS + "description")
                          ?? GetIptcSingleValue(IptcTag.Caption)
                          ?? GetExifStringValue(ExifTag.ImageDescription);

            ExifImageDescription = GetExifStringValue(ExifTag.ImageDescription);

            Keywords = GetIptcMultipleValues(IptcTag.Keyword)
                .Concat(GetXmpBag(DcNS + "subject"))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .ToList();

            Categories = GetXmpBag(DcNS + "type");
        }

        /// <summary>
        /// Updates the main properties in the XMP, IPTC, and EXIF profiles.
        /// </summary>
        private void UpdateMainProperties()
        {
            SetXmpSimpleString(DcNS + "description", Description);
            SetIptcSingleValue(IptcTag.Caption, Description);
            SetExifStringValue(ExifTag.ImageDescription, ExifImageDescription);
            SetIptcMultipleValues(IptcTag.Keyword, Keywords);
            SetXmpBag(DcNS + "subject", Keywords);
            SetXmpBag(DcNS + "type", Categories);
        }

        /// <summary>
        /// Gets the EXIF string value for the specified tag identifier.
        /// </summary>
        /// <param name="tagIdentifier"></param>
        /// <returns></returns>
        private string? GetExifStringValue(ExifTag tagIdentifier)
        {
            if (_exifProfile == null) return null;

            if (tagIdentifier == ExifTag.ImageDescription)
                return _exifProfile.GetValue(ExifTag<string>.ImageDescription)?.Value;

            return null;
        }

        /// <summary>
        /// Sets the EXIF string value for the specified tag identifier.
        /// </summary>
        /// <param name="tagIdentifier"></param>
        /// <param name="value"></param>
        private void SetExifStringValue(ExifTag tagIdentifier, string? value)
        {
            if (tagIdentifier != ExifTag.ImageDescription) return;

            _exifProfile ??= new ExifProfile();

            if (string.IsNullOrEmpty(value))
                _exifProfile.RemoveValue(ExifTag<string>.ImageDescription);
            else
                _exifProfile.SetValue(ExifTag<string>.ImageDescription, value);
        }

        /// <summary>
        /// Gets the IPTC single value for the specified tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <returns></returns>
        private string? GetIptcSingleValue(IptcTag tag)
        {
            return _iptcProfile?.Values.FirstOrDefault(v => v.Tag == tag)?.Value;
        }

        /// <summary>
        ///     Gets the IPTC multiple values for the specified tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <returns></returns>
        private List<string> GetIptcMultipleValues(IptcTag tag)
        {
            return _iptcProfile?.Values
                       .Where(v => v.Tag == tag && !string.IsNullOrEmpty(v.Value))
                       .Select(v => v.Value)
                       .ToList() ?? new List<string>();
        }

        /// <summary>
        /// Sets the IPTC single value for the specified tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="value"></param>
        private void SetIptcSingleValue(IptcTag tag, string? value)
        {
            if (string.IsNullOrEmpty(value)) return;

            _iptcProfile ??= new IptcProfile();
            _iptcProfile.RemoveValue(tag);
            _iptcProfile.SetValue(tag, value);
        }

        /// <summary>
        /// Sets the IPTC multiple values for the specified tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="values"></param>
        private void SetIptcMultipleValues(IptcTag tag, List<string> values)
        {
            if (values == null || values.All(string.IsNullOrWhiteSpace)) return;

            _iptcProfile ??= new IptcProfile();
            _iptcProfile.RemoveValue(tag);

            foreach (var val in values.Where(s => !string.IsNullOrWhiteSpace(s)))
                _iptcProfile.SetValue(tag, val);
        }

        /// <summary>
        ///     Tries to get the XMP document from the profile.
        /// </summary>
        /// <param name="profile"></param>
        /// <returns></returns>
        private XDocument? TryGetXmpDocument(IXmpProfile? profile)
        {
            try { return profile?.ToXDocument(); }
            catch (Exception ex) { Console.WriteLine($"Failed to parse XMP: {ex.Message}"); return null; }
        }

        /// <summary>
        /// Creates a new XMP document if it doesn't exist.
        /// </summary>
        /// <returns></returns>
        private XDocument GetOrCreateXmpDocument()
        {
            var xdoc = TryGetXmpDocument(_xmpProfile);
            if (xdoc != null) return xdoc;

            var newDoc = new XDocument(
                new XElement(XmpMetaNS + "xmpmeta",
                    new XAttribute(XNamespace.Xmlns + "x", XmpMetaNS.NamespaceName),
                    new XElement(RdfNS + "RDF",
                        new XAttribute(XNamespace.Xmlns + "rdf", RdfNS.NamespaceName),
                        new XElement(RdfNS + "Description",
                            new XAttribute(RdfNS + "about", ""),
                            new XAttribute(XNamespace.Xmlns + "dc", DcNS.NamespaceName)))));

            try { _xmpProfile = XmpProfile.FromXDocument(newDoc); }
            catch (Exception ex) { Console.WriteLine($"Failed to create XMP profile: {ex.Message}"); }

            return newDoc;
        }

        /// <summary>
        /// Updates the XMP profile from the XDocument.
        /// </summary>
        /// <param name="xdoc"></param>
        private void UpdateXmpProfileFromDocument(XDocument xdoc)
        {
            try { _xmpProfile = XmpProfile.FromXDocument(xdoc); }
            catch (Exception ex) { Console.WriteLine($"Failed to update XMP profile: {ex.Message}"); }
        }

        /// <summary>
        /// Gets or creates the RDF description element in the XMP document.
        /// </summary>
        /// <param name="xdoc"></param>
        /// <returns></returns>
        private static XElement GetOrCreateRdfDescription(XDocument xdoc)
        {
            var root = xdoc.Root ?? new XElement(XmpMetaNS + "xmpmeta");
            if (xdoc.Root == null) xdoc.Add(root);

            var rdf = root.Element(RdfNS + "RDF") ?? new XElement(RdfNS + "RDF");
            if (root.Element(RdfNS + "RDF") == null) root.Add(rdf);

            var desc = rdf.Element(RdfNS + "Description") ?? new XElement(RdfNS + "Description");
            if (rdf.Element(RdfNS + "Description") == null) rdf.Add(desc);

            if (desc.Attribute(XNamespace.Xmlns + "dc") == null)
                desc.SetAttributeValue(XNamespace.Xmlns + "dc", DcNS.NamespaceName);

            return desc;
        }

        /// <summary>
        /// Gets the XMP simple string value for the specified tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <returns></returns>
        private string? GetXmpSimpleString(XName tag)
        {
            var xdoc = TryGetXmpDocument(_xmpProfile ?? _image?.GetXmpProfile());
            if (xdoc == null) return null;

            var rdf = xdoc.Root?.Element(RdfNS + "RDF")?.Element(RdfNS + "Description");
            var element = rdf?.Element(tag);

            if (element != null) return element.Value;

            if (tag == DcNS + "description")
                return rdf?.Element(tag)?.Element(RdfNS + "Alt")?.Elements(RdfNS + "li")
                    .FirstOrDefault(li => (string?)li.Attribute(XNamespace.Xml + "lang") == "x-default")?.Value;

            return null;
        }

        /// <summary>
        /// Sets the XMP simple string value for the specified tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="value"></param>
        private void SetXmpSimpleString(XName tag, string? value)
        {
            var xdoc = GetOrCreateXmpDocument();
            var desc = GetOrCreateRdfDescription(xdoc);

            desc.Element(tag)?.Remove();

            if (!string.IsNullOrEmpty(value))
            {
                if (tag == DcNS + "description")
                {
                    desc.Add(new XElement(tag,
                        new XElement(RdfNS + "Alt",
                            new XElement(RdfNS + "li", value, new XAttribute(XNamespace.Xml + "lang", "x-default")))));
                }
                else
                {
                    desc.Add(new XElement(tag, value));
                }
            }

            UpdateXmpProfileFromDocument(xdoc);
        }

        /// <summary>
        /// Gets the XMP bag (multiple values) for the specified tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <returns></returns>
        private List<string> GetXmpBag(XName tag)
        {
            var xdoc = TryGetXmpDocument(_xmpProfile ?? _image?.GetXmpProfile());
            var bag = xdoc?.Root?.Element(RdfNS + "RDF")?.Element(RdfNS + "Description")?.Element(tag)?.Element(RdfNS + "Bag");

            return bag?.Elements(RdfNS + "li").Select(li => li.Value).ToList() ?? new List<string>();
        }

        /// <summary>
        /// Sets the XMP bag (multiple values) for the specified tag.
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="values"></param>
        private void SetXmpBag(XName tag, List<string> values)
        {
            if (values == null || values.All(string.IsNullOrWhiteSpace)) return;

            var xdoc = GetOrCreateXmpDocument();
            var desc = GetOrCreateRdfDescription(xdoc);
            desc.Element(tag)?.Remove();

            var bag = new XElement(RdfNS + "Bag");
            foreach (var val in values.Where(s => !string.IsNullOrWhiteSpace(s)))
                bag.Add(new XElement(RdfNS + "li", val));

            desc.Add(new XElement(tag, bag));
            UpdateXmpProfileFromDocument(xdoc);
        }

        private bool _disposed;
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed && disposing)
                _image?.Dispose();
            _disposed = true;
        }
        ~ImageMetadataService() => Dispose(false);
    }
}

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\Services\ImageMetadataWriter.cs">
<![CDATA[
// DaminionOllamaWpfApp/Services/ImageMetadataWriter.cs
using ImageMagick;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
// using System.Xml.Linq; // We'll simplify XMP and might not need direct XDocument manipulation for now
using DaminionOllamaInteractionLib.Ollama;

namespace DaminionOllamaInteractionLib.Services
{
    /// <summary>
    /// Handles writing metadata to images using ImageMagick.
    /// </summary>
    public static class ImageMetadataWriter
    {
        /// <summary>
        /// Writes metadata to an image file.
        /// </summary>
        /// <param name="imagePath"></param>
        /// <param name="ollamaContent"></param>
        /// <returns></returns>
        public static bool WriteMetadataToImage(string imagePath, ParsedOllamaContent ollamaContent)
        {
            if (string.IsNullOrEmpty(imagePath) || !File.Exists(imagePath) || ollamaContent == null)
            {
                Console.Error.WriteLine("[ImageMetadataWriter] Error: Invalid image path or Ollama content.");
                return false;
            }

            try
            {
                Console.WriteLine($"[ImageMetadataWriter] Attempting to write metadata to: {imagePath}");

                using (MagickImage image = new MagickImage(imagePath))
                {
                    bool changesMadeToImage = false;

                    // --- IPTC Profile ---
                    IIptcProfile? iptcProfile = image.GetIptcProfile(); // Gets existing or returns null
                    bool iptcProfileWasNewlyCreated = false;

                    // Create a new profile only if there's actual content to write and no profile exists
                    if (iptcProfile == null &&
                        (!string.IsNullOrWhiteSpace(ollamaContent.Description) || ollamaContent.Keywords.Any() || ollamaContent.Categories.Any()))
                    {
                        Console.WriteLine("[ImageMetadataWriter] No IPTC profile found, creating a new one.");
                        iptcProfile = new IptcProfile();
                        iptcProfileWasNewlyCreated = true;
                    }

                    if (iptcProfile != null)
                    {
                        bool currentIptcProfileChanged = false;
                        if (!string.IsNullOrWhiteSpace(ollamaContent.Description))
                        {
                            iptcProfile.SetValue(IptcTag.Caption, ollamaContent.Description);
                            Console.WriteLine($"[ImageMetadataWriter] Set IPTC Caption.");
                            currentIptcProfileChanged = true;
                        }

                        if (ollamaContent.Keywords.Any())
                        {
                            iptcProfile.RemoveValue(IptcTag.Keyword);
                            foreach (string keyword in ollamaContent.Keywords.Where(k => !string.IsNullOrWhiteSpace(k)))
                            {
                                iptcProfile.SetValue(IptcTag.Keyword, keyword);
                            }
                            Console.WriteLine($"[ImageMetadataWriter] Set IPTC Keywords.");
                            currentIptcProfileChanged = true;
                        }

                        if (ollamaContent.Categories.Any())
                        {
                            iptcProfile.RemoveValue(IptcTag.Category);
                            foreach (string category in ollamaContent.Categories.Where(c => !string.IsNullOrWhiteSpace(c)))
                            {
                                iptcProfile.SetValue(IptcTag.Category, category);
                            }
                            Console.WriteLine($"[ImageMetadataWriter] Set IPTC Categories.");
                            currentIptcProfileChanged = true;
                        }

                        if (currentIptcProfileChanged || iptcProfileWasNewlyCreated)
                        {
                            image.SetProfile(iptcProfile);
                            changesMadeToImage = true;
                        }
                    }

                    // --- Simplified XMP Profile Handling ---
                    // We will only try to add a new XMP profile with a description if one doesn't exist
                    // and if there's a description to add.
                    // Modifying existing complex XMP is deferred.
                    if (!string.IsNullOrWhiteSpace(ollamaContent.Description))
                    {
                        IXmpProfile? xmpProfile = image.GetXmpProfile();
                        if (xmpProfile == null)
                        {
                            Console.WriteLine("[ImageMetadataWriter] No XMP profile found. Attempting to create a new one for description.");
                            // Create a minimal XMP packet string that includes dc:description
                            // Ensure namespaces are correctly defined and used.
                            string minimalXmpPacket = $@"<?xpacket begin="""" id=""W5M0MpCehiHzreSzNTczkc9d""?>
<x:xmpmeta xmlns:x=""adobe:ns:meta/"" x:xmptk=""ImageMagick"">
  <rdf:RDF xmlns:rdf=""http://www.w3.org/1999/02/22-rdf-syntax-ns#"">
    <rdf:Description rdf:about="""" xmlns:dc=""http://purl.org/dc/elements/1.1/"">
      <dc:description>
        <rdf:Alt>
          <rdf:li xml:lang=""x-default"">{System.Security.SecurityElement.Escape(ollamaContent.Description)}</rdf:li>
        </rdf:Alt>
      </dc:description>
    </rdf:Description>
  </rdf:RDF>
</x:xmpmeta>
<?xpacket end=""w""?>";
                            try
                            {
                                xmpProfile = new XmpProfile(minimalXmpPacket); // Create from string
                                image.SetProfile(xmpProfile); // Use SetProfile to add it
                                changesMadeToImage = true;
                                Console.WriteLine("[ImageMetadataWriter] Added new XMP profile with dc:description.");
                            }
                            catch (Exception ex)
                            {
                                Console.Error.WriteLine($"[ImageMetadataWriter] Error creating or setting new XMP profile: {ex.Message}");
                            }
                        }
                        else
                        {
                            Console.WriteLine("[ImageMetadataWriter] Existing XMP profile found. Advanced modification of existing XMP is not implemented in this simplified version.");
                            // If you wanted to *modify* existing XMP, you would use:
                            // byte[]? xmpData = xmpProfile.ToByteArray(); // Corrected from GetData()
                            // if (xmpData != null) { /* Parse with XDocument, modify, create new XmpProfile(modifiedBytes), image.SetProfile() */ }
                        }
                    }


                    if (changesMadeToImage)
                    {
                        Console.WriteLine($"[ImageMetadataWriter] Writing changes to {imagePath}");
                        image.Write(imagePath);
                        Console.WriteLine($"[ImageMetadataWriter] Successfully wrote metadata changes to {imagePath}");
                        return true;
                    }
                    else
                    {
                        Console.WriteLine($"[ImageMetadataWriter] No new metadata changes to write to {imagePath}");
                        return true;
                    }
                }
            }
            catch (MagickException magickEx)
            {
                Console.Error.WriteLine($"[ImageMetadataWriter] Magick.NET error writing metadata to {imagePath}: {magickEx.Message}\n{magickEx.StackTrace}");
                return false;
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"[ImageMetadataWriter] General error writing metadata to {imagePath}: {ex.Message}\n{ex.StackTrace}");
                return false;
            }
        }
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\DaminionApiClient.cs">
<![CDATA[
// DaminionOllamaInteractionLib/DaminionApiClient.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json; // Required for JsonSerializer and JsonException
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using DaminionOllamaInteractionLib.Daminion;
using DaminionOllamaInteractionLib.Ollama; // For Daminion DTOs
using Serilog;
using System.IO;
using Serilog.Sinks.File;

namespace DaminionOllamaInteractionLib
{
    /// <summary>
    /// Represents a client for interacting with the Daminion API.
    /// </summary>
    public class DaminionApiClient : IDisposable
    {
        private static readonly ILogger Logger;
        static DaminionApiClient()
        {
            var logDir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "DaminionOllamaApp", "logs");
            Directory.CreateDirectory(logDir);
            var logPath = Path.Combine(logDir, "daminionapiclient.log");
            Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(logPath, rollingInterval: RollingInterval.Day, retainedFileCountLimit: 7)
                .CreateLogger();
        }

        private readonly HttpClient _httpClient;
        private string? _apiBaseUrl;
        private string? _authenticationCookie;

        /// <summary>
        /// Initializes a new instance of the <see cref="DaminionApiClient"/> class.
        /// </summary>
        public DaminionApiClient()
        {
            _httpClient = new HttpClient();
            _httpClient.Timeout = TimeSpan.FromSeconds(60);
            Console.WriteLine("[DaminionApiClient] Initialized.");
        }

        /// <summary>
        /// Checks if the Ollama server is running and reachable.
        /// </summary>
        /// <returns>True if the server responds positively, false otherwise.</returns>
        public async Task<bool> CheckConnectionAsync()
        {
            if (string.IsNullOrWhiteSpace(_apiBaseUrl))
            {
                Console.Error.WriteLine("[OllamaApiClient] CheckConnection Error: API base URL is not set.");
                return false;
            }

            // Ollama's root endpoint typically returns "Ollama is running" with a 200 OK.
            string healthCheckUrl = _apiBaseUrl; // Or a specific health check endpoint like /api/ps or similar if available
            Console.WriteLine($"[OllamaApiClient] Checking Ollama connection at: {healthCheckUrl}");

            try
            {
                // Use a shorter timeout for a simple connection check
                using (var tempHttpClient = new HttpClient { Timeout = TimeSpan.FromSeconds(5) })
                {
                    HttpResponseMessage response = await tempHttpClient.GetAsync(healthCheckUrl);
                    Console.WriteLine($"[OllamaApiClient] Connection check response status: {response.StatusCode}");
                    //string responseBody = await response.Content.ReadAsStringAsync();
                    //Console.WriteLine($"[OllamaApiClient] Connection check response body: {responseBody}");
                    return response.IsSuccessStatusCode; // Or check for specific content if needed
                }
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"[OllamaApiClient] Error checking Ollama connection: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Lists local models available on the Ollama server using the /api/tags endpoint.
        /// </summary>
        /// <returns>An OllamaListTagsResponse containing the list of models, or null if an error occurs.</returns>
        public async Task<OllamaListTagsResponse?> ListLocalModelsAsync()
        {
            if (string.IsNullOrWhiteSpace(_apiBaseUrl))
            {
                Console.Error.WriteLine("[OllamaApiClient] ListLocalModels Error: API base URL is not set.");
                return null;
            }

            string listModelsUrl = $"{_apiBaseUrl}/api/tags";
            Console.WriteLine($"[OllamaApiClient] Listing Ollama models from: {listModelsUrl}");

            try
            {
                // _httpClient is the class member HttpClient, already configured
                HttpResponseMessage response = await _httpClient.GetAsync(listModelsUrl);
                string responseBody = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"[OllamaApiClient] ListLocalModels Response Status Code: {response.StatusCode}");

                if (response.IsSuccessStatusCode)
                {
                    OllamaListTagsResponse? listResponse = null;
                    try
                    {
                        listResponse = JsonSerializer.Deserialize<OllamaListTagsResponse>(responseBody,
                            new JsonSerializerOptions { PropertyNameCaseInsensitive = true }); // Ollama sometimes uses snake_case
                    }
                    catch (JsonException jsonEx)
                    {
                        Console.Error.WriteLine($"[OllamaApiClient] Error deserializing ListLocalModels response: {jsonEx.Message}. Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                        return null; // Or a response object indicating failure
                    }

                    if (listResponse != null)
                    {
                        Console.WriteLine($"[OllamaApiClient] Successfully fetched {listResponse.Models?.Count ?? 0} local models.");
                    }
                    else
                    {
                        Console.Error.WriteLine($"[OllamaApiClient] ListLocalModels deserialization resulted in null object. Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                    }
                    return listResponse;
                }
                else
                {
                    Console.Error.WriteLine($"[OllamaApiClient] ListLocalModels HTTP call failed. Status: {response.StatusCode}, Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                    return null; // Or a response object indicating failure
                }
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"[OllamaApiClient] An unexpected error occurred during ListLocalModels: {ex.Message}");
                return null; // Or a response object indicating failure
            }
        }

        public bool IsAuthenticated => !string.IsNullOrEmpty(_authenticationCookie);

        public async Task<bool> LoginAsync(string daminionServerUrl, string username, string password)
        {
            Console.WriteLine("[DaminionApiClient] Attempting LoginAsync...");

            if (string.IsNullOrWhiteSpace(daminionServerUrl))
            {
                Console.Error.WriteLine("[DaminionApiClient] Login Error: Daminion server URL cannot be empty.");
                throw new ArgumentException("Daminion server URL cannot be empty.", nameof(daminionServerUrl));
            }
            if (string.IsNullOrWhiteSpace(username))
            {
                Console.Error.WriteLine("[DaminionApiClient] Login Error: Username cannot be empty.");
                throw new ArgumentException("Username cannot be empty.", nameof(username));
            }
            // Password can be empty if Daminion allows it.

            _apiBaseUrl = daminionServerUrl.TrimEnd('/');
            string loginUrl = $"{_apiBaseUrl}/account/login";
            Console.WriteLine($"[DaminionApiClient] Login URL: {loginUrl}");

            var loginRequest = new LoginRequest { UsernameOrEmailAddress = username, Password = password };
            string jsonRequest = "";
            try
            {
                jsonRequest = JsonSerializer.Serialize(loginRequest);
                // WARNING: Logging passwords is a security risk. For temporary debugging only.
                Console.WriteLine($"[DaminionApiClient] Login Request Payload (JSON): {jsonRequest} <-- CONTAINS SENSITIVE DATA");
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"[DaminionApiClient] Error serializing login request: {ex.Message}");
                throw;
            }

            var content = new StringContent(jsonRequest, Encoding.UTF8, "application/json");

            try
            {
                _httpClient.DefaultRequestHeaders.Remove("Cookie");
                _authenticationCookie = null;

                Console.WriteLine($"[DaminionApiClient] Sending POST request to {loginUrl}...");
                HttpResponseMessage response = await _httpClient.PostAsync(loginUrl, content);
                string responseBody = await response.Content.ReadAsStringAsync();

                Console.WriteLine($"[DaminionApiClient] Login Response Status Code: {response.StatusCode} ({response.ReasonPhrase})");
                Console.WriteLine($"[DaminionApiClient] Login Response Headers: {response.Headers.ToString().Trim()}");
                Console.WriteLine($"[DaminionApiClient] Login Response Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 1000))}");

                if (response.IsSuccessStatusCode)
                {
                    if (response.Headers.TryGetValues("Set-Cookie", out IEnumerable<string>? cookieValues))
                    {

                        _authenticationCookie = cookieValues.FirstOrDefault(c => c.StartsWith(".AspNet.ApplicationCookie=", StringComparison.OrdinalIgnoreCase));
                        if (!string.IsNullOrEmpty(_authenticationCookie))
                        {
                            _authenticationCookie = _authenticationCookie.Split(';')[0];
                            _httpClient.DefaultRequestHeaders.Add("Cookie", _authenticationCookie);
                            Console.WriteLine($"[DaminionApiClient] Authentication cookie found and applied: {_authenticationCookie.Substring(0, Math.Min(_authenticationCookie.Length, 50))}...");
                            return true;
                        }
                        else
                        {
                            Console.Error.WriteLine("[DaminionApiClient] Login HTTP call successful, but 'AspNet.ApplicationCookie' not found in 'Set-Cookie' header.");
                            _authenticationCookie = null;
                            return false;
                        }
                    }
                    else
                    {
                        Console.Error.WriteLine("[DaminionApiClient] Login HTTP call successful, but 'Set-Cookie' header was not found in the response.");
                        _authenticationCookie = null;
                        return false;
                    }
                }
                else
                {
                    Console.Error.WriteLine($"[DaminionApiClient] Login HTTP call failed. Full Response Body: {responseBody}");
                    _authenticationCookie = null;
                    return false;
                }
            }
            catch (HttpRequestException ex)
            {
                Console.Error.WriteLine($"[DaminionApiClient] HTTP request error during login to {loginUrl}: {ex.Message}");
                if (ex.InnerException != null) { Console.Error.WriteLine($"[DaminionApiClient] Inner Exception: {ex.InnerException.Message}"); }
                Console.Error.WriteLine($"[DaminionApiClient] HttpRequestException StackTrace: {ex.StackTrace}");
                _authenticationCookie = null;
                throw;
            }
            catch (TaskCanceledException ex)
            {
                Console.Error.WriteLine($"[DaminionApiClient] Login request to {loginUrl} timed out after {_httpClient.Timeout.TotalSeconds} seconds: {ex.Message}");
                if (ex.InnerException != null) { Console.Error.WriteLine($"[DaminionApiClient] Inner Exception (Timeout): {ex.InnerException.Message}"); }
                _authenticationCookie = null;
                throw new HttpRequestException($"Login request timed out. Timeout: {_httpClient.Timeout.TotalSeconds}s.", ex);
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"[DaminionApiClient] An unexpected error occurred during login: {ex.Message}");
                if (ex.InnerException != null) { Console.Error.WriteLine($"[DaminionApiClient] Inner Exception: {ex.InnerException.Message}"); }
                Console.Error.WriteLine($"[DaminionApiClient] Exception StackTrace: {ex.StackTrace}");
                _authenticationCookie = null;
                throw;
            }
        }

        /// <summary>
        /// Asynchronously retrieves the list of tags from the Daminion server.
        /// </summary>
        /// <returns></returns>
        // Inside DaminionApiClient class in DaminionOllamaInteractionLib project

        // Ensure the return type is Task<DaminionGetTagsResponse?>
        public async Task<DaminionGetTagsResponse?> GetTagsAsync()
        {
            Console.WriteLine("[DaminionApiClient] Attempting GetTagsAsync...");
            if (!IsAuthenticated || string.IsNullOrEmpty(_apiBaseUrl))
            {
                Console.Error.WriteLine("[DaminionApiClient] GetTags Error: Client is not authenticated or API base URL is not set.");
                // Return the response object with error details
                return new DaminionGetTagsResponse { Success = false, Error = "Not authenticated or API base URL not set." };
            }

            string tagsUrl = $"{_apiBaseUrl}/api/settings/getTags";
            Console.WriteLine($"[DaminionApiClient] GetTags URL: {tagsUrl}");
            try
            {
                _httpClient.DefaultRequestHeaders.Accept.Clear();
                _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

                HttpResponseMessage response = await _httpClient.GetAsync(tagsUrl);
                string responseBody = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"[DaminionApiClient] GetTags Response Status Code: {response.StatusCode}");

                if (response.IsSuccessStatusCode)
                {
                    DaminionGetTagsResponse? getTagsResponse = null;
                    try
                    {
                        getTagsResponse = JsonSerializer.Deserialize<DaminionGetTagsResponse>(responseBody);
                    }
                    catch (JsonException jsonEx)
                    {
                        Console.Error.WriteLine($"[DaminionApiClient] Error deserializing GetTags response: {jsonEx.Message}. Body: {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                        // Return the response object with error details
                        return new DaminionGetTagsResponse { Success = false, Error = $"JSON Deserialization error: {jsonEx.Message}" };
                    }

                    // Return the entire DaminionGetTagsResponse object
                    if (getTagsResponse != null) // Check if deserialization was successful
                    {
                        if (getTagsResponse.Success)
                        {
                            Console.WriteLine($"[DaminionApiClient] Successfully fetched {getTagsResponse.Data?.Count ?? 0} tags.");
                        }
                        else
                        {
                            Console.Error.WriteLine($"[DaminionApiClient] GetTags API call reported failure or bad data. Success: {getTagsResponse.Success}, Error: {getTagsResponse.Error}, Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                        }
                        return getTagsResponse;
                    }
                    else
                    {
                        // Should not happen if deserialization didn't throw, but as a fallback
                        Console.Error.WriteLine($"[DaminionApiClient] GetTags deserialization resulted in null object. Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                        return new DaminionGetTagsResponse { Success = false, Error = "Deserialization resulted in null object." };
                    }
                }
                else
                {
                    Console.Error.WriteLine($"[DaminionApiClient] GetTags HTTP call failed. Status: {response.StatusCode}, Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                    // Return the response object with error details
                    return new DaminionGetTagsResponse { Success = false, Error = $"HTTP Error: {response.StatusCode}" };
                }
            }
            catch (HttpRequestException ex)
            {
                Console.Error.WriteLine($"[DaminionApiClient] HTTP request error during GetTags: {ex.Message}");
                return new DaminionGetTagsResponse { Success = false, Error = $"HTTP Request Exception: {ex.Message}" };
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"[DaminionApiClient] An unexpected error occurred during GetTags: {ex.Message}");
                return new DaminionGetTagsResponse { Success = false, Error = $"Unexpected Exception: {ex.Message}" };
            }
        }
        /// <summary>
        /// Asynchronously retrieves the absolute paths of media items from the Daminion server.
        /// </summary>
        /// <param name="itemIds"></param>
        /// <returns></returns>
        public async Task<DaminionPathResult> GetAbsolutePathsAsync(List<long> itemIds)
        {
            Console.WriteLine($"[DaminionApiClient] Attempting GetAbsolutePathsAsync for {itemIds?.Count} items...");
            var result = new DaminionPathResult { Success = false, Paths = new Dictionary<string, string>() };
            if (!IsAuthenticated || string.IsNullOrEmpty(_apiBaseUrl))
            {
                result.ErrorMessage = "Client is not authenticated or API base URL is not set.";
                Console.Error.WriteLine($"[DaminionApiClient] GetAbsolutePaths Error: {result.ErrorMessage}");
                return result;
            }
            if (itemIds == null || !itemIds.Any())
            {
                result.ErrorMessage = "Item IDs list cannot be null or empty.";
                Console.Error.WriteLine($"[DaminionApiClient] GetAbsolutePaths Error: {result.ErrorMessage}");
                return result;
            }

            string idsQueryParam = string.Join(",", itemIds);
            string pathsUrl = $"{_apiBaseUrl}/api/mediaItems/getAbsolutePaths?ids={idsQueryParam}";
            Console.WriteLine($"[DaminionApiClient] GetAbsolutePaths URL: {pathsUrl}");

            try
            {
                _httpClient.DefaultRequestHeaders.Accept.Clear();
                _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

                HttpResponseMessage response = await _httpClient.GetAsync(pathsUrl);
                string responseBody = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"[DaminionApiClient] GetAbsolutePaths Response Status Code: {response.StatusCode}");

                if (response.IsSuccessStatusCode)
                {
                    Dictionary<string, string>? paths = null;
                    try
                    {
                        paths = JsonSerializer.Deserialize<Dictionary<string, string>>(responseBody);
                    }
                    catch (System.Text.Json.JsonException ex)
                    {
                        Console.Error.WriteLine($"[DaminionApiClient] Failed to deserialize paths directly: {ex.Message}. Body(snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                        result.ErrorMessage = $"Failed to deserialize paths response: {ex.Message}";
                    }

                    if (paths != null && paths.Any())
                    {
                        result.Paths = paths;
                        result.Success = true;
                        Console.WriteLine($"[DaminionApiClient] Successfully fetched {paths.Count} absolute paths.");
                    }
                    else if (string.IsNullOrEmpty(result.ErrorMessage))
                    {
                        result.ErrorMessage = "Successfully called API for paths, but no paths data was returned or parsed correctly.";
                        Console.Error.WriteLine($"[DaminionApiClient] {result.ErrorMessage} Body(snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                    }
                    return result;
                }
                else
                {
                    result.ErrorMessage = $"API call for paths failed. Status: {response.StatusCode}";
                    Console.Error.WriteLine($"[DaminionApiClient] {result.ErrorMessage} Body(snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                    return result;
                }
            }
            catch (Exception ex)
            {
                result.ErrorMessage = $"Error getting absolute paths: {ex.Message}";
                Console.Error.WriteLine($"[DaminionApiClient] GetAbsolutePaths Exception: {ex.Message} StackTrace: {ex.StackTrace}");
                return result;
            }
        }

        /// <summary>
        /// Searches for media items in Daminion based on a queryLine and operators (f parameter).
        /// Corresponds to Daminion API endpoint GET /api/mediaItems/get.
        /// </summary>
        /// <param name="queryLine">Search conditions separated by a semicolon[cite: 69]. Optional[cite: 70].</param>
        /// <param name="f_operators">Logical operators separated by a semicolon (the 'f' parameter)[cite: 71]. Optional[cite: 72].</param>
        /// <param name="pageSize">Page size. Can take positive integer values from 0 to 1000[cite: 73]. Optional, defaults to 0 if not specified[cite: 74].</param>
        /// <param name="pageIndex">The serial number of the requested page[cite: 75]. Optional, defaults to 0 if not specified[cite: 76].</param>
        /// <returns>A DaminionSearchMediaItemsResponse containing the media items or an error.</returns>
        public async Task<DaminionSearchMediaItemsResponse?> SearchMediaItemsAsync(
            string? queryLine = null, // Made queryLine nullable as it's optional
            string? f_operators = null,
            int pageSize = 100, // Defaulting to a reasonable page size
            int pageIndex = 0)
        {
            Console.WriteLine($"[DaminionApiClient] Attempting SearchMediaItemsAsync with queryLine: '{queryLine}' and f_operators: '{f_operators}'");
            if (!IsAuthenticated || string.IsNullOrEmpty(_apiBaseUrl))
            {
                Console.Error.WriteLine("[DaminionApiClient] SearchMediaItems Error: Client is not authenticated or API base URL is not set.");
                return new DaminionSearchMediaItemsResponse { Success = false, Error = "Client not authenticated." };
            }

            var queryParams = new Dictionary<string, string>();
            if (!string.IsNullOrEmpty(queryLine))
            {
                queryParams.Add("queryLine", queryLine); // [cite: 69]
            }
            if (!string.IsNullOrEmpty(f_operators))
            {
                queryParams.Add("f", f_operators); // [cite: 71]
            }
            // API doc says page size 0-1000[cite: 73].
            // If not specified, page size is 0[cite: 74], which might mean "all" or "default", be cautious.
            // For robust pagination, always specify a positive page size if you expect many results.
            queryParams.Add("size", pageSize.ToString()); // [cite: 73]
            queryParams.Add("index", pageIndex.ToString()); // [cite: 75]
                                                            // sortTag and sort parameters are also available if needed [cite: 77, 79]

            string queryString = await new FormUrlEncodedContent(queryParams).ReadAsStringAsync();
            string searchUrl = $"{_apiBaseUrl}/api/mediaItems/get?{queryString}"; // [cite: 69]
            Console.WriteLine($"[DaminionApiClient] SearchMediaItems URL: {searchUrl}");

            try
            {
                _httpClient.DefaultRequestHeaders.Accept.Clear();
                _httpClient.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

                HttpResponseMessage response = await _httpClient.GetAsync(searchUrl);
                string responseBody = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"[DaminionApiClient] SearchMediaItems Response Status Code: {response.StatusCode}");

                if (response.IsSuccessStatusCode)
                {
                    DaminionSearchMediaItemsResponse? searchResponse = null;
                    try
                    {
                        searchResponse = System.Text.Json.JsonSerializer.Deserialize<DaminionSearchMediaItemsResponse>(responseBody);
                    }
                    catch (System.Text.Json.JsonException jsonEx)
                    {
                        Console.Error.WriteLine($"[DaminionApiClient] Error deserializing SearchMediaItems response: {jsonEx.Message}. Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                        return new DaminionSearchMediaItemsResponse { Success = false, Error = $"JSON Deserialization error: {jsonEx.Message}" };
                    }

                    if (searchResponse != null && searchResponse.Success) // [cite: 83]
                    {
                        Console.WriteLine($"[DaminionApiClient] Successfully fetched {searchResponse.MediaItems?.Count ?? 0} media items.");
                        return searchResponse; // [cite: 83]
                    }
                    else
                    {
                        string errorMsg = searchResponse?.Error ?? "API call reported failure or bad data."; // [cite: 82]
                        Console.Error.WriteLine($"[DaminionApiClient] SearchMediaItems API call failed or returned unsuccessful. Success: {searchResponse?.Success}, Error: {errorMsg}, Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                        return new DaminionSearchMediaItemsResponse { Success = false, Error = errorMsg, MediaItems = searchResponse?.MediaItems };
                    }
                }
                else
                {
                    Console.Error.WriteLine($"[DaminionApiClient] SearchMediaItems HTTP call failed. Status: {response.StatusCode}, Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                    return new DaminionSearchMediaItemsResponse { Success = false, Error = $"HTTP Error: {response.StatusCode}" };
                }
            }
            catch (System.Net.Http.HttpRequestException ex)
            {
                Console.Error.WriteLine($"[DaminionApiClient] HTTP request error during SearchMediaItems: {ex.Message}");
                return new DaminionSearchMediaItemsResponse { Success = false, Error = $"HTTP Request Exception: {ex.Message}" };
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"[DaminionApiClient] An unexpected error occurred during SearchMediaItems: {ex.Message}");
                return new DaminionSearchMediaItemsResponse { Success = false, Error = $"Unexpected Exception: {ex.Message}" };
            }
        }


        /// <summary>
        /// Asynchronously updates the metadata of items in Daminion.
        /// </summary>
        /// <param name="itemIds"></param>
        /// <param name="operations"></param>
        /// <returns></returns>
        public async Task<DaminionBatchChangeResponse?> UpdateItemMetadataAsync(List<long> itemIds, List<DaminionUpdateOperation> operations)
        {
            Console.WriteLine($"[DaminionApiClient] Attempting UpdateItemMetadataAsync for {itemIds?.Count} items with {operations?.Count} operations...");
            if (!IsAuthenticated || string.IsNullOrEmpty(_apiBaseUrl))
            {
                Console.Error.WriteLine("[DaminionApiClient] UpdateItemMetadata Error: Client is not authenticated or API base URL is not set.");
                return new DaminionBatchChangeResponse { Success = false, Error = "Not authenticated." };
            }
            if (itemIds == null || !itemIds.Any() || operations == null || !operations.Any())
            {
                Console.Error.WriteLine("[DaminionApiClient] UpdateItemMetadata Error: Item IDs and operations list cannot be null or empty.");
                return new DaminionBatchChangeResponse { Success = false, Error = "Item IDs or operations missing." };
            }

            string updateUrl = $"{_apiBaseUrl}/api/itemData/batchChange";
            Console.WriteLine($"[DaminionApiClient] UpdateItemMetadata URL: {updateUrl}");
            var requestPayload = new DaminionBatchChangeRequest
            {
                Ids = itemIds,
                Data = operations
            };

            string jsonRequest = "";
            try
            {
                jsonRequest = JsonSerializer.Serialize(requestPayload);
                Console.WriteLine($"[DaminionApiClient] UpdateItemMetadata Request Payload (snippet): {jsonRequest.Substring(0, Math.Min(jsonRequest.Length, 500))}...");
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"[DaminionApiClient] Error serializing update metadata request: {ex.Message}");
                return new DaminionBatchChangeResponse { Success = false, Error = $"Serialization error: {ex.Message}" };
            }
            var content = new StringContent(jsonRequest, Encoding.UTF8, "application/json");

            try
            {
                HttpResponseMessage response = await _httpClient.PostAsync(updateUrl, content);
                string responseBody = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"[DaminionApiClient] UpdateItemMetadata Response Status Code: {response.StatusCode}");

                DaminionBatchChangeResponse? batchChangeResponse = null;
                try
                {
                    batchChangeResponse = JsonSerializer.Deserialize<DaminionBatchChangeResponse>(responseBody);
                }
                catch (System.Text.Json.JsonException jsonEx)
                {
                    Console.Error.WriteLine($"[DaminionApiClient] Error deserializing batchChange response: {jsonEx.Message}. Body(snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                    if (response.IsSuccessStatusCode) return new DaminionBatchChangeResponse { Success = true, Error = "Response was not valid JSON, but HTTP status was success." };
                    return new DaminionBatchChangeResponse { Success = false, Error = $"JSON Deserialization error: {jsonEx.Message}" };
                }

                if (batchChangeResponse == null)
                {
                    if (response.IsSuccessStatusCode && string.IsNullOrWhiteSpace(responseBody))
                    {
                        Console.WriteLine("[DaminionApiClient] UpdateItemMetadata returned success status with empty body. Assuming success.");
                        return new DaminionBatchChangeResponse { Success = true };
                    }
                    Console.Error.WriteLine($"[DaminionApiClient] Failed to deserialize batchChange response or response object was null. Status: {response.StatusCode}, Body(snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                    return new DaminionBatchChangeResponse { Success = false, Error = $"Failed to deserialize response or null object. Status: {response.StatusCode}" };
                }

                if (!batchChangeResponse.Success)
                {
                    Console.Error.WriteLine($"[DaminionApiClient] UpdateItemMetadata operation reported failure. Error: {batchChangeResponse.Error}. Body(snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                }
                else
                {
                    Console.WriteLine("[DaminionApiClient] UpdateItemMetadata reported success.");
                }
                return batchChangeResponse;
            }
            catch (HttpRequestException httpEx)
            {
                Console.Error.WriteLine($"[DaminionApiClient] HTTP request error updating item metadata: {httpEx.Message}");
                throw;
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"[DaminionApiClient] An unexpected error occurred updating item metadata: {ex.Message}");
                return new DaminionBatchChangeResponse { Success = false, Error = $"Exception: {ex.Message}" };
            }
        }

        public void Dispose()
        {
            _httpClient?.Dispose();
            GC.SuppressFinalize(this);
        }

        // Inside DaminionApiClient class

        /// <summary>
        /// Asynchronously retrieves the values for a specified indexed tag from the Daminion server.
        /// </summary>
        /// <param name="indexedTagId">ID of the tag whose values should be found. [cite: 23]</param>
        /// <param name="pageSize">Page size (positive integer, max 2,147,483,647). [cite: 24]</param>
        /// <param name="pageIndex">Page serial number (0 to 2,147,483,647). [cite: 25]</param>
        /// <param name="parentValueId">Limits search level. 0 for root, -2 for thorough search, or specific parent tag value ID. [cite: 26]</param>
        /// <param name="filter">Case-insensitive search string to filter values. [cite: 27]</param>
        /// <returns>A DaminionGetTagValuesResponse containing the tag values or an error.</returns>
        public async Task<DaminionGetTagValuesResponse?> GetTagValuesAsync(
            long indexedTagId,
            int pageSize = 100, // Default page size
            int pageIndex = 0,
            long parentValueId = 0, // Default to root level [cite: 26]
            string filter = "")
        {
            Console.WriteLine($"[DaminionApiClient] Attempting GetTagValuesAsync for tag ID: {indexedTagId}...");
            if (!IsAuthenticated || string.IsNullOrEmpty(_apiBaseUrl))
            {
                Console.Error.WriteLine("[DaminionApiClient] GetTagValues Error: Client is not authenticated or API base URL is not set.");
                return new DaminionGetTagValuesResponse { Success = false, Error = "Client not authenticated." };
            }

            // Construct the query parameters
            var queryParams = new Dictionary<string, string>
    {
        { "indexedTagId", indexedTagId.ToString() },
        { "pageSize", pageSize.ToString() },
        { "pageIndex", pageIndex.ToString() },
        { "parentValueId", parentValueId.ToString() }
    };
            if (!string.IsNullOrEmpty(filter))
            {
                queryParams.Add("filter", filter);
            }

            string queryString = await new FormUrlEncodedContent(queryParams).ReadAsStringAsync();
            string getTagValuesUrl = $"{_apiBaseUrl}/api/indexedTagValues/getIndexedTagValues?{queryString}";
    Console.WriteLine($"[DaminionApiClient] GetTagValues URL: {getTagValuesUrl}");

            try
            {
                _httpClient.DefaultRequestHeaders.Accept.Clear();
                _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

                HttpResponseMessage response = await _httpClient.GetAsync(getTagValuesUrl);
                string responseBody = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"[DaminionApiClient] GetTagValues Response Status Code: {response.StatusCode}");

                if (response.IsSuccessStatusCode)
                {
                    DaminionGetTagValuesResponse? getValuesResponse = null;
                    try
                    {
                        getValuesResponse = JsonSerializer.Deserialize<DaminionGetTagValuesResponse>(responseBody);
                    }
                    catch (JsonException jsonEx)
                    {
                        Console.Error.WriteLine($"[DaminionApiClient] Error deserializing GetTagValues response: {jsonEx.Message}. Body: {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                        return new DaminionGetTagValuesResponse { Success = false, Error = $"JSON Deserialization error: {jsonEx.Message}" };
                    }

                    if (getValuesResponse != null && getValuesResponse.Success)
                    {
                        Console.WriteLine($"[DaminionApiClient] Successfully fetched {getValuesResponse.Values?.Count ?? 0} tag values for tag ID {indexedTagId}.");
                        return getValuesResponse;
                    }
                    else
                    {
                        string errorMsg = getValuesResponse?.Error ?? "API call reported failure or bad data.";
                        Console.Error.WriteLine($"[DaminionApiClient] GetTagValues API call failed or returned unsuccessful. Success: {getValuesResponse?.Success}, Error: {errorMsg}, Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                        return new DaminionGetTagValuesResponse { Success = false, Error = errorMsg, Values = getValuesResponse?.Values /* preserve values if any */ };
                    }
                }
                else
                {
                    Console.Error.WriteLine($"[DaminionApiClient] GetTagValues HTTP call failed. Status: {response.StatusCode}, Body (snippet): {responseBody.Substring(0, Math.Min(responseBody.Length, 500))}");
                    return new DaminionGetTagValuesResponse { Success = false, Error = $"HTTP Error: {response.StatusCode}" };
                }
            }
            catch (HttpRequestException ex)
            {
                Console.Error.WriteLine($"[DaminionApiClient] HTTP request error during GetTagValues: {ex.Message}");
                return new DaminionGetTagValuesResponse { Success = false, Error = $"HTTP Request Exception: {ex.Message}" };
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"[DaminionApiClient] An unexpected error occurred during GetTagValues: {ex.Message}");
                return new DaminionGetTagValuesResponse { Success = false, Error = $"Unexpected Exception: {ex.Message}" };
            }
        }

        // Example: Log API requests and responses
        private void LogApiRequest(string endpoint, object? payload = null)
        {
            Logger.Information("API Request: {Endpoint}, Payload: {@Payload}", endpoint, payload);
        }
        private void LogApiResponse(string endpoint, object? response = null)
        {
            Logger.Information("API Response: {Endpoint}, Response: {@Response}", endpoint, response);
        }
        private void LogApiError(string endpoint, Exception ex)
        {
            Logger.Error(ex, "API Error: {Endpoint}", endpoint);
        }
    }

    /// <summary>
    /// Represents the request payload for logging in to Daminion.
    /// </summary>
    internal class LoginRequest
    {
        [JsonPropertyName("usernameOrEmailAddress")]
        public string UsernameOrEmailAddress { get; set; } = string.Empty;

        [JsonPropertyName("password")]
        public string Password { get; set; } = string.Empty;
    }
}
]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaInteractionLib\DaminionOllamaInteractionLib.csproj">
<![CDATA[
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <Platforms>AnyCPU;x64</Platforms>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Magick.NET-Q16-AnyCPU" Version="14.6.0" />
    <PackageReference Include="Serilog" Version="4.3.0" />
    <PackageReference Include="Serilog.Sinks.File" Version="7.0.0" />
  </ItemGroup>

</Project>

]]>
</File>


<File Path="C:\Users\User\source\repos\deanable\DaminionOllamaProcessor\DaminionOllamaProcessor.sln">
<![CDATA[

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.13.35931.197
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DaminionOllamaInteractionLib", "DaminionOllamaInteractionLib\DaminionOllamaInteractionLib.csproj", "{8D73EA54-88AC-4F14-88A0-9468CD8C1862}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DaminionOllamaApp", "DaminionOllamaApp\DaminionOllamaApp.csproj", "{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		DefaultBuild|Any CPU = DefaultBuild|Any CPU
		DefaultBuild|ARM = DefaultBuild|ARM
		DefaultBuild|ARM64 = DefaultBuild|ARM64
		DefaultBuild|x64 = DefaultBuild|x64
		DefaultBuild|x86 = DefaultBuild|x86
		Release|Any CPU = Release|Any CPU
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Debug|ARM.Build.0 = Debug|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Debug|ARM64.Build.0 = Debug|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Debug|x64.ActiveCfg = Debug|x64
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Debug|x64.Build.0 = Debug|x64
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Debug|x86.ActiveCfg = Debug|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Debug|x86.Build.0 = Debug|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.DefaultBuild|Any CPU.ActiveCfg = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.DefaultBuild|Any CPU.Build.0 = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.DefaultBuild|ARM.ActiveCfg = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.DefaultBuild|ARM.Build.0 = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.DefaultBuild|ARM64.ActiveCfg = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.DefaultBuild|ARM64.Build.0 = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.DefaultBuild|x64.ActiveCfg = Release|x64
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.DefaultBuild|x64.Build.0 = Release|x64
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.DefaultBuild|x86.ActiveCfg = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.DefaultBuild|x86.Build.0 = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Release|Any CPU.Build.0 = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Release|ARM.ActiveCfg = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Release|ARM.Build.0 = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Release|ARM64.ActiveCfg = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Release|ARM64.Build.0 = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Release|x64.ActiveCfg = Release|x64
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Release|x64.Build.0 = Release|x64
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Release|x86.ActiveCfg = Release|Any CPU
		{8D73EA54-88AC-4F14-88A0-9468CD8C1862}.Release|x86.Build.0 = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Debug|ARM.Build.0 = Debug|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Debug|ARM64.Build.0 = Debug|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Debug|x64.ActiveCfg = Debug|x64
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Debug|x64.Build.0 = Debug|x64
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Debug|x86.ActiveCfg = Debug|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Debug|x86.Build.0 = Debug|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.DefaultBuild|Any CPU.ActiveCfg = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.DefaultBuild|Any CPU.Build.0 = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.DefaultBuild|ARM.ActiveCfg = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.DefaultBuild|ARM.Build.0 = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.DefaultBuild|ARM64.ActiveCfg = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.DefaultBuild|ARM64.Build.0 = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.DefaultBuild|x64.ActiveCfg = Release|x64
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.DefaultBuild|x64.Build.0 = Release|x64
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.DefaultBuild|x86.ActiveCfg = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.DefaultBuild|x86.Build.0 = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Release|Any CPU.Build.0 = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Release|ARM.ActiveCfg = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Release|ARM.Build.0 = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Release|ARM64.ActiveCfg = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Release|ARM64.Build.0 = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Release|x64.ActiveCfg = Release|x64
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Release|x64.Build.0 = Release|x64
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Release|x86.ActiveCfg = Release|Any CPU
		{A6BE4A87-B4BA-41BC-8395-EF576BC47F22}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7A6AC139-D40F-460C-9FDE-646E70B1777E}
	EndGlobalSection
EndGlobal

]]>
</File>

